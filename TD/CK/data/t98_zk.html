if(!window.zk){
//ZK, Copyright 2009 Potix Corporation, LGPL
//jQuery, (c) John Resig, MIT
//Sizzle, (c) The Dojo Foundation, MIT
//jQuery Mousewheel, (c) Brandon Aaron, MIT

window.$eval=function(s){return eval(s);};

window.zkInitCrashTimer = setTimeout(function () {
	var zkErrorCode,
		z_runonce = document.querySelectorAll('.z-runonce')[0], 
		zk_proc = document.getElementById('zk_proc'),
		ztemp = document.querySelectorAll('.z-temp')[0],
		zna = document.getElementById('zna'),
		body = document.body;
	if (zk_proc) {
		if (z_runonce) { 
			if (ztemp) { 
				if (!zna)
					zkErrorCode = 1;
				else 
					zkErrorCode = 2;
			} else
				zkErrorCode = 3;
		} else { 
			if (ztemp) 
				zkErrorCode = 4;
			else
				zkErrorCode = 5;
		}
		
		if (!window.zkShowCrashMessage) {
			window.zkShowCrashMessage = function () {
				var style = '<style> a:visited {color: white;} </style>';
				var div = '<div style="background: rgb(35,48,64); text-align: center; color: white; position: absolute; \
					top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 50%; height: 300px; font-size: 20px;">';
				var icon = '<i class="z-icon-frown-o" style="font-size: 5em; display: block;"></i>';
				var msg = '<p>Something went wrong while loading the page.</p> \
					<p>Please try to reload or visit another page. If you are the administrator, \
					try to check your Javascript or Network console.</p>';
				var copyright = '<div style="text-align: right; margin-top: -18px">\
					<span style="font-size: 10px;">powered by </span>\
					<span style="font-size: 14px;"><a href="http://www.zkoss.org/">ZK</a></span></div>';
				var btn = '<button style="margin-top: 10px" onclick="location.reload();">Reload page</button>';
				switch (zkErrorCode) {
					case 1:
						msg = '<p>Error code 1: ZK error, before mounting. </p>' + msg;
						break;
					case 2:
						msg = '<p>Error code 2: ZK error, mounting. </p>' + msg;
						break;
					case 3:
						msg = '<p>Error code 3: ZK error, after mounting. </p>' + msg;
						break;
					case 4:
						msg = '<p>Error code 4: user error, wrong script. </p>' + msg;
						break;
					case 5:
						msg = '<p>Error code 5: user error, server response. </p>' + msg;
						break;
				}
				div = style + div + icon + msg + copyright + btn + '</div>';
				body.style.background = 'rgb(35,48,64)';
				body.innerHTML = div;
			}
		}
		window.zkShowCrashMessage(zkErrorCode);
	}
}, window.zkInitCrashTimeout >= 0 ? window.zkInitCrashTimeout * 1000 : 60000);

(function( window, undefined ) {






var
	
	readyList,

	
	rootjQuery,

	
	
	core_strundefined = typeof undefined,

	
	location = window.location,
	document = window.document,
	docElem = document.documentElement,

	




	




	
	class2type = {},

	
	core_deletedIds = [],

	core_version = "1.10.2",

	
	core_concat = core_deletedIds.concat,
	core_push = core_deletedIds.push,
	core_slice = core_deletedIds.slice,
	core_indexOf = core_deletedIds.indexOf,
	core_toString = class2type.toString,
	core_hasOwn = class2type.hasOwnProperty,
	core_trim = core_version.trim,

	
	jQuery = function( selector, context ) {
		
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	
	core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

	
	core_rnotwhite = /\S+/g,

	
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	
	
	
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,

	
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	},

	
	completed = function( event ) {

		
		if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
			detach();
			jQuery.ready();
		}
	},
	
	detach = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", completed, false );
			window.removeEventListener( "load", completed, false );

		} else {
			document.detachEvent( "onreadystatechange", completed );
			window.detachEvent( "onload", completed );
		}
	};

jQuery.fn = jQuery.prototype = {
	
	jquery: core_version,

	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem;

		
		if ( !selector ) {
			return this;
		}

		
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			
			if ( match && (match[1] || !context) ) {

				
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				
				} else {
					elem = document.getElementById( match[2] );

					
					
					if ( elem && elem.parentNode ) {
						
						
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			
			
			} else {
				return this.constructor( context ).find( selector );
			}

		
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		
		
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	
	selector: "",

	
	length: 0,

	toArray: function() {
		return core_slice.call( this );
	},

	
	
	get: function( num ) {
		return num == null ?

			
			this.toArray() :

			
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	
	
	pushStack: function( elems ) {

		
		var ret = jQuery.merge( this.constructor(), elems );

		
		ret.prevObject = this;
		ret.context = this.context;

		
		return ret;
	},

	
	
	
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		
		jQuery.ready.promise().done( fn );

		return this;
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	
	
	push: core_push,
	sort: [].sort,
	splice: [].splice
};


jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		
		i = 2;
	}

	
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		
		if ( (options = arguments[ i ]) != null ) {
			
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				
				if ( target === copy ) {
					continue;
				}

				
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					
					target[ name ] = jQuery.extend( deep, clone, copy );

				
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	
	return target;
};

jQuery.extend({
	
	
	expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),

	noConflict: function( deep ) {

		return jQuery;
	},

	
	isReady: false,

	
	
	readyWait: 1,

	
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	
	ready: function( wait ) {

		
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		
		jQuery.isReady = true;

		
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		
		readyList.resolveWith( document, [ jQuery ] );

		
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	
	
	
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return String( obj );
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ core_toString.call(obj) ] || "object" :
			typeof obj;
	},

	isPlainObject: function( obj ) {
		var key;

		
		
		
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			
			return false;
		}

		
		
		if ( jQuery.support.ownLast ) {
			for ( key in obj ) {
				return core_hasOwn.call( obj, key );
			}
		}

		
		
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	
	
	
	parseHTML: function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );
		if ( scripts ) {
			jQuery( scripts ).remove();
		}
		return jQuery.merge( [], parsed.childNodes );
	},

	parseJSON: function( data ) {
		
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		if ( data === null ) {
			return data;
		}

		if ( typeof data === "string" ) {

			
			data = jQuery.trim( data );

			if ( data ) {
				
				
				if ( rvalidchars.test( data.replace( rvalidescape, "@" )
					.replace( rvalidtokens, "]" )
					.replace( rvalidbraces, "")) ) {

					return ( new Function( "return " + data ) )();
				}
			}
		}

		jQuery.error( "Invalid JSON: " + data );
	},

	
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { 
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { 
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	
	
	
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			
			
			
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	
	
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				core_push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		
		
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		
		return core_concat.apply( [], ret );
	},

	
	guid: 1,

	
	
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		
		
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
		};

		
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	
	
	access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			length = elems.length,
			bulk = key == null;

		
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < length; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	
	
	
	swap: function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		
		
		
		if ( document.readyState === "complete" ) {
			
			setTimeout( jQuery.ready );

		
		} else if ( document.addEventListener ) {
			
			document.addEventListener( "DOMContentLoaded", completed, false );

			
			window.addEventListener( "load", completed, false );

		
		} else {
			
			document.attachEvent( "onreadystatechange", completed );

			
			window.attachEvent( "onload", completed );

			
			
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							
							
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						
						detach();

						
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};


jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || type !== "function" &&
		( length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj );
}


rootjQuery = jQuery(document);

(function( window, undefined ) {

var i,
	support,
	cachedruns,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,

	
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	hasDuplicate = false,
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
		return 0;
	},


	
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	

	
	whitespace = "[\\x20\\t\\r\\n\\f]",
	
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	
	
	
	identifier = characterEncoding.replace( "w", "w#" ),

	
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	
	
	
	
	
	
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rsibling = new RegExp( whitespace + "*[+~]" ),
	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		
		"ZID": /^\$((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		
		"ZTAG": /^((?:[@\w\u00c0-\uFFFF\*-]|\\.)+)/,
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		
		
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rnative = /^[^{]+\{\s*\[native \w/,

	
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rescape = /'|\\/g,

	
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		
		
		
		return high !== high || escapedWhitespace ?
			escaped :
			
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};


try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	
	
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		
		
		function( target, els ) {
			var j = target.length,
				i = 0;
			
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		
		if ( (match = rquickExpr.exec( selector )) ) {
			
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					
					
					if ( elem && elem.parentNode ) {
						
						
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			
			
			
			
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && context.parentNode || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}


function createCache() {
	var keys = [];

	function cache( key, value ) {
		
		if ( keys.push( key += " " ) > Expr.cacheLength ) {
			
			delete cache[ keys.shift() ];
		}
		return (cache[ key ] = value);
	}
	return cache;
}


function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}


function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		
		div = null;
	}
}


function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}


function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	
	if ( diff ) {
		return diff;
	}

	
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}


function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}


function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}


function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}


isXML = Sizzle.isXML = function( elem ) {
	
	
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};


support = Sizzle.support = {};


setDocument = Sizzle.setDocument = function( node ) {
	var doc = node ? node.ownerDocument || node : preferredDoc,
			parent = doc.defaultView;

	
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	
	document = doc;
	docElem = doc.documentElement;

	
	documentIsHTML = !isXML( doc );

	
	
	
	
	if ( parent && parent.attachEvent && parent !== parent.top ) {
		parent.attachEvent( "onbeforeunload", function() {
			setDocument();
		});
	}

	

	
	
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	

	
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	
	support.getElementsByClassName = assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		
		
		div.firstChild.className = "i";
		
		
		return div.getElementsByClassName("i").length === 2;
	});

	
	
	
	
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				
				
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		
		
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};
	
	Expr.find["ZID"] = function(selector, context) {
		return context == window || context == document ?
			zk.Widget.getElementsById(selector) :
			jq.grep(zk.Widget.getElementsById(selector), function (n) {
				return jq.isAncestor(context, n);
			});
	};
	
	Expr.find["ZTAG"] = function(selector, context) {
		return context == window || context == document ?
			zk.Widget.getElementsByName(selector.substring(1)) :
			jq.grep(zk.Widget.getElementsByName(selector.substring(1)), function (n) {
				return jq.isAncestor(context, n);
			});
	};


	

	

	
	rbuggyMatches = [];

	
	
	
	
	
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		
		
		assert(function( div ) {
			
			
			
			
			
			div.innerHTML = "<select><option selected=''></option></select>";

			
			
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			
			
			
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			
			
			
			
			
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "t", "" );

			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			
			
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			
			
			support.disconnectedMatch = matches.call( div, "div" );

			
			
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	

	
	
	
	contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	

	
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {

		
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );

		if ( compare ) {
			
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				
				if ( a === doc || contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || contains(preferredDoc, b) ) {
					return 1;
				}

				
				return sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		}

		
		return a.compareDocumentPosition ? -1 : 1;
	} :
	function( a, b ) {
		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		
		} else if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			
			siblingCheck( ap[i], bp[i] ) :

			
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			
			if ( ret || support.disconnectedMatch ||
					
					
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val === undefined ?
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null :
		val;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};


Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};


getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		
		for ( ; (node = elem[i]); i++ ) {
			
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		
		
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	

	return ret;
};

Expr = Sizzle.selectors = {

	
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				
				
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				
				(excess = tokenize( unquoted, true )) &&
				
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		
		"ZTAG": function(selector) {
			var tag = selector.substring(1);
			return function ( elem, context, xml, wgt ) {
				wgt = wgt ? wgt : zk.Widget.$(elem, {exact: true}) || false;
				return wgt && wgt.className.toLowerCase().endsWith(tag);
			}
		},

		
		"ZID": function(selector) {
			var id = selector.startsWith('$') ? selector.substring(1) : selector;
			return function ( elem, context, xml, wgt  ) {
				wgt = wgt ? wgt : zk.Widget.$(elem);
				return wgt ? wgt.id === id : false;
			}
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );
				
				
				if (!result) {
					var wgt = zk.Widget.$(elem, {exact: 1});
					if (wgt)
						result = wgt.get(name) || result;
				}

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						
						if ( forward && useCache ) {
							
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								
								(diff = nodeIndex = 0) || start.pop()) ) {

								
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						
						} else {
							
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			
			
			
			
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			
			
			
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		
		"not": markFunction(function( selector ) {
			
			
			
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		
		
		
		
		
		
		
		"lang": markFunction( function( lang ) {
			
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			
			
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			
			
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		
		"empty": function( elem ) {
			
			
			
			
			
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			
			
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
		},

		
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};
Expr.pseudos["nth"] = Expr.pseudos["eq"];

for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}


function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	
	
	
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base, selector ) {

	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		hasZTag = /@/.test(selector), 
		hasZID = /\$/.test(selector), 
		doneName = done++;

	return combinator.first ?
		
		function( elem, context, xml ) {
			
			if (hasZTag || hasZID) {
				var wgt = zk.Widget.$(elem, {exact: 1}),
				getParent = function (wgt) {
					if (dir === "parentNode")
						return wgt.parent;
					else
						return wgt[ dir ];
				};
			
				
				while ((wgt = wgt ? getParent(wgt) : zk.Widget.$(elem)) && (elem = zk.isLoaded('zul.sel') &&
						wgt.$instanceof(zul.sel.Treechildren, zul.sel.Treeitem) ?
						elem : wgt.$n())) {
					
					if (matcher( elem, context, xml, wgt ))
						return true;
				}
			} else {
				elem = elem[ dir ];
				while ( elem ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}

					if (dir == 'parentNode')
						elem = zk(elem).vparentNode(true);
					else
						elem = elem[ dir ];
				}
			}
		} :

		
		function( elem, context, xml ) {
			var data, cache, outerCache,
				dirkey = dirruns + " " + doneName;
			
			if (hasZTag || hasZID) {
				var wgt = zk.Widget.$(elem, {exact: 1}),
					getParent = function (wgt) {
						if (dir === "parentNode")
							return wgt.parent;
						else
							return wgt[ dir ];
					};
				
				
				while ((wgt = wgt ? getParent(wgt) : zk.Widget.$(elem)) && (elem = wgt.isRealElement() ?
						wgt.$n() : elem)) {
					
					if (matcher( elem, context, xml, wgt ))
						return true;
				}
			} else if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				elem = elem[ dir ];
				while (elem) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
							if ( (data = cache[1]) === true || data === cachedruns ) {
								return data === true;
							}
						} else {
							cache = outerCache[ dir ] = [ dirkey ];
							cache[1] = matcher( elem, context, xml ) || cachedruns;
							if ( cache[1] === true ) {
								return true;
							}
						}
					}
					if (dir == 'parentNode')
						elem = zk(elem).vparentNode(true);
					else
						elem = elem[ dir ];
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml, wgt) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml, wgt ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					
					[] :

					
					results :
				matcherIn;

		
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens , selector ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true, selector ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true, selector ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher, false, selector ) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			
			if ( matcher[ expando ] ) {
				
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	
	var matcherCachedRuns = 0,
		bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = matcherCachedRuns;
			}

			
			
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++matcherCachedRuns;
					}
				}

				
				if ( bySet ) {
					
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					
					setMatched = condense( setMatched );
				}

				
				push.apply( results, setMatched );

				
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group  ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i], selector );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		
		if ( match.length === 1 ) {

			
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
				}
				selector = selector.slice( tokens.shift().value.length );
			}

			
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && context.parentNode || context
					)) ) {

						
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	
	
	compile( selector, match )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector )
	);
	return results;
}




support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;



support.detectDuplicates = hasDuplicate;


setDocument();



support.sortDetached = assert(function( div1 ) {
	
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});




if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}



if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}



if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return (val = elem.getAttributeNode( name )) && val.specified ?
				val.value :
				elem[ name ] === true ? name.toLowerCase() : null;
		}
	});
}

jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );

var optionsCache = {};


function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}


jQuery.Callbacks = function( options ) {

	
	
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var 
		firing,
		
		memory,
		
		fired,
		
		firingLength,
		
		firingIndex,
		
		firingStart,
		
		list = [],
		
		stack = !options.once && [],
		
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; 
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		
		self = {
			
			add: function() {
				if ( list ) {
					
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								
								add( arg );
							}
						});
					})( arguments );
					
					
					if ( firing ) {
						firingLength = list.length;
					
					
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			
			
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			
			disabled: function() {
				return !list;
			},
			
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			
			locked: function() {
				return !stack;
			},
			
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];

					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function(  ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				
				
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		
		promise.pipe = promise.then;

		
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			
			promise[ tuple[1] ] = list.add;

			
			if ( stateString ) {
				list.add(function() {
					
					state = stateString;

				
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		
		promise.promise( deferred );

		
		if ( func ) {
			func.call( deferred, deferred );
		}

		
		return deferred;
	},

	
	when: function( subordinate  ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function( support ) {

	var all, a, input, select, fragment, opt, eventName, isSupported, i,
		div = document.createElement("div");

	
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	
	all = div.getElementsByTagName("*") || [];
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !a || !a.style || !all.length ) {
		return support;
	}

	
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";

	
	support.getSetAttribute = div.className !== "t";

	
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	
	
	support.tbody = !div.getElementsByTagName("tbody").length;

	
	
	support.htmlSerialize = !!div.getElementsByTagName("link").length;

	
	
	support.style = /top/.test( a.getAttribute("style") );

	
	
	support.hrefNormalized = a.getAttribute("href") === "/a";

	
	
	
	support.opacity = /^0.5/.test( a.style.opacity );

	
	
	support.cssFloat = !!a.style.cssFloat;

	
	support.checkOn = !!input.value;

	
	
	support.optSelected = opt.selected;

	
	support.enctype = !!document.createElement("form").enctype;

	
	
	support.html5Clone = document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>";

	
	support.inlineBlockNeedsLayout = false;
	support.shrinkWrapBlocks = false;
	support.pixelPosition = false;
	support.deleteExpando = true;
	support.noCloneEvent = true;
	support.reliableMarginRight = true;
	support.boxSizingReliable = true;

	
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	
	
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	
	input = document.createElement("input");
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	
	input.setAttribute( "checked", "t" );
	input.setAttribute( "name", "t" );

	fragment = document.createDocumentFragment();
	fragment.appendChild( input );

	
	
	support.appendChecked = input.checked;

	
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	
	
	
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	
	
	for ( i in { submit: true, change: true, focusin: true }) {
		div.setAttribute( eventName = "on" + i, "t" );

		support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	
	
	for ( i in jQuery( support ) ) {
		break;
	}
	support.ownLast = i !== "0";

	
	jQuery(function() {
		var container, marginDiv, tds,
			divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

		body.appendChild( container ).appendChild( div );

		
		
		
		
		
		
		
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		
		
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";

		
		
		jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
			support.boxSizing = div.offsetWidth === 4;
		});

		
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			
			
			
			
			marginDiv = div.appendChild( document.createElement("div") );
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";

			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== core_strundefined ) {
			
			
			
			
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			
			
			div.style.display = "block";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			if ( support.inlineBlockNeedsLayout ) {
				
				
				
				body.style.zoom = 1;
			}
		}

		body.removeChild( container );

		
		container = div = tds = marginDiv = null;
	});

	
	all = select = fragment = opt = a = input = null;

	return support;
})({});

var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

function internalData( elem, name, data, pvt  ){
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		
		
		isNode = elem.nodeType,

		
		
		cache = isNode ? jQuery.cache : elem,

		
		
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	
	
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		
		
		if ( isNode ) {
			id = elem[ internalKey ] = core_deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		
		
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	
	
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	
	
	
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	
	
	if ( typeof name === "string" ) {

		
		ret = thisCache[ name ];

		
		if ( ret == null ) {

			
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	
	
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			
			if ( !jQuery.isArray( name ) ) {

				
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				
				
				
				
				
				
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			
			
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	
	if ( !pvt ) {
		delete cache[ id ].data;

		
		
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	
	
	} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
		
		delete cache[ id ];

	
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	
	
	noData: {
		"applet": true,
		"embed": true,
		
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	},

	
	acceptData: function( elem ) {
		
		if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {
			return false;
		}

		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var attrs, name,
			data = null,
			i = 0,
			elem = this[0];

		
		

		
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attrs = elem.attributes;
					for ( ; i < attrs.length; i++ ) {
						name = attrs[i].name;

						if ( name.indexOf("data-") === 0 ) {
							name = jQuery.camelCase( name.slice(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			
			
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	
	
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
			} catch( e ) {}

			
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}


function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			
			
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	
	
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	
	
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});

function setClassName( elem, className ) {
	if (elem.className != className)
		elem.className = className;
}

var nodeHook, boolHook,
	rclass = /[\t\r\n\f]/g,
	rreturn = /\r/g,
	rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	getSetInput = jQuery.support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}
					setClassName( elem, jQuery.trim( cur ) );

				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}
					setClassName( elem, value ? jQuery.trim( cur ) : "" );
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( core_rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}


			
			} else if ( type === core_strundefined || type === "boolean" ) {
				if ( this.className ) {
					
					jQuery._data( this, "__className__", this.className );
				}

				
				
				
				
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var ret, hooks, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					
					ret.replace(rreturn, "") :
					
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				
				for ( ; i < max; i++ ) {
					option = options[ i ];

					
					if ( ( option.selected || i === index ) &&
							
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						
						value = jQuery( option ).val();

						
						if ( one ) {
							return value;
						}

						
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
						optionSet = true;
					}
				}

				
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		
		if ( typeof elem.getAttribute === core_strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		
		
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( core_rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				
				if ( jQuery.expr.match.bool.test( name ) ) {
					
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					
					
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					
					
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				
				
				
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});


boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;

	jQuery.expr.attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var fn = jQuery.expr.attrHandle[ name ],
				ret = isXML ?
					undefined :
					
					(jQuery.expr.attrHandle[ name ] = undefined) !=
						getter( elem, name, isXML ) ?

						name.toLowerCase() :
						null;
			jQuery.expr.attrHandle[ name ] = fn;
			return ret;
		} :
		function( elem, name, isXML ) {
			return isXML ?
				undefined :
				elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
		};
});


if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				
				elem.defaultValue = value;
			} else {
				
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}


if ( !getSetAttribute ) {

	
	
	nodeHook = {
		set: function( elem, value, name ) {
			
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			
			return name === "value" || value === elem.getAttribute( name ) ?
				value :
				undefined;
		}
	};
	jQuery.expr.attrHandle.id = jQuery.expr.attrHandle.name = jQuery.expr.attrHandle.coords =
		
		function( elem, name, isXML ) {
			var ret;
			return isXML ?
				undefined :
				(ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
		};
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			return ret && ret.specified ?
				ret.value :
				undefined;
		},
		set: nodeHook.set
	};

	
	
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	
	
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}




if ( !jQuery.support.hrefNormalized ) {
	
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			
			
			
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}



if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});


if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}


jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !jQuery.support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			
			
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});
var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}


jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		
		if ( !elemData ) {
			return;
		}

		
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				
				
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			
			eventHandle.elem = elem;
		}

		
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			
			if ( !type ) {
				continue;
			}

			
			special = jQuery.event.special[ type ] || {};

			
			type = ( selector ? special.delegateType : special.bindType ) || type;

			
			special = jQuery.event.special[ type ] || {};

			
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			
			jQuery.event.global[ type ] = true;
		}

		
		elem = null;
	},

	
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			
			
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			
			
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = core_hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		
		
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				
				
				
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						
						
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = core_slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		
		args[0] = event;
		event.delegateTarget = this;

		
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				
				
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		
		
		
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			
			for ( ; cur != this; cur = cur.parentNode || this ) {
				

				
				
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		
		
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		
		
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		
		
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			
			
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			
			noBubble: true
		},
		focus: {
			
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						
						
						
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		
		
		
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			
			
			if ( typeof elem[ name ] === core_strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		
		
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	
	} else {
		this.type = src;
	}

	
	if ( props ) {
		jQuery.extend( this, props );
	}

	
	this.timeStamp = src && src.timeStamp || jQuery.now();

	
	this[ jQuery.expando ] = true;
};



jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		
		if ( e.preventDefault ) {
			e.preventDefault();

		
		
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		
		
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};


jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			
			
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});


if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			
		},

		postDispatch: function( event ) {
			
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			
			jQuery.event.remove( this, "._submit" );
		}
	};
}


if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				
				
				
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}


if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn,  one ) {
		var type, origFn;

		
		if ( typeof types === "object" ) {
			
			if ( typeof selector !== "string" ) {
				
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				
				fn = data;
				data = undefined;
			} else {
				
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});
var isSimple = /^.[^:#\[\.,]*$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	rneedsContext = jQuery.expr.match.needsContext,
	
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},

	is: function( selector ) {
		return !!winnow(
			this,

			
			
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					cur = ret.push( cur );
					break;
				}
			}
		}

		return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
	},

	
	
	index: function( elem ) {

		
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		
		return jQuery.inArray(
			
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( jQuery.unique(all) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});


function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
	
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		
		
		_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	
	remove: function( selector, keepData ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			
			
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var
			
			args = jQuery.map( this, function( elem ) {
				return [ elem.nextSibling, elem.parentNode ];
			}),
			i = 0;

		
		this.domManip( arguments, function( elem ) {
			var next = args[ i++ ],
				parent = args[ i++ ];

			if ( parent ) {
				
				if ( next && next.parentNode !== parent ) {
					next = this.nextSibling;
				}
				jQuery( this ).remove();
				parent.insertBefore( elem, next );
			}
		
		}, true );

		
		return i ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback, allowIntersection ) {

		
		args = core_concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		
		if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback, allowIntersection );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				
				
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					
					jQuery.map( scripts, restoreScript );

					
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								
								jQuery._evalUrl( node.src );
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				
				fragment = first = null;
			}
		}

		return this;
	}
});



function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}


function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}


function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	
	if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		
		dest.removeAttribute( jQuery.expando );
	}

	
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	
	
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		
		
		
		
		if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
		
		
		

		dest.defaultChecked = dest.checked = src.checked;

		
		
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	
	
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	
	
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			
			core_push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}


function fixDefaultChecked( elem ) {
	if ( manipulation_rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			
			destElements = getAll( clone );
			srcElements = getAll( elem );

			
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					
					if ( !jQuery.support.tbody ) {

						
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					
					tmp.textContent = "";

					
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					
					tmp = safe.lastChild;
				}
			}
		}

		
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		
		
		if ( !jQuery.support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			
			
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			
			tmp = getAll( safe.appendChild( elem ), "script" );

			
			if ( contains ) {
				setGlobalEval( tmp );
			}

			
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems,  acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					
					if ( cache[ id ] ) {

						delete cache[ id ];

						
						
						
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== core_strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						core_deletedIds.push( id );
					}
				}
			}
		}
	},

	_evalUrl: function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	}
});
jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});
var iframe, getStyles, curCSS,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	
	
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


function vendorPropName( style, name ) {

	
	if ( name in style ) {
		return name;
	}

	
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	
	
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			
			
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			
			
			
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	}

	
	
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			var len, styles,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	
	
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	
	
	cssProps: {
		
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	
	style: function( elem, name, value, extra ) {
		
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		
		
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		
		if ( value !== undefined ) {
			type = typeof value;

			
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				
				type = "number";
			}

			
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			
			
			if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				
				
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		
		
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});



if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, _computed ) {
		var width, minWidth, maxWidth,
			computed = _computed || getStyles( elem ),

			
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
			style = elem.style;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			
			
			
			
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, _computed ) {
		var left, rs, rsLeft,
			computed = _computed || getStyles( elem ),
			ret = computed ? computed[ name ] : undefined,
			style = elem.style;

		
		
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		
		

		
		
		
		
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		
		4 :
		
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	
	
	
	if ( val <= 0 || val == null ) {
		
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		
		
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		
		val = parseFloat( val ) || 0;
	}

	
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}


function css_defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		
		if ( display === "none" || !display ) {
			
			iframe = ( iframe ||
				jQuery("<iframe frameborder='0' width='0' height='0'/>")
				.css( "cssText", "display:block !important" )
			).appendTo( doc.documentElement );

			
			doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
			doc.write("<!doctype html><html><body>");
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		
		elemdisplay[ nodeName ] = display;
	}

	return display;
}


function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
		display = jQuery.css( elem[0], "display" );
	elem.remove();
	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				
				
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			
			
			style.zoom = 1;

			
			
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				
				
				
				style.removeAttribute( "filter" );

				
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}



jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				if ( computed ) {
					
					
					return jQuery.swap( elem, { "display": "inline-block" },
						curCSS, [ elem, "marginRight" ] );
				}
			}
		};
	}

	
	
	
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						computed = curCSS( elem, prop );
						
						return rnumnonpx.test( computed ) ?
							jQuery( elem ).position()[ prop ] + "px" :
							computed;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		
		
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
			(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}


jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function(){
			var type = this.type;
			
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !manipulation_rcheckableType.test( type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});



jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		
		
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				
				add( prefix, v );

			} else {
				
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		
		add( prefix, obj );
	}
}
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});
var
	
	ajaxLocParts,
	ajaxLocation,
	ajax_nonce = jQuery.now(),

	ajax_rquery = /\?/,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, 
	
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	
	_load = jQuery.fn.load,

	
	prefilters = {},

	
	transports = {},

	
	allTypes = "*/".concat("*");



try {
	ajaxLocation = location.href;
} catch( e ) {
	
	
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}


ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];


function addToPrefiltersOrTransports( structure ) {

	
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			
			while ( (dataType = dataTypes[i++]) ) {
				
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}


function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}




function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	
	if ( jQuery.isFunction( params ) ) {

		
		callback = params;
		params = undefined;

	
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			
			response = arguments;

			self.html( selector ?

				
				
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};


jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
	jQuery.fn[ type ] = function( fn ){
		return this.on( type, fn );
	};
});

jQuery.extend({

	
	active: 0,

	
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		
		
		converters: {

			
			"* text": String,

			
			"text html": true,

			
			"text json": jQuery.parseJSON,

			
			"text xml": jQuery.parseXML
		},

		
		
		
		
		flatOptions: {
			url: true,
			context: true
		}
	},

	
	
	
	ajaxSetup: function( target, settings ) {
		return settings ?

			
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	
	ajax: function( url, optionss, isUnload  ) {

		
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		
		options = options || {};

		var 
			parts,
			
			i,
			
			cacheURL,
			
			responseHeadersString,
			
			timeoutTimer,

			
			fireGlobals,

			transport,
			
			responseHeaders,
			
			s = jQuery.ajaxSetup( {}, options ),
			
			callbackContext = s.context || s,
			
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			
			statusCode = s.statusCode || {},
			
			requestHeaders = {},
			requestHeadersNames = {},
			
			state = 0,
			
			strAbort = "canceled",
			
			jqXHR = {
				readyState: 0,

				
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		
		
		
		
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		
		s.type = options.method || options.type || s.method || s.type;

		
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];

		
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		
		if ( state === 2 ) {
			return jqXHR;
		}

		
		fireGlobals = s.global;

		
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		
		s.type = s.type.toUpperCase();

		
		s.hasContent = !rnoContent.test( s.type );

		
		
		cacheURL = s.url;

		
		if ( !s.hasContent ) {

			
			if ( s.data ) {
				cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				
				delete s.data;
			}

			
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					
					cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :

					
					cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
			}
		}

		
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			
			return jqXHR.abort();
		}

		
		strAbort = "abort";

		
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done, isUnload );
			} catch ( e ) {
				
				if ( state < 2 ) {
					done( -1, e );
				
				} else {
					throw e;
				}
			}
		}

		
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			
			if ( state === 2 ) {
				return;
			}

			
			state = 2;

			
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			
			
			transport = undefined;

			
			responseHeadersString = headers || "";

			
			jqXHR.readyState = status > 0 ? 4 : 0;

			
			isSuccess = status >= 200 && status < 300 || status === 304;

			
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			
			if ( isSuccess ) {

				
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				
				} else if ( status === 304 ) {
					statusText = "notmodified";

				
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				
				
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		
		finalDataType = finalDataType || firstDataType;
	}

	
	
	
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}


function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		
		dataTypes = s.dataTypes.slice();

	
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			
			if ( current === "*" ) {

				current = prev;

			
			} else if ( prev !== "*" && prev !== current ) {

				
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				
				if ( !conv ) {
					for ( conv2 in converters ) {

						
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								
								if ( conv === true ) {
									conv = converters[ conv2 ];

								
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				
				if ( conv !== true ) {

					
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});


jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});


jQuery.ajaxTransport( "script", function(s) {

	
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						
						script.onload = script.onreadystatechange = null;

						
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						
						script = null;

						
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				
				
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});
var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;


jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});


jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		
		s.dataTypes[ 0 ] = "json";

		
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		
		jqXHR.always(function() {
			
			window[ callbackName ] = overwritten;

			
			if ( s[ callbackName ] ) {
				
				s.jsonpCallback = originalSettings.jsonpCallback;

				
				oldCallbacks.push( callbackName );
			}

			
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		
		return "script";
	}
});
var xhrCallbacks, xhrSupported,
	xhrId = 0,
	
	xhrOnUnloadAbort = window.ActiveXObject && function() {
		
		var key;
		for ( key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	};


function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject("Microsoft.XMLHTTP");
	} catch( e ) {}
}



jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	
	createStandardXHR;


xhrSupported = jQuery.ajaxSettings.xhr();
jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = jQuery.support.ajax = !!xhrSupported;


if ( xhrSupported ) {

	jQuery.ajaxTransport(function( s ) {
		
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete, isUnload ) {

					
					var handle, i,
						xhr = s.xhr();

					
					
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					
					
					
					
					
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( err ) {}

					
					
					
					xhr.send( ( s.hasContent && s.data ) || null );

					
					callback = function( _, isAbort ) {
						var status, responseHeaders, statusText, responses;

						
						
						
						try {

							
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								
								callback = undefined;

								
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								
								if ( isAbort ) {
									
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									responses = {};
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();

									
									
									if ( typeof xhr.responseText === "string" ) {
										responses.text = xhr.responseText;
									}

									
									
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										
										statusText = "";
									}

									

									
									
									
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						
						callback();
					} else if ( xhr.readyState === 4 ) {
						
						
						setTimeout( callback );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							
							
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							
							xhrCallbacks[ handle ] = callback;
						}
						if (!isUnload)
							xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				
				unit = unit || start[ 3 ];

				
				parts = parts || [];

				
				start = +target || 1;

				do {
					
					
					scale = scale || ".5";

					
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				
				
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		}]
	};


function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			
			return tween;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					
					
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				
				
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			
			
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	
	var prop, value, toggle, tween, hooks, oldfire,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			
			
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		
		
		
		
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		
		
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			
			
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			
			
			
			
			result = jQuery.css( tween.elem, tween.prop, "" );
			
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			
			
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};




Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			
			
			
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			
			data.finish = true;

			
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			
			delete data.finish;
		});
	}
});


function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	
	
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}


jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) ) {
		jQuery.fx.start();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	
	_default: 400
};


jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, win,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	docElem = doc.documentElement;

	
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	
	
	if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	return {
		top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
		left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
	};
};

jQuery.offset = {

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			
			offset = elem.getBoundingClientRect();
		} else {
			
			offsetParent = this.offsetParent();

			
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		
		
		
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;
			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});



jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}

jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					
					
					
					return elem.document.documentElement[ "client" + name ];
				}

				
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					
					
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					
					jQuery.css( elem, type, extra ) :

					
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});




jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;


if ( typeof module === "object" && module && typeof module.exports === "object" ) {
	
	
	
	
	module.exports = jQuery;
} else {

if (!window.jQuery)
	
	window.jQuery = window.$ = jQuery;
window.jq = jQuery; 

	
	
	
	
	
	
	
	if ( typeof define === "function" && define.amd ) {
		define( "jquery", [], function () { return jQuery; } );
	}
}

})( window );


(zk = function (sel) {
	return jq(sel, zk).zk;
}).copy = function (dst, src, bu) {
	dst = dst || {};
	for (var p in src) {
		if (bu) bu[p] = dst[p];
		dst[p] = src[p];
	}
	return dst;
};

(function () {
	var _oid = 0,
		_statelesscnt = 0,
		_logmsg,
		_stamps = [],
		_t0 = jq.now();

	function newClass(copy) {
		var init = function () {
			if (!init.$copied) {
				init.$copied = true;
				var cf = init.$copyf;
				delete init.$copyf;
				cf();
			}
			this.$oid = ++_oid;
			this.$init.apply(this, arguments);

			var ais = this._$ais;
			if (ais) {
				delete this._$ais;
				for (var j = ais.length; j--;)
					ais[j].call(this);
			}
		};
		init.$copyf = copy;
		init.$copied = !init.$copyf;
		return init;
	}
	function regClass(jclass, superclass) {
		var oid = jclass.$oid = ++_oid;
		zk.classes[oid] = jclass;
		jclass.prototype.$class = jclass;
		jclass.$class = zk.Class;
		(jclass._$extds = (jclass.superclass = superclass) ?
			zk.copy({}, superclass._$extds): {})[oid] = jclass;
			
		return jclass;
	}

	function defGet(nm) {
		return new Function('return this.' + nm + ';');
	}
	function defSet00(nm) {
		return function (v) {
			this[nm] = v;
			return this;
		};
	}
	function defSet01(nm, after) {
		return function (v, opts) {
			var o = this[nm];
			this[nm] = v;
			if (o !== v || (opts && opts.force)) {
				this.__fname__ = nm.substring(1);
				after.apply(this, arguments);
				delete this.__fname__;
			}
			return this;
		};
	}
	function defSet10(nm, before) {
		return function () {
			this.__fname__ = nm.substring(1);
			this[nm] = before.apply(this, arguments);
			delete this.__fname__;
			return this;
		};
	}
	function defSet11(nm, before, after) {
		return function (v, opts) {
			var o = this[nm];
			this.__fname__ = nm.substring(1);
			this[nm] = v = before.apply(this, arguments);
			if (o !== v || (opts && opts.force))
				after.apply(this, arguments);
			delete this.__fname__;
			return this;
		};
	}

	function showprgbInit() {
		
		if (jq.isReady||zk.Page.contained.length)
			_showprgb(true, zk.pi ? 'z-initing': null);
		else
			setTimeout(showprgbInit, 10);
	}
	function showprgb() { 
		_showprgb(zk.processMask);
	}
	function _showprgb(mask, icon) {
		var $jq;
		if (zk.processing
		&& !($jq = jq('#zk_proc')).length && !jq('#zk_showBusy').length) {
			zUtl.progressbox('zk_proc', window.msgzk?msgzk.PLEASE_WAIT:'Processing...', mask, icon);
		} else if (icon == 'z-initing') {
			var $jq = $jq || jq('#zk_proc');
			if ($jq.length && $jq.hasClass('z-loading') && ($jq = $jq.parent()).hasClass('z-temp')) {
				$jq.append('<div class="z-initing"></div>');
			}
		}
	}
	function wgt2s(w) {
		var s = w.widgetName;
		return s + (w.id ? '$' + w.id: '') + '#' + w.uuid + '$' + w.$oid;
	}
	function toLogMsg(ars, detailed) {
		var msg = [], Widget = zk.Widget;
		for (var j = 0, len = ars.length; j < len; j++) {
			if (msg.length) msg.push(", ");
			var ar = ars[j];
			if (ar && (jq.isArray(ar) || ar.zk)) 
				msg.push('[' + toLogMsg(ar, detailed) + ']');
			else if (Widget && Widget.isInstance(ar))
				msg.push(wgt2s(ar));
			else if (ar && ar.nodeType) {
				var w = Widget && Widget.$(ar);
				if (w) msg.push(jq.nodeName(ar), (ar != w.$n() ? '#'+ar.id+'.'+ar.className:''), ':', wgt2s(w));
				else msg.push(jq.nodeName(ar), '#', ar.id);
			} else if (detailed && ar && (typeof ar == 'object') && !ar.nodeType) {
				var s = ['{\n'];
				for (var v in ar)
					s.push(v, ':', ar[v], ',\n');
				if (s[s.length - 1] == ',\n')
					s.pop();
				s.push('\n}');
				msg.push(s.join(''));
			} else if (typeof ar == 'function') {
				var s = '' + ar,
					m = s.indexOf('{'),
					k = m < 0 ? s.indexOf('\n'): -1;
				msg.push(s.substring(0, m > 0 ? m: k > 0 ? k: s.length));
			} else
				msg.push('' + ar);
		}
		return msg.join('');
	}
	function doLog() {
		if (_logmsg) {
			var console = jq('#zk_log');
			if (!console.length) {
				jq(document.body).append(
	'<div id="zk_logbox" class="z-log">'
	+'<button class="z-button" onclick="jq(\'#zk_logbox\').remove()">X</button><br/>'
	+'<textarea id="zk_log" rows="10"></textarea></div>');
				console = jq('#zk_log');
			}
			console = console[0];
			console.value += _logmsg;
			console.scrollTop = console.scrollHeight;
			_logmsg = null;
		}
	}

	function _stampout() {
		if (zk.mounting)
			return zk.afterMount(_stampout);
		zk.stamp('ending');
		zk.stamp();
	}

	
	function _overrideSub(dstpt, nm, oldfn, newfn, tobak) {
		for (var sub = dstpt._$subs, j = sub ? sub.length: 0; --j >= 0;) {
			var subpt = sub[j];
			if (subpt[nm] === oldfn) {
				if (tobak)
					subpt['$'+nm] = oldfn; 
				subpt[nm] = newfn;
				_overrideSub(subpt, nm, oldfn, newfn, tobak); 
			}
		}
	}
	

zk.copy(zk, {
	
	classes: {},
	
	isClass: function (cls) {
		return cls && cls.$class == zk.Class;
	},
	
	isObject: function (o) {
		return o && o.$supers != null;
	},
	
	procDelay: 900,
	
	tipDelay: 800,
    
    resendTimeout: 200,
	
	clickPointer: [0, 0],
	
	currentPointer: [0, 0],
	
	
	
	

	
	loading: 0,
	
	
	
	
	
	
	
	
	
	busy: 0,
	
	appName: 'ZK',

	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	

	
	
	
	

	
	
	
	

	
	
	

	
	cut: function (props, nm) {
		var v;
		if (props) {
			v = props[nm];
			delete props[nm];
		}
		return v;
	},

	
	$package: function (name, end, wv) { 
		for (var j = 0, ref = window;;) {
			var k = name.indexOf('.', j),
				nm = k >= 0 ? name.substring(j, k): name.substring(j);
			var nxt = ref[nm], newpkg;
			if (newpkg = !nxt) nxt = ref[nm] = {};
			if (k < 0) {
				if (newpkg && end !== false) zk.setLoaded(name);
					
					
				if (wv) nxt.$wv = true; 
				return nxt;
			}
			ref = nxt;
			j = k + 1;
		}
	},
	
	
	$import: function (name, fn) {
		for (var j = 0, ref = window;;) {
			var k = name.indexOf('.', j),
				nm = k >= 0 ? name.substring(j, k): name.substring(j);
			var nxt = ref[nm];
			if (k < 0 || !nxt) {
				if (fn)
					if (nxt) fn(nxt);
					else
						zk.load(name.substring(0, name.lastIndexOf('.')),
							function () {fn(zk.$import(name));});
				return nxt;
			}
			ref = nxt;
			j = k + 1;
		}
	},

	
	$extends: function (superclass, members, staticMembers) {
		if (!superclass)
			throw 'unknown superclass';

		var fe = !(zk.feature && zk.feature.ee),
			superpt = superclass.prototype,
			jclass = newClass(function () {
				if (superclass.$copyf && !superclass.$copied) {
					superclass.$copyf();
					superclass.$copied = true;
				}
				var define = members['$define'],
					superpt = superclass.prototype,
					thispt = jclass.prototype;
				
				if (define)	delete members['$define'];
				
				var zf = zk.feature;
				if (!(zf && zf.ee)) {
					for (var p in superpt) {
						var $p = '|'+p+'|';
						if ('|_$super|_$subs|$class|_$extds|superclass|className|widgetName|blankPreserved|'.indexOf($p) < 0) {
							thispt[p] = superpt[p];	
						} else if (thispt[p] == undefined && '|className|widgetName|blankPreserved|'.indexOf($p) >= 0) {
							thispt[p] = superpt[p]; 
						}
					}
				}
				
				zk.define(jclass, define);
				zk.copy(thispt, members);
			}),
			thispt = jclass.prototype;
		
		if (fe) {
			jclass.$copyf();
			jclass.$copied = true;
		} else {
			function _init() { this.constructor = jclass; };
		    _init.prototype = superclass.prototype;
		    jclass.prototype = new _init();
			thispt = jclass.prototype;
		}
		
		for (var p in superclass) 
			if ('|prototype|$copyf|$copied|'.indexOf('|'+p+'|') < 0)
				jclass[p] = superclass[p];

		zk.copy(jclass, staticMembers);

		
		thispt['_$super'] = superpt;
		thispt._$subs = [];
		superpt._$subs.push(thispt);
			
		return regClass(jclass, superclass);
	},

	
	$default: function (opts, defaults) {
		opts = opts || {};
		for (var p in defaults)
			if (opts[p] === undefined)
				opts[p] = defaults[p];
		return opts;
	},

	
	
	
	override: function (dst, backup, src) {
		var $class = dst.$class;
		if ($class && $class.$copied === false) {
			var f = $class.$copyf;
			$class.$copyf = function () {
				f();
				$class.$copied = true;
				zk.override(dst, backup, src);
			};
			return dst;
		}
		var fe = !(zk.feature && zk.feature.ee);
		switch (typeof backup) {
		case 'function':
			var old = dst;
			dst = backup;
			return old;
		case 'string':
			
			if (fe)
				_overrideSub(dst, backup, dst['$'+backup] = dst[backup], dst[backup] = src, true);
			else {
				dst['$'+backup] = dst[backup];
				dst[backup] = src;
			}
			return dst;
		}
		if (fe) {
			for (var nm in src)
				_overrideSub(dst, nm, backup[nm] = dst[nm], dst[nm] = src[nm]);
		} else {
			for (var nm in src) {
				backup[nm] = dst[nm];
				dst[nm] = src[nm];
			}
		}
		return dst;
	},

	
	define: function (klass, props) {
		for (var nm in props) {
			var nm1 = '_' + nm,
				nm2 = nm.charAt(0).toUpperCase() + nm.substring(1),
				pt = klass.prototype,
				after = props[nm], before = null;
			if (jq.isArray(after)) {
				before = after.length ? after[0]: null;
				after = after.length > 1 ? after[1]: null;
			}
			pt['set' + nm2] = before ?
				after ? defSet11(nm1, before, after): defSet10(nm1, before):
				after ? defSet01(nm1, after): defSet00(nm1);
			pt['get' + nm2] = pt['is' + nm2] = defGet(nm1);
		}
		return klass;
	},

	
	$void: function () {return false;},

	
	parseInt: function (v, b) {
		return v && !isNaN(v = parseInt(v, b || 10)) ? v: 0;
	},
	
	parseFloat: function (v) {
		return v && !isNaN(v = parseFloat(v)) ? v: 0;
	},

	
	
	set: function (o, name, value, extra) {
		if (typeof name == 'string') {
			zk._set(o, name, value, extra);
		} else 
			for (var j = 0, len = value.length, m, n, v; j < len;) {
				n = value[j++];
				m = name['get' + n.charAt(0).toUpperCase() + n.substring(1)];
				if (!extra || m || name[n] !== undefined) 
					zk._set(o, n, m ? m.call(name): name[n]);
			}
		return o;
	},
	_set: function (o, name, value, extra) { 
		zk._set2(o,
			o['set' + name.charAt(0).toUpperCase() + name.substring(1)],
			name, value, extra);
	},
	_set2: function (o, mtd, name, value, extra) { 
		if (mtd) {
			if (extra !== undefined)
				mtd.call(o, value, extra);
			else
				mtd.call(o, value);
		} else
			o[name] = value;
	},
	
	get: function (o, name) {
		var nm = name.charAt(0).toUpperCase() + name.substring(1),
			m = o['get' + nm];
		if (m) return m.call(o);
		m = o['is' + nm];
		if (m) return m.call(o);
		return o[name];
	},

	
	
	startProcessing: function (timeout) {
		zk.processing = true;
		setTimeout(jq.isReady ? showprgb: showprgbInit, timeout > 0 ? timeout: 0);
	},
	
	endProcessing: function () {
		
		if (window.zkInitCrashTimer) { 
			clearTimeout(window.zkInitCrashTimer);
			window.zkInitCrashTimer = false;
		}
		zk.processing = false;
		zUtl.destroyProgressbox('zk_proc');
	},

	
	disableESC: function () {
		++zk._noESC;
	},
	
	enableESC: function () {
		--zk._noESC;
	},
	_noESC: 0, 

	
	
	error: function (msg) {
		zAu.send(new zk.Event(null, 'error', {message: msg}, {ignorable: true}), 800);
		zk._Erbx.push(msg);
	},
	
	errorDismiss: function () {
		zk._Erbx.remove();
	},
	
	log: function (detailed) {
		var msg = toLogMsg(
			(detailed !== zk) ? arguments :
				(function (args) {
					var a = [];
					for (var j = args.length; --j > 0;)
						a.unshift(args[j]);
					return a;
				})(arguments)
			, (detailed === zk)
		);
		_logmsg = (_logmsg ? _logmsg + msg: msg) + '\n';
		if (zk.mobile) {
			console.log(_logmsg);
			_logmsg = null;
		} else setTimeout(function(){jq(doLog);}, 300);
	},
	
	
	stamp: function (nm, noAutoLog) {
		if (nm) {
			if (!noAutoLog && !_stamps.length)
				setTimeout(_stampout, 0);
			_stamps.push({n: nm, t: jq.now()});
		} else if (_stamps.length) {
			var t0 = _t0;
			for (var inf; (inf = _stamps.shift());) {
				zk.log(inf.n + ': ' + (inf.t - _t0));
				_t0 = inf.t;
			}
			zk.log('total: ' + (_t0 - t0));
		}
	},

	
	ajaxURI: function (uri, opts) {
		var ctx = zk.Desktop.$(opts?opts.desktop:null),
			au = opts && opts.au;
		ctx = (ctx ? ctx: zk)[au ? 'updateURI': 'contextURI'];
		uri = uri || '';

		var abs = uri.charAt(0) == '/';
		if (au && !abs) {
			abs = true;
			if (uri)
				uri = '/' + uri; 
		}

		var j = ctx.indexOf(';'), 
			k = ctx.lastIndexOf('?');
		if (j < 0 && k < 0) return abs ? ctx + uri: uri;

		if (k >= 0 && (j < 0 || k < j)) j = k;
		var prefix = abs ? ctx.substring(0, j): '';

		if (opts && opts.ignoreSession)
			return prefix + uri;

		var suffix = ctx.substring(j),
			l = uri.indexOf('?');
		return l >= 0 ?
			k >= 0 ?
			  prefix + uri.substring(0, l) + suffix + '&' + uri.substring(l+1):
			  prefix + uri.substring(0, l) + suffix + uri.substring(l):
			prefix + uri + suffix;
	},
	
	stateless: function (dtid, contextURI, updateURI, reqURI) {
		var Desktop = zk.Desktop, dt;
		dtid = dtid || ('z_auto' + _statelesscnt++);
		dt = Desktop.all[dtid];
		if (dt && !dt.stateless) throw 'Desktop conflict';
		if (zk.updateURI == null)
			zk.updateURI = updateURI;
		if (zk.contextURI == null) 
			zk.contextURI = contextURI;
		return dt || new Desktop(dtid, contextURI, updateURI, reqURI, true);
	}
});


(function () {
	function _ver(ver) {
		return parseFloat(ver) || ver;
	}

	
	jq.uaMatch = function( ua ) {
		ua = ua.toLowerCase();

		var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
			/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
			/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
			/(msie) ([\w.]+)/.exec( ua ) ||
			ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
			[];

		return {
			browser: match[ 1 ] || '',
			version: match[ 2 ] || '0'
		};
	};

	
	if ( !jq.browser ) {
		matched = jq.uaMatch( navigator.userAgent );
		browser = {};

		if ( matched.browser ) {
			browser[ matched.browser ] = true;
			browser.version = matched.version;
		}

		
		if ( browser.chrome ) {
			browser.webkit = true;
		} else if ( browser.webkit ) {
			browser.safari = true;
		}

		jq.browser = browser;
	}
	var browser = jq.browser,
		agent = zk.agent = navigator.userAgent.toLowerCase();
	zk.opera = browser.opera && _ver(browser.version);
	zk.ff = zk.gecko = browser.mozilla 
		&& (agent.indexOf('trident') < 0) && _ver(browser.version);
	zk.linux = agent.indexOf('linux') >= 0;
	zk.mac = !zk.ios && agent.indexOf('mac') >= 0;
	zk.webkit = browser.webkit;
	zk.chrome = browser.chrome;
	zk.safari = browser.webkit && !zk.chrome; 
	zk.ios = zk.webkit && /iphone|ipad|ipod/.test(agent);
	zk.android = zk.webkit && (agent.indexOf('android') >= 0);
	zk.mobile = zk.ios || zk.android;
	zk.css3 = true;
	var ie11 = browser.mozilla && (agent.indexOf('trident') >= 0) && _ver(browser.version);
	
	zk.vendor = zk.webkit ? 'webkit' : '';

	var bodycls;
	if (zk.ff) {
		if (zk.ff < 5 
		&& (bodycls = agent.indexOf('firefox/')) > 0)
			zk.ff = zk.gecko = _ver(agent.substring(bodycls + 8));
		bodycls = 'gecko gecko' + Math.floor(zk.ff);
		zk.vendor = 'Moz';
	} else if (zk.opera) { 
		bodycls = 'opera';
		zk.vendor = 'O';
	} else {
		zk.iex = browser.msie && _ver(browser.version); 
			
			
		if (!zk.iex && ie11) 
			zk.iex = ie11;
		
		if (zk.iex) {
			if ((zk.ie = document.documentMode||zk.iex) < 6) 
				zk.ie = 6; 
			
			if (zk.ie < 11 && zk.ie > 6) {
				zk.ie7 = zk.ie >= 7;
				zk.ie8 = zk.ie >= 8;
				zk.ie9 = zk.ie >= 9;
				zk.ie10 = zk.ie >= 10;
			}
			zk['ie' + zk.ie + '_'] = true;
			zk.css3 = zk.ie >= 9;
			bodycls = 'ie ie' + Math.floor(zk.ie);
			zk.vendor = 'ms';
		} else {
			if (zk.webkit)
				bodycls = 'webkit webkit' + Math.floor(zk.webkit);
			if (zk.mobile) {
				bodycls = (bodycls || '') + ' mobile';
				if (zk.ios)
					bodycls = (bodycls || '') + ' ios';
				else
					bodycls = (bodycls || '') + ' android';
			}
		}
	}
	if ((zk.air = agent.indexOf('adobeair') >= 0) && zk.webkit)
		bodycls = (bodycls || '') + ' air';

	if (bodycls)
		jq(function () {
			jq(document.body).addClass(bodycls);
		});
	
	zk.vendor_ = zk.vendor.toLowerCase();
})();


	function getProxy(o, f) { 
		return function () {
				return f.apply(o, arguments);
			};
	}
zk.Class = function () {}; 
regClass(zk.Object = newClass());

zk.Object.prototype = {
	
	$init: zk.$void,
	
	afterInit: function (f) {
		(this._$ais = this._$ais || []).unshift(f); 
	},
	
	
	
	
	
	$instanceof: function () {
		if (this.$class)
			for (var extds = this.$class._$extds, args = arguments,
					j = args.length, cls; j--;)
				if ((cls = args[j]) && extds[cls.$oid])
					return true; 
		return false;
	},
	
	
	$super: function (arg0, arg1) {
		if (typeof arg0 != 'string') {
			return this.$supers(arg0, arg1, [].slice.call(arguments, 2));
		}
		return this.$supers(arg0, [].slice.call(arguments, 1));
	},
	
	
	$supers: function (nm, args, argx) {
		var supers = this._$supers;
		if (!supers) supers = this._$supers = {};

		if (typeof nm != 'string') { 
			var old = supers[args], p; 
			if (!(p = nm.prototype._$super) || !(nm = p[args])) 
				throw args + ' not in superclass'; 

			supers[args] = p;
			try {
				return nm.apply(this, argx);
			} finally {
				supers[args] = old; 
			}
		}

		
		var old = supers[nm], m, p, oldmtd;
		if (old) {
			oldmtd = old[nm];
			p = old;
		} else {
			oldmtd = this[nm];
			p = this;
		}
		while (p = p._$super)
			if (oldmtd != p[nm]) {
				m = p[nm];
				if (m) supers[nm] = p;
				break;
			}

		if (!m)
			throw nm + ' not in superclass';

		try {
			return m.apply(this, args);
		} finally {
			supers[nm] = old; 
		}
	},
	
	_$subs: [],

	
	proxy: function (f) {
		var fps = this._$proxies, fp;
		if (!fps) this._$proxies = fps = {};
		else if (fp = fps[f]) return fp;
		return fps[f] = getProxy(this, f);
	}
};


_zkf = {
	
	isInstance: function (o) {
		return o && o.$instanceof && o.$instanceof(this);
	},
	
	isAssignableFrom: function (cls) {
		return cls && (cls = cls._$extds) && cls[this.$oid] != null;
	}
};
zk.copy(zk.Object, _zkf);
zk.copy(regClass(zk.Class, zk.Object), _zkf);


var _erbx, _errcnt = 0;

zk._Erbx = zk.$extends(zk.Object, { 
	$init: function (msg) {
		var id = 'zk_err',
			$id = '#' + id,
			click = zk.mobild ? ' ontouchstart' : ' onclick',
			
 			html = ['<div class="z-error" id="', id, '">',
 			        '<div id="', id, '-p">',
 			        '<div class="errornumbers">', ++_errcnt, ' Errors</div>',
 					'<div class="button"', click, '="zk._Erbx.remove()">',
 					'<i class="z-icon-times"></i></div>',
 					'<div class="button"', click, '="zk._Erbx.redraw()">',
 					'<i class="z-icon-refresh"></i></div></div>',
 					'<div class="messagecontent"><div class="messages">',
 			        zUtl.encodeXML(msg, {multiline : true}), '</div></div></div>'];

		jq(document.body).append(html.join(''));
		_erbx = this;
		this.id = id;
		try {
			var n;
			this.dg = new zk.Draggable(null, n = jq($id)[0], {
				handle: jq($id + '-p')[0], zIndex: n.style.zIndex,
				starteffect: zk.$void, starteffect: zk.$void,
				endeffect: zk.$void});
		} catch (e) {
		}
		jq($id).slideDown(1000);
	},
	destroy: function () {
		_erbx = null;
		_errcnt = 0;
		if (this.dg) this.dg.destroy();
		jq('#' + this.id).remove();
	}
},{
	redraw: function () {
		zk.errorDismiss();
		zAu.send(new zk.Event(null, 'redraw'));
	},
	push: function (msg) {
		if (!_erbx)
			return new zk._Erbx(msg);

		var id = _erbx.id;
		jq('#' + id + ' .errornumbers')
			.html(++_errcnt + ' Errors');
		jq('#' + id + ' .messages')
			.append('<div class="newmessage">' + msg + '</hr></div>');
		jq('#' + id + ' .newmessage')
			.removeClass('newmessage').addClass('message').slideDown(600)
	},
	remove: function () {
		if (_erbx) _erbx.destroy();
	}
});
})();

if(!zk.feature)zk.feature = {standard:true,pe:true};
zk.copy(String.prototype, {
	startsWith: function (prefix) {
		return this.substring(0,prefix.length) == prefix;
	},
	endsWith: function (suffix) {
		return this.substring(this.length-suffix.length) == suffix;
	},
	trim: function () {
		return jq.trim(this);
	},
	$camel: function() {
		var parts = this.split('-'), len = parts.length;
		if (len == 1) return parts[0];

		var camelized = this.charAt(0) == '-' ?
			parts[0].charAt(0).toUpperCase() + parts[0].substring(1): parts[0];

		for (var i = 1; i < len; i++)
			camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
		return camelized;
	},
	$inc: function (diff) {
		return String.fromCharCode(this.charCodeAt(0) + diff)
	},
	$sub: function (cc) {
		return this.charCodeAt(0) - cc.charCodeAt(0);
	}
});

zk.copy(Array.prototype, {
	$indexOf: function (o) {
		return jq.inArray(o, this);
	},
	$contains: function (o) {
		return this.$indexOf(o) >= 0;
	},
	$equals: function (o) {
		if (jq.isArray(o) && o.length == this.length) {
			for (var j = this.length; j--;) {
				var e = this[j];
				if (e != o[j] && (!jq.isArray(e) || !e.$equals(o[j])))
					return false;
			}
			return true;
		}
	},
	$remove: function (o) {
		for (var ary = jq.isArray(o), j = 0, tl = this.length; j < tl; ++j) {
			if (o == this[j] || (ary && o.$equals(this[j]))) {
				this.splice(j, 1);
				return true;
			}
		}
		return false;
	},
	$addAll: function (o) {
		return this.push.apply(this, o);
	},
	$clone: function() {
		return [].concat(this);
	}
});
if (!Array.prototype.indexOf)
	Array.prototype.indexOf = function (o) {
		for (var i = 0, len = this.length; i < len; i++)
			if (this[i] == o) return i;
		return -1;
	};


zjq = function (jq) { 
	this.jq = jq;
};
(function (document, window) {
	var _jq = {}, 
		
		_txtStyles = [
			'font-family', 'font-size', 'font-weight', 'font-style',
			'letter-spacing', 'line-height', 'text-align', 'text-decoration',
			'text-indent', 'text-shadow', 'text-transform', 'text-overflow',
			'direction', 'word-spacing', 'white-space'],
		_txtStylesCamel, _txtSizDiv, 
		_txtStyles2 = ['color', 'background-color', 'background'],
		_zsyncs = [],
		_pendzsync = 0,
		_vpId = 0, 
		_sbwDiv; 

	function _elmOfWgt(id, ctx) {
		var w = ctx && ctx !== zk ? zk.Widget.$(ctx): null, w2;
		return (w2=w||zk.Desktop.sync()) && (w2=w2.$f(id, !w)) ? w2.$n(): null;
	}
	function _ofsParent(el) {
		if (el.offsetParent) return el.offsetParent;
		if (el == document.body) return el;

		while ((el = el.parentNode) && el != document.body)
			if (el.style && jq(el).css('position') != 'static') 
				return el;

		return document.body;
	}
	function _zsync(org) {
		if (--_pendzsync <= 0)
			for (var j = _zsyncs.length; j--;)
				_zsyncs[j].zsync(org);
	}
	function _focus(n) {
		zk.afterAnimate(function () {
			try {
				n.focus();
				var w = zk.Widget.$(n);
				if (w) zk.currentFocus = w;

				zjq.fixInput(n);
			} catch (e) {
			}
		}, -1); 
	}
	function _select(n) {
		try {
			n.select();
		} catch (e) {
		}
	}

	function _submit() {
		if (this.submit) {
			jq.Event.fire(this, 'submit');
			this.submit();
		}
	}

	function _dissel() {
		this.style.MozUserSelect = 'none';
	}
	function _ensel() {
		this.style.MozUserSelect = '';
	}

	function _scrlIntoView(outer, inner, info, excludeHorizontal) {
		if (outer && inner) {
			var ooft = zk(outer).revisedOffset(),
				ioft = info ? info.oft : zk(inner).revisedOffset(),		 
				top = ioft[1] - ooft[1] +
						(outer == DocRoot() ? 0 : outer.scrollTop),
				left = ioft[0] - ooft[0] +
						(outer == DocRoot() ? 0 : outer.scrollLeft),
				ih = info ? info.h : inner.offsetHeight,
				iw = info ? info.w : inner.offsetWidth,
				right = left + iw,
				bottom = top + ih,
				updated;
			
			if ( outer.scrollTop > top) {
				outer.scrollTop = top;
				updated = true;
			} else if (bottom > outer.clientHeight + outer.scrollTop) {
				outer.scrollTop = !info ? bottom : bottom - (outer.clientHeight + (inner.parentNode == outer ? 0 : outer.scrollTop));
				updated = true;
			}
			
			
			
			if (!excludeHorizontal)
				if (outer.scrollLeft > left) {
					outer.scrollLeft = left;
					updated = true;
				} else if (right > outer.clientWidth + outer.scrollLeft) {
					outer.scrollLeft = !info ? right : right - (outer.clientWidth + (inner.parentNode == outer ? 0 : outer.scrollLeft));
					updated = true;
				}
			
			if (updated || !info) {
				if (!info)
					info = {
						oft: ioft,
						h: inner.offsetHeight,
						w: inner.offsetWidth,
						el: inner
					};
				else info.oft = zk(info.el).revisedOffset();
			}
			
			return info; 
		}
	}

	
	function _cmOffset(el) {
		var t = 0, l = 0, operaBug;
		
		if (zk.gecko) {
			var p = el.parentNode;
			while (p && p != document.body && p.nodeType === 1) {
				var $p = jq(p),
					style = $p.css('position');
				if (style == 'relative' || style == 'absolute') {
					t += zk.parseInt($p.css('border-top-width'));
					l += zk.parseInt($p.css('border-left-width'));
				}
				p = p.offsetParent;
			}
		}

		do {
			
			var $el = jq(el);
			if ($el.css('position') == 'fixed') {
				t += jq.innerY() + el.offsetTop;
				l += jq.innerX() + el.offsetLeft;
				break;
			} else {
				
				
				if (zk.opera) {
					if (operaBug && jq.nodeName(el, 'div') && el.scrollTop != 0)
						t += el.scrollTop || 0;
					operaBug = jq.nodeName(el, 'span', 'input');
				}
				t += el.offsetTop || 0;
				l += el.offsetLeft || 0;
				
				el = zk.gecko && el != document.body ?
					_ofsParent(el): el.offsetParent;
			}
		} while (el);
		return [l, t];
	}
	function _posOffset(el) {
		if (zk.webkit && jq.nodeName(el, 'tr') && el.cells.length)
			el = el.cells[0];

		var t = 0, l = 0;
		do {
			t += el.offsetTop  || 0;
			l += el.offsetLeft || 0;
			
			el = zk.gecko && el != document.body ?
				_ofsParent(el): el.offsetParent;
			if (el) {
				if(jq.nodeName(el, 'body')) break;
				var p = jq(el).css('position');
				if (p == 'relative' || p == 'absolute') break;
			}
		} while (el);
		return [l, t];
	}
	function _addOfsToDim($this, dim, revised) {
		if (revised) {
			var ofs = $this.revisedOffset();
			dim.left = ofs[0];
			dim.top = ofs[1];
		} else {
			dim.left = $this.offsetLeft();
			dim.top = $this.offsetTop();
		}
		return dim;
	}

	
	var _rdcss = [];
	function _redoCSS0() {
		if (_rdcss.length) {
			for (var el; el = _rdcss.pop();)
				try {
					zjq._fixCSS(el);
				} catch (e) {
				}
		
			
			setTimeout(_redoCSS0);
		}
	}

	
	var isHTML5DocType = (function () {
		var html5;
		return function () {
			if (html5 === undefined) {
			    if (document.doctype === null) return false;
		
			    var node = document.doctype;
			    var doctype_string = '<!DOCTYPE ' + node.name +
			    		(node.publicId ? ' PUBLIC"' + node.publicId + '"' : '') +
			    		(!node.publicId && node.systemId ? ' SYSTEM' : '') +
			    		(node.systemId ? ' "' + node.systemId + '"' : '') + '>';
		
			    html5 = doctype_string === '<!DOCTYPE html>';
			}
			return html5;
		}
	})();
	
	
	var DocRoot = (function() {
		var docRoot,
			
			initDocRoot = function () {
				return docRoot = (zk.webkit || zk.opera) ? document.body : document.documentElement;
			};
		return function () {
			return docRoot || initDocRoot();
		};
	})();

zk.copy(zjq, {
	
	minWidth: (!zk.ie11_) ? function (el) {
		return zk(el).offsetWidth();
	}: function (el) {
		
		return zk(el).offsetWidth() + 1;
	},

	fixInput: zk.$void, 
	_fixCSS: function (el) { 
		el.className += ' ';
		if (el.offsetHeight)
			;
		el.className.trim();
	},
	_cleanVisi: function (n) { 
		n.style.visibility = 'inherit';
	},
	_fixClick: zk.$void, 
	_fixedVParent: zk.$void,
	_fixIframe: zk.$void,

	
	src0: "", 
	eventTypes: {
		zmousedown: 'mousedown',
		zmouseup: 'mouseup',
		zmousemove: 'mousemove',
		zdblclick: 'dblclick',
		zcontextmenu: 'contextmenu'
	}
});
jq.fn.zbind = jq.fn.bind;
jq.fn.zunbind = jq.fn.unbind;

zk.override(jq.fn, _jq,  {
	
	

	init: function (sel, ctx) {
		if (ctx === zk) {
			if (typeof sel == 'string'
			&& zUtl.isChar(sel.charAt(0), {digit:1,upper:1,lower:1,'_':1})) {
				var el = document.getElementById(sel);
				if (!el || el.id == sel) {
					var ret = jq(el || []);
					ret.context = document;
					ret.selector = '#' + sel;
					ret.zk = new zjq(ret);
					return ret;
				}
				sel = '#' + sel;
			}
			ctx = null;
		}
		if (zk.Widget && zk.Widget.isInstance(sel))
			sel = sel.$n() || '#' + sel.uuid;
		var ret = _jq.init.apply(this, arguments);
		ret.zk = new zjq(ret);
		return ret;
	},
	
	replaceWith: function (w, desktop, skipper) {
		if (!zk.Widget.isInstance(w))
			return _jq.replaceWith.apply(this, arguments);

		var n = this[0];
		if (n) w.replaceHTML(n, desktop, skipper);
		return this;
	},
	bind: function(type, data, fn) {
		type = zjq.eventTypes[type] || type;
		return this.zbind.apply(this, arguments);
	},
	unbind: function(type, fn){
		type = zjq.eventTypes[type] || type;
		return this.zunbind.apply(this, arguments);
	}
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
});
jq.fn.init.prototype = jq.fn;

jq.each(['remove', 'empty', 'show', 'hide'], function (i, nm) {
	_jq[nm] = jq.fn[nm];
	jq.fn[nm] = function () {
		return !this.selector && this[0] === document ? this: _jq[nm].apply(this, arguments);
	};
});
jq.each(['before','after','append','prepend'], function (i, nm) {
	_jq[nm] = jq.fn[nm];
	jq.fn[nm] = function (w, desktop) {
		if (!zk.Widget.isInstance(w))
			return _jq[nm].apply(this, arguments);

		if (!this.length) return this;
		if (!zk.Desktop._ndt) zk.stateless();

		var ret = _jq[nm].call(this, w.redrawHTML_());
		if (!w.z_rod) {
			w.bind(desktop);
			zUtl.fireSized(w);
		}
		return ret;
	};
});


zjq.prototype = {
	
	

	
	cleanVisibility: function () {
		return this.jq.each(function () {
			zjq._cleanVisi(this);
		});
	},
	
	
	isVisible: function (strict) {
		var n = this.jq[0];
		return n && (!n.style || (n.style.display != 'none' && (!strict || n.style.visibility != 'hidden')));
	},
	
	isRealVisible: function (strict) {
		var n = this.jq[0];
		return n && this.isVisible(strict) && (n.offsetWidth > 0 || n.offsetHeight > 0
		|| (!n.firstChild 
			&& (!(n=n.parentNode) || n==document.body || zk(n).isRealVisible(strict))));
			
	},

	
	scrollTo: function () {
		if (this.jq.length) {
			var pos = this.cmOffset();
			scrollTo(pos[0], pos[1]);
		}
		return this;
	},
	
	scrollIntoView: function (parent) {
		var n = this.jq[0];
		if (n) {
			var real = jq('#' + n.id + '-real')[0];
			if (real)
				n = real;

			
			
			if (!this.isScrollIntoView()) {
				
				
				var isAbsolute = parent,
					p = n;
				if (!isAbsolute) {
					do {
						if (p == document.body) break;
						if (jq(p).css('position')=='absolute') {
							isAbsolute = true;
							break;
						}
	
					} while (p = p.offsetParent);
				}
				
				
				
				if (!isAbsolute && zk.isLoaded('zul.sel')) {
					var w = zk.Widget.$(n);
					isAbsolute = w && w.$instanceof(zul.sel.ItemWidget);
				}

				if (isAbsolute) {
					var parent = parent || document.documentElement;
					for (var p = n, c; (p = p.parentNode) && n != parent; n = p)
						c = _scrlIntoView(p, n, c, true);
				} else {
					
					setTimeout(function () {
						n.scrollIntoView();
					}, 20);
				}
			}
		}
		return this;
	},
	
	isScrollIntoView: (function () {
		function _overflowElement(self, recursive) {
			var el = self.jq[0],
				te, le, oels = [];
			do {
				if (!te) {
					if (el == DocRoot() || el.style.overflow == 'auto' || el.style.overflowY == 'auto' || jq(el).css('overflow-y') == 'auto')
						te = el;
				}
				if (!le) {
					if (el == DocRoot() || el == document.body || el.style.overflow == 'auto' || el.style.overflowX == 'auto' || jq(el).css('overflow-x') == 'auto')
						le = el;
				}
				if (te && le) {
					oels.push([le, te]);
					if (!recursive)
						break;
					te = le = null;
				}
				el = el.parentNode;
			} while (el && (el != document));
				
			return oels;
		}
		
		return function (recursive) {
			var vOffset = this.viewportOffset(),
				x = vOffset[0],
				y = vOffset[1],
				w = this.jq[0].offsetWidth,
				h = this.jq[0].offsetHeight,
				x1 = x + w,
				y1 = y + h;
			
			
			if (x >= 0 && y >= 0 && x1 <= jq.innerWidth() && y1 <= jq.innerHeight()) {
				var oels = _overflowElement(this, recursive),
					inView = true;
				for (var i = 0; i < oels.length; i++) {
					
					var oel = oels[i],
					    eqX = this.jq[0] == oel[0],
					    eqY = this.jq[0] == oel[1],
					    nodeX = zk(eqX ? oel[0].parentNode : oel[0]),
					    nodeY = zk(eqY ? oel[1].parentNode : oel[1]),
					    pW;
					if (eqX && (pW = nodeX.$()) && pW.$instanceof(zk.Page)) continue;
					if (eqY && (pW = nodeY.$()) && pW.$instanceof(zk.Page)) continue;
					var lex = nodeX.viewportOffset()[0],
					    tey = nodeY.viewportOffset()[1];
				
					
					inView = (x >= lex && x1 <= lex + oel[0].offsetWidth && y >= tey && y1 <= tey + oel[1].offsetHeight);
					if (!inView)
						return inView;
				}
				return inView;
			}
			return false;		
		};
	})(),
	
	hasVScroll: function () {
		var w;
		if ((w = this.$()) && w._scrollbar) {
			return w._scrollbar.hasVScroll();
		}
		var n, v;
		return (n = this.jq[0]) && (v = n.clientWidth) && (v = n.offsetWidth - v) > 11 ? v: 0;
	},
	
	hasHScroll: function () {
		var w;
		if ((w = this.$()) && w._scrollbar) {
			return w._scrollbar.hasHScroll();
		}
		var n, v;
		return (n = this.jq[0]) && (v = n.clientHeight) && (v = n.offsetHeight - v) > 11 ? v: 0;
	},

	
	isOverlapped: function (el, tolerant) {
		var n;
		if (n = this.jq[0])
			return jq.isOverlapped(
				
				this.revisedOffset(), [n.offsetWidth, n.offsetHeight], zk(el).revisedOffset(),
				    [el.offsetWidth, el.offsetHeight], tolerant);
	},

	
	sumStyles: function (areas, styles) {
		var val = 0;
		for (var i = 0, len = areas.length, $jq = this.jq; i < len; i++){
			 var w = Math.round(zk.parseFloat($jq.css(styles[areas.charAt(i)])));
			 if (!isNaN(w)) val += w;
		}
		return val;
	},
	
	
	
	revisedOffset: function (ofs) {
		var el = this.jq[0];
		if(!ofs) {
			if (el.getBoundingClientRect){ 
				var elst, oldvisi;
				if (zk.ie < 11 && el.style.display == 'none') {
				
					oldvisi = (elst = el.style).visibility;
					elst.visibility = 'hidden';
					elst.display = '';
				}

				var b = el.getBoundingClientRect();
				b = [b.left + jq.innerX() - el.ownerDocument.documentElement.clientLeft,
					b.top + jq.innerY() - el.ownerDocument.documentElement.clientTop];

				if (elst) {
					elst.display = 'none';
					elst.visibility = oldvisi;
				}
				
				b[0] = Math.ceil(b[0]);
				b[1] = Math.ceil(b[1]);
				
				return b;
				
				
				
				
				
				
			}
			ofs = this.cmOffset();
		}
		var scrolls = zk(el.parentNode).scrollOffset();
		scrolls[0] -= jq.innerX(); scrolls[1] -= jq.innerY();
		return [ofs[0] - scrolls[0], ofs[1] - scrolls[1]];
	},
	
	revisedWidth: function (size, excludeMargin) {
		if (this.jq.css('box-sizing') != 'border-box')
			size -= this.padBorderWidth();
		if (size > 0 && excludeMargin)
			size -= this.marginWidth();
		return size < 0 ? 0: size;
	},
	
	revisedHeight: function (size, excludeMargin) {
		if (this.jq.css('box-sizing') != 'border-box')
			size -= this.padBorderHeight();
		if (size > 0 && excludeMargin)
			size -= this.marginHeight();
		return size < 0 ? 0: size;
	},
	
	contentWidth: function (excludeMargin) {
		var size = this.jq[0].offsetWidth;
		size -= this.padBorderWidth();
		if (size > 0 && excludeMargin)
			size -= this.marginWidth();
		return size < 0 ? 0: size;
	},
	
	contentHeight: function (excludeMargin) {
		var size = this.jq[0].offsetHeight;
		size -= this.padBorderHeight();
		if (size > 0 && excludeMargin)
			size -= this.marginHeight();
		return size < 0 ? 0: size;
	},
	
	marginWidth: function () {
		return this.sumStyles('lr', jq.margins);
	},
	
	marginHeight: function () {
		return this.sumStyles('tb', jq.margins);
	},
	
	borderWidth: function () {
		return this.sumStyles('lr', jq.borders);
	},
	
	borderHeight: function () {
		return this.sumStyles('tb', jq.borders);
	},
	
	paddingWidth: function () {
		return this.sumStyles('lr', jq.paddings);
	},
	
	paddingHeight: function () {
		return this.sumStyles('tb', jq.paddings);
	},
	
	padBorderWidth: function () {
		return this.borderWidth() + this.paddingWidth();
	},
	
	padBorderHeight: function () {
		return this.borderHeight() + this.paddingHeight();
	},
	 
	vflexHeight: function () {
		var el = this.jq[0],
			hgh = el.parentNode.clientHeight;
		for (var p = el; p = p.previousSibling;)
			if (p.offsetHeight && zk(p).isVisible())
				hgh -= p.offsetHeight; 
		for (var p = el; p = p.nextSibling;)
			if (p.offsetHeight && zk(p).isVisible())
				hgh -= p.offsetHeight; 
		return hgh;
	},
	
	cellIndex: function () {
		var cell = this.jq[0];
		return cell ? cell.cellIndex: 0;
	},
	
	ncols: function (visibleOnly) {
		var row = this.jq[0],
			cnt = 0, cells;
		if (row && (cells = row.cells))
			for (var j = 0, cl = cells.length; j < cl; ++j) {
				var cell = cells[j];
				if (!visibleOnly || zk(cell).isVisible()) {
					var span = cell.colSpan;
					if (span >= 1) cnt += span;
					else ++cnt;
				}
			}
		return cnt;
	},
	
	toStyleOffset: function (x, y) {
		var el = this.jq[0],
			oldx = el.style.left, oldy = el.style.top,
			resetFirst = zk.webkit || zk.opera || zk.air || zk.ie > 7; 
		
		
		
		
		
		
		if (resetFirst || el.style.left == '' || el.style.left == 'auto')
			el.style.left = '0';
		if (resetFirst || el.style.top == '' || el.style.top == 'auto')
			el.style.top = '0';

		var ofs1 = this.cmOffset(),
			x2 = zk.parseInt(el.style.left),
			y2 = zk.parseInt(el.style.top);
		ofs1 = [x - ofs1[0] + x2, y  - ofs1[1] + y2];

		el.style.left = oldx; el.style.top = oldy; 
		return ofs1;
	},
	
	center: function (flags) {
		var el = this.jq[0],
			wdgap = this.offsetWidth(),
			hghgap = this.offsetHeight();

		if ((!wdgap || !hghgap) && !this.isVisible()) {
			el.style.left = el.style.top = '-10000px'; 
			el.style.display = 'block'; 
			wdgap = this.offsetWidth();
			hghgap = this.offsetHeight(),
			el.style.display = 'none'; 
		}

		var left = jq.innerX(), top = jq.innerY();
		var x, y, skipx, skipy;

		wdgap = jq.innerWidth() - wdgap;
		if (!flags) x = left + wdgap / 2;
		else if (flags.indexOf('left') >= 0) x = left;
		else if (flags.indexOf('right') >= 0) x = left + wdgap - 1; 
		else if (flags.indexOf('center') >= 0) x = left + wdgap / 2;
		else {
			x = 0; skipx = true;
		}

		hghgap = jq.innerHeight() - hghgap;
		if (!flags) y = top + hghgap / 2;
		else if (flags.indexOf('top') >= 0) y = top;
		else if (flags.indexOf('bottom') >= 0) y = top + hghgap - 1; 
		else if (flags.indexOf('center') >= 0) y = top + hghgap / 2;
		else {
			y = 0; skipy = true;
		}

		if (x < left) x = left;
		if (y < top) y = top;

		var ofs = this.toStyleOffset(x, y);

		if (!skipx) el.style.left = jq.px(ofs[0]);
		if (!skipy) el.style.top =  jq.px(ofs[1]);
		return this;
	},
	
	
	position: function (dim, where, opts) {
		where = where || 'overlap';
		
		if (!dim) {
			var bd = jq('body')[0];
			dim = {
				left:0, top: 0,
				width: bd.offsetWidth, height: bd.offsetHeight
			};
		}
		
		if (dim.nodeType) 
			dim = zk(dim).dimension(true);
		var x = dim.left, y = dim.top,
			wd = this.dimension(), hgh = wd.height; 
		wd = wd.width;
		
		
		switch(where) {
		case 'before_start':
			y -= hgh;
			break;
		case 'before_center':
			y -= hgh;
			x += (dim.width - wd) / 2 | 0;
			break;
		case 'before_end':
			y -= hgh;
			x += dim.width - wd;
			break;
		case 'after_start':
			y += dim.height;
			break;
		case 'after_center':
			y += dim.height;
			x += (dim.width - wd) / 2 | 0;
			break;
		case 'after_end':
			y += dim.height;
			x += dim.width - wd;
			break;
		case 'start_before':
			x -= wd;
			break;
		case 'start_center':
			x -= wd;
			y += (dim.height - hgh) / 2 | 0;
			break;
		case 'start_after':
			x -= wd;
			y += dim.height - hgh;
			break;
		case 'end_before':
			x += dim.width;
			break;
		case 'end_center':
			x += dim.width;
			y += (dim.height - hgh) / 2 | 0;
			break;
		case 'end_after':
			x += dim.width;
			y += dim.height - hgh;
			break;
		case 'at_pointer':
			var offset = zk.currentPointer;
			x = offset[0];
			y = offset[1];
			break;
		case 'after_pointer':
			var offset = zk.currentPointer;
			x = offset[0];
			y = offset[1] + 20;
			break;
		case 'top_right':
		case 'overlap_end':
			x += dim.width - wd;
			break;
		case 'top_center':
			x += (dim.width - wd) / 2 | 0;
			break;
		case 'middle_left':
			y += (dim.height - hgh) / 2 | 0;
			break;
		case 'middle_center':
			x += (dim.width - wd) / 2 | 0;
			y += (dim.height - hgh) / 2 | 0;
			break;
		case 'middle_right':
			x += dim.width - wd;
			y += (dim.height - hgh) / 2 | 0;
			break;
		case 'bottom_left':
		case 'overlap_before':
			y += dim.height - hgh;
			break;
		case 'bottom_center':
			x += (dim.width - wd) / 2 | 0;
			y += dim.height - hgh;
			break;
		case 'bottom_right':
		case 'overlap_after':
			x += dim.width - wd;
			y += dim.height - hgh;
			break;
		default: 
			
		}
		
		if (!opts || !opts.overflow) {
			var scX = jq.innerX(),
				scY = jq.innerY(),
				scMaxX = scX + jq.innerWidth(),
				scMaxY = scY + jq.innerHeight();
			
			if (x + wd > scMaxX) x = scMaxX - wd;
			if (x < scX) x = scX;
			if (y + hgh > scMaxY) y = scMaxY - hgh;
			if (y < scY) y = scY;
		}
		
		
		
		if (opts && opts.dodgeRef) {
			var dl = dim.left, dt = dim.top,
				dr = dl + dim.width, db = dt + dim.height;
			
			if (x + wd > dl && x < dr && y + hgh > dt && y < db) {
				if (opts.overflow) {
					
					x = dr;
				} else {
					var scX = jq.innerX(),
						scMaxX = scX + jq.innerWidth(),
						spr = scMaxX - dr,
						spl = dl - scX;
					
					
					if (spr >= wd || spr >= spl)
						x = Math.min(dr, scMaxX - wd);
					else
						x = Math.max(dl - wd, scX);
				}
			}
		}

		var el = this.jq[0],
			ofs = this.toStyleOffset(x, y);
		el.style.left = jq.px(ofs[0]);
		el.style.top = jq.px(ofs[1]);
		return this;
	},

	
	scrollOffset: function() {
		var el = this.jq[0],
			t = 0, l = 0;
		do {
			t += el.scrollTop  || 0;
			l += el.scrollLeft || 0;
			el = el.parentNode;
		} while (el);
		return [l, t];
	},
	
	cmOffset: function () {
		
		var el = this.jq[0];
		if (zk.webkit && jq.nodeName(el, 'tr') && el.cells.length)
			el = el.cells[0];

		
		if (!(zk.gecko || zk.webkit)
		|| this.isVisible() || this.offsetWidth())
			return _cmOffset(el);

		el.style.display = '';
		var ofs = _cmOffset(el);
		el.style.display = 'none';
		return ofs;
	},
	
	$:function(){
		return zk.Widget.$(this.jq[0]);
	},
	
	absolutize: function() {
		var el = this.jq[0];
		if (el.style.position == 'absolute') return this;

		var offsets = _posOffset(el),
			left = offsets[0], top = offsets[1],
			st = el.style;
		el._$orgLeft = left - parseFloat(st.left  || 0);
		el._$orgTop = top  - parseFloat(st.top || 0);
		st.position = 'absolute';
		st.top = jq.px(top);
		st.left = jq.px(left);
		return this;
	},
	
	relativize: function() {
		var el = this.jq[0];
		if (el.style.position == 'relative') return this;

		var st = el.style;
		st.position = 'relative';
		var top  = parseFloat(st.top  || 0) - (el._$orgTop || 0),
			left = parseFloat(st.left || 0) - (el._$orgLeft || 0);

		st.top = jq.px(top);
		st.left = jq.px(left);
		return this;
	},

	
	offsetWidth: function () {
		return this.jq[0].offsetWidth;
	},
	
	offsetHeight: function () {
		var n = this.jq[0];
		
		
		if (isHTML5DocType() &&
				jq.nodeName(n, 'SPAN') && this.jq.css('display') != 'block') {
			var text = n.outerHTML;
			
			
			if (zk.Widget.$(n, {exact: 1})) {
				text = text.replace(/id="[^"]*"/g, '');
			}
			return zk(document.body).textSize(text)[1];
		}
		return n.offsetHeight;
	},
	
	offsetTop: function () {
		return this.jq[0].offsetTop;
	},
	
	offsetLeft: function () {
		return this.jq[0].offsetLeft;
	},

	
	viewportOffset: function() {
		var t = 0, l = 0, el = this.jq[0], p = el;
		do {
			t += p.offsetTop  || 0;
			l += p.offsetLeft || 0;

			
			if (p.offsetParent==document.body)
			if (jq(p).css('position')=='absolute') break;

		} while (p = p.offsetParent);
		
		while (el = el.parentNode) {
			
			
				t -= el.scrollTop  || 0;
				l -= el.scrollLeft || 0;
			
		}
		return [l, t];
	},
	
	textSize: (function () {
		
		var _txtStylesCamel = [],
			_txtSizDiv,
			_defaultStyle = 'left:-1000px;top:-1000px;position:absolute;visibility:hidden;border:none;display:none;',
			_cache = {};
		return function (txt) {
			var jq = this.jq;
			txt = txt || jq[0].innerHTML;
			if (!_txtSizDiv) {
				_txtSizDiv = document.createElement('div');
				_txtSizDiv.style.cssText = _defaultStyle;
				document.body.appendChild(_txtSizDiv);

				for (var ss = _txtStyles, j = ss.length; j--;)
					_txtStylesCamel[j] = ss[j].$camel();
			}
			var newStyle = '';
			for (var ss = _txtStylesCamel, j = ss.length; j--;) {
				var nm = ss[j];
				newStyle += _txtStyles[j] + ':' + jq.css(nm) + ';';
			}
			
			var result,
				key = newStyle + txt;
			if (!(result = _cache[key])) {
				
				_txtSizDiv.innerHTML = txt.replace(/name="[^"]*"/g, '');
				_txtSizDiv.style.cssText = _defaultStyle + newStyle;
				_txtSizDiv.style.display = '';
				result = _cache[key] = [_txtSizDiv.offsetWidth, _txtSizDiv.offsetHeight];
				_txtSizDiv.style.display = 'none';
				_txtSizDiv.innerHTML = ''; 
			}
			return result;
		};
	})(),
	
	dimension: function (revised) {
		var display = this.jq.css('display');
		if (display != 'none' && display != null) 
			return _addOfsToDim(this,
				{width: this.offsetWidth(), height: this.offsetHeight()}, revised);

	
	
		var st = this.jq[0].style,
			backup = {};
		zk.copy(st, {
			visibility: 'hidden',
			position: 'absolute',
			display: 'block'
			}, backup);
		try {
			return _addOfsToDim(this,
				{width: this.offsetWidth(), height: this.offsetHeight()}, revised);
		} finally {
			zk.copy(st, backup);
		}
	},

	
	redoCSS: function (timeout, opts) {
		if (opts && opts['fixFontIcon']) {
			if (zk.ie8_) {
				var head = document.getElementsByTagName('head')[0],
	    			style = document.createElement('style'),
	    			n = this.jq[0],
	    			s = opts['selector'],
	    			cls = n ? n.className : '',
	    			idOrCls = n ? (n.id ? '#' + n.id : '.' + cls) : '', 
	    			selector = s ? s : '*';
	    		if(idOrCls == '' && selector == '*')
	    			return this;
				style.type = 'text/css';
				
				style.styleSheet.cssText = idOrCls + ' ' + selector + ':before{content:"" !important';
				var scrollTop = document.documentElement.scrollTop,
					scrollLeft = document.documentElement.scrollLeft;
				head.appendChild(style);
				setTimeout(function(){
				    head.removeChild(style);
				    
				    document.documentElement.scrollTop = scrollTop;
				    document.documentElement.scrollLeft = scrollLeft;
				}, 0);
				return this;
			} else {
				return this;
			}
		} 
		if (timeout == -1){ 
			for (var j = this.jq.length; j--;)
				zjq._fixCSS(this.jq[j]);	
		} else {
			for (var j = this.jq.length; j--;)
				_rdcss.push(this.jq[j]);
			setTimeout(_redoCSS0, timeout >= 0 ? timeout : 100);
		}
		return this;
	},
	
	redoSrc: function () {
		for (var j = this.jq.length; j--;) {
			var el = this.jq[j],
				src = el.src;
			el.src = zjq.src0;
			el.src = src;
		}
		return this;
	},

	
	vparentNode: function (real) {
		var el = this.jq[0];
		if (el) {
			var v = el.z_vp; 
			if (v) return jq('#' + v)[0];
			v = el.z_vpagt;
			if (v && (v = jq('#' +v)[0]))
				return v.parentNode;
			if (real)
				return el.parentNode;
		}
	},
	
	makeVParent: function () {
		var el = this.jq[0],
			p = el.parentNode;
		if (el.z_vp || el.z_vpagt || p == document.body)
			return this; 

		var sib = el.nextSibling,
			agt = document.createElement('span');
		agt.id = el.z_vpagt = '_z_vpagt' + _vpId ++;
		agt.style.display = 'none';
		
		
		zjq._fixedVParent(el, true);
		
		if (sib) p.insertBefore(agt, sib);
		else p.appendChild(agt);

		el.z_vp = p.id; 
		var st = el.style;
		if (!st.top) st.top = '0';
			
			
			
		document.body.appendChild(el);
		return this;
	},
	
	undoVParent: function () {
		var el = this.jq[0];
		if (el.z_vp || el.z_vpagt) {
			var p = el.z_vp,
				agt = el.z_vpagt,
				$agt = jq('#' + agt);
			el.z_vp = el.z_vpagt = null;
			agt = $agt[0];

			p = p ? jq('#' + p)[0]: agt ? agt.parentNode: null;
			if (p) {
				
				
				zjq._fixedVParent(el);
				
				if (agt) {
					p.insertBefore(el, agt);
					$agt.remove();
				} else
					p.appendChild(el);
				
				var cf, p, a;
				
				if ((zk.ff || zk.opera) && (cf = zk._prevFocus) && 
					(p = zk.Widget.$(el)) && zUtl.isAncestor(p, cf)) { 
					if (cf.getInputNode)
						jq(cf.getInputNode()).trigger('blur');
					else if ((a = cf.$n('a')) 
							&& jq.nodeName(a, 'button', 'input', 'textarea', 'a', 'select', 'iframe'))
						jq(a).trigger('blur');
					else if (cf.$instanceof(zul.wgt.Button)) 
						jq(cf.$n('btn') || cf.$n()).trigger('blur');
				}
			}
		}
		return this;
	},
	
	hasVParent: function() {
		
		var el = this.jq[0];
		return el && (el.z_vp || el.z_vpagt);
	},

	
	beforeHideOnUnbind: zk.$void,

	
	
	focus: function (timeout) {
		var n = this.jq[0];
		if (!n || !n.focus) return false;
			

		if (!jq.nodeName(n, 'button', 'input', 'textarea', 'a', 'select', 'iframe'))
			return false;

		if (timeout >= 0) setTimeout(function() {_focus(n);}, timeout);
		else _focus(n);
		return true;
	},
	
	select: function (timeout) {
		var n = this.jq[0];
		if (!n || typeof n.select != 'function') return false;

		if (timeout >= 0) setTimeout(function() {_select(n);}, timeout);
		else _select(n);
		return true;
	},

	
	getSelectionRange: function() {
		var inp = this.jq[0];
		try {
			if (document.selection != null && inp.selectionStart == null) { 
				var range = document.selection.createRange();
				var rangetwo = inp.createTextRange();
				var stored_range = '';
				if(inp.type.toLowerCase() == 'text'){
					stored_range = rangetwo.duplicate();
				}else{
					 stored_range = range.duplicate();
					 stored_range.moveToElementText(inp);
				}
				stored_range.setEndPoint('EndToEnd', range);
				var start = stored_range.text.length - range.text.length;
				return [start, start + range.text.length];
			} else { 
				return [inp.selectionStart, inp.selectionEnd];
			}
		} catch (e) {
			return [0, 0];
		}
	},
	
	setSelectionRange: function (start, end) {
		var inp = this.jq[0],
			len = inp.value.length;
		if (start == null || start < 0) start = 0;
		if (start > len) start = len;
		if (end == null || end > len) end = len;
		if (end < 0) end = 0;

		if (inp.setSelectionRange) {
			inp.setSelectionRange(start, end);
		} else if (inp.createTextRange) {
			var range = inp.createTextRange();
			if(start != end){
				range.moveEnd('character', end - range.text.length);
				range.moveStart('character', start);
			}else{
				range.move('character', start);
			}
			range.select();
		}
		return this;
	},

	
	submit: function () {
		this.jq.each(_submit);
		return this;
	},

	
	
	disableSelection: function () {
		this.jq.each(_dissel);
		return this;
	},
	
	enableSelection: function () {
		this.jq.each(_ensel);
		return this;
	},

	
	setStyles: function (styles) {
		this.jq.css(styles);
		return this;
	},
	
	clearStyles: function () {
		var st = this.jq[0];
		if (st && (st=st.style))
			for (var nm in st)
				if ((!(zk.ie < 11) || nm != 'accelerator')
				&& st[nm] && typeof st[nm] == 'string')
					try {
						st[nm] = '';
					} catch (e) { 
					}
		return this;
	},
	
	detachChildren: function () {
		var embed = this.jq[0];
		if (embed) {
			var val = [], n;
			while (n = embed.firstChild) {
				val.push(n);
				embed.removeChild(n);
			}
			return val;
		}
		return null;
	},

	
	isInput: function () {
		var $jq = this.jq,
			len = $jq.length,
			types = ['text', 'password', 'number', 'tel', 'url', 'email'];
		for (var j = len, tag, n; j--;)
			if ((tag = jq.nodeName(n = $jq[j])) != 'textarea'
			&& (tag != 'input' || (jq.inArray(n.type, types) == -1)))
				return false;
		return len > 0; 
	}
};


zk.copy(jq, {
	
	
	nodeName: function (el) {
		var tag = el && el.nodeName ? el.nodeName.toLowerCase(): "",
			j = arguments.length;
		if (j <= 1)
			return tag;
		while (--j)
			if (tag == arguments[j].toLowerCase())
				return true;
		return false;
	},

	
	px: function (v) {
		return (v||0) + 'px';
	},
	
	px0: function (v) {
		return Math.max(v||0, 0) + 'px';
	},

	
	$$: function (id, subId) {
		return typeof id == 'string' ?
			id ? document.getElementsByName(id + (subId ? '-' + subId : '')): null: id;
	},

	
	isAncestor: function (p, c) {
		if (!p) return true;
		for (; c; c = zk(c).vparentNode(true))
			if (p == c)
				return true;
		return false;
	},
	
	innerX: function () {
		return window.pageXOffset
			|| DocRoot().scrollLeft || 0;
	},
	
	innerY: function () {
		return window.pageYOffset
			|| DocRoot().scrollTop || 0;
	},
	
	innerWidth: function () {
		return jq(window).width();
	},
	
	innerHeight: function () {
		return jq(window).height();
	},

	
	margins: {l: 'margin-left', r: 'margin-right', t: 'margin-top', b: 'margin-bottom'},
	
	borders: {l: 'border-left-width', r: 'border-right-width', t: 'border-top-width', b: 'border-bottom-width'},
	
	paddings: {l: 'padding-left', r: 'padding-right', t: 'padding-top', b: 'padding-bottom'},

	
	scrollbarWidth: function () {
		if (!_sbwDiv) {
			_sbwDiv = document.createElement('div');
			_sbwDiv.style.cssText = 'top:-1000px;left:-1000px;position:absolute;visibility:hidden;border:none;width:50px;height:50px;overflow:scroll;';
			document.body.appendChild(_sbwDiv);
		}
		return _sbwDiv._value || (_sbwDiv._value = _sbwDiv.offsetWidth - _sbwDiv.clientWidth);
	},
    
	
	isOverlapped: function (ofs1, dim1, ofs2, dim2, tolerant) {
		var o1x1 = ofs1[0], o1x2 = dim1[0] + o1x1,
			o1y1 = ofs1[1], o1y2 = dim1[1] + o1y1;
		var o2x1 = ofs2[0], o2x2 = dim2[0] + o2x1,
			o2y1 = ofs2[1], o2y2 = dim2[1] + o2y1;
		if (tolerant) {
		  return o2x1 <= o1x2 && o2x2 >= o1x1 && o2y1 <= o1y2 && o2y2 >= o1y1
                 && o1x2 - o2x1 > tolerant && o2x2 - o1x1 > tolerant
                 && o1y2 - o2y1 > tolerant && o2y2 - o1y1 > tolerant;
		} else
		  return o2x1 <= o1x2 && o2x2 >= o1x1 && o2y1 <= o1y2 && o2y2 >= o1y1;
	},

	
	clearSelection: function () {
		try{
			if (window['getSelection']) {
				if (zk.webkit) window.getSelection().collapse();
				else window.getSelection().removeAllRanges();
			} else if (document.selection) {
				if (document.selection.empty) document.selection.empty();
				else if (document.selection.clear) document.selection.clear();
			}
			return true;
		} catch (e){
			return false;
		}
	},

	
	
	filterTextStyle: function (style, plus) {
		if (typeof style == 'string') {
			var ts = '';
			if (style)
				for (var j = 0, k = 0; k >= 0; j = k + 1) {
					k = style.indexOf(';', j);
					var s = k >= 0 ? style.substring(j, k): style.substring(j),
						l = s.indexOf(':'),
						nm = l < 0 ? s.trim(): s.substring(0, l).trim();
					if (nm && (_txtStyles.$contains(nm)
					|| _txtStyles2.$contains(nm)
					|| (plus && plus.$contains(nm))))
						ts += s + ';';
				}
			return ts;
		}

		var ts = {};
		for (var nm in style)
			if (_txtStyles.$contains(nm) || _txtStyles2.$contains(nm)
			|| (plus && plus.$contains(nm)))
				ts[nm] = style[nm];
		return ts;
	},

	
	parseStyle: function (style) {
		var map = {};
		if (style) {
			var pairs = style.split(';');
			for (var j = 0, len = pairs.length; j < len;) {
				var v = pairs[j++].split(':'),
					nm = v.length > 0 ? v[0].trim(): '';
				if (nm)
					map[nm] = v.length > 1 ? v[1].trim(): '';
			}
		}
		return map;
	},

	
	newFrame: function (id, src, style) {
		if (!src) src = zjq.src0;
			

		var html = '<iframe id="'+id+'" name="'+id+'" src="'+src+'"';
		if (style == null) style = 'display:none';
		html += ' style="'+style+'"></iframe>';
		jq(document.body).append(html);
		return zk(id).jq[0];
	},
	
	newStackup: function (el, id, anchor) {
		el = jq(el||[], zk)[0];
		var ifr = document.createElement('iframe');
		ifr.id = id || (el ? el.id + "-ifrstk": 'z_ifrstk');
		ifr.style.cssText = 'position:absolute;overflow:hidden;opacity:0;filter:alpha(opacity=0)';
		ifr.frameBorder = 'no';
		ifr.tabIndex = -1;
		ifr.src = zjq.src0;
		if (el) {
			ifr.style.width = el.offsetWidth + 'px';
			ifr.style.height = el.offsetHeight + 'px';
			ifr.style.top = el.style.top;
			ifr.style.left = el.style.left;
			ifr.style.zIndex = el.style.zIndex;
			el.parentNode.insertBefore(ifr, anchor || el);
		}
		return ifr;
	},
	
	newHidden: function (nm, val, parent) {
		var inp = document.createElement('input');
		inp.type = 'hidden';
		inp.name = nm;
		inp.value = val;
		if (parent) parent.appendChild(inp);
		return inp;
	},

	
	head: function () {
		return document.getElementsByTagName('head')[0] || document.documentElement;
	},

	
	
	confirm: function (msg) {
		zk.alerting = true;
		try {
			return confirm(msg);
		} finally {
			try {zk.alerting = false;} catch (e) {} 
		}
	},
	
	alert: function (msg) {
		zk.alerting = true;
		try {
			alert(msg);
		} finally {
			try {zk.alerting = false;} catch (e) {} 
		}
	},
	
	onzsync: function (obj) {
		_zsyncs.unshift(obj);
	},
	
	unzsync: function (obj) {
		_zsyncs.$remove(obj);
	},
	
	zsync: function (org) {
		++_pendzsync;
		setTimeout(function () {_zsync(org);}, 50);	
	},

	
	focusOut: zk.ie < 11 ? function () {
		window.focus();
	}: function () {
		var a = jq('#z_focusOut')[0];
		if (!a) {
			
			jq(document.body).append('<a href="javascript:;" style="position:absolute;'
					+ 'left:' + zk.clickPointer[0] + 'px;top:' + zk.clickPointer[1]
					+ 'px;" id="z_focusOut"/>');
			a = jq('#z_focusOut')[0];
		}
		a.focus();
		setTimeout(function () {jq(a).remove();}, 500);
	},
	
	
	
	
	
	
	
	
	
	
	_syncScroll: {},
	
	onSyncScroll: function (wgt) {
		var sync = this._syncScroll;
		if (!sync[wgt.id])
			sync[wgt.id] = wgt;
	},
	
	doSyncScroll: function () {
		var sync = this._syncScroll;
		for (var id in sync) {
			sync[id].doResizeScroll_();
			delete sync[id];
		}
	},
	
	unSyncScroll: function (wgt) {
		delete this._syncScroll[wgt.id];
	}
});


zk.copy(jq.Event.prototype, {
	
	stop: function () {
		this.preventDefault();
		this.stopPropagation();
	},
	
	mouseData: function () {
		return zk.copy({
			pageX: this.pageX, pageY: this.pageY
		}, this.metaData());
	},
	
	keyData: function () {
		return zk.copy({
			keyCode: this.keyCode,
			charCode: this.charCode
			}, this.metaData());
	},
	
	metaData: function () {
		var inf = {};
		if (this.altKey) inf.altKey = true;
		if (this.ctrlKey) inf.ctrlKey = true;
		if (this.shiftKey) inf.shiftKey = true;
		if (this.metaKey) inf.metaKey = true;
		inf.which = this.which || 0;
		return inf;
	}
});


zk.copy(jq.Event, {
	
	fire: document.createEvent ? function (el, evtnm) {
		var evt = document.createEvent('HTMLEvents');
		evt.initEvent(evtnm, false, false);
		el.dispatchEvent(evt);
	}: function (el, evtnm) {
		el.fireEvent('on' + evtnm);
	},
	
	stop: function (evt) {
		evt.stop();
	},
	
	filterMetaData: function (data) {
		var inf = {}
		if (data.altKey) inf.altKey = true;
		if (data.ctrlKey) inf.ctrlKey = true;
		if (data.shiftKey) inf.shiftKey = true;
		if (data.metaKey) inf.metaKey = true;
		inf.which = data.which || 0;
		return inf;
	},
	
	zk: function (evt, wgt) {
		var type = evt.type,
			target = zk.Widget.$(evt) || wgt,
			data;

		if (type.startsWith('mouse')) {
			if (type.length > 5)
				type = 'Mouse' + type.charAt(5).toUpperCase() + type.substring(6);
			data = evt.mouseData();
		} else if (type.startsWith('key')) {
			if (type.length > 3)
				type = 'Key' + type.charAt(3).toUpperCase() + type.substring(4);
			data = evt.keyData();
		} else if (type == 'dblclick') {
			data = evt.mouseData();
			type = 'DoubleClick';
		} else {
			if (type == 'click')
				data = evt.mouseData();
			type = type.charAt(0).toUpperCase() + type.substring(1);
		}
		return new zk.Event(target, 'on' + type, data, {}, evt);
	}
});
})(document, window);


zk.copy(zjq.prototype, {
	beforeHideOnUnbind: function () { 
		return this.jq.each(function () {
			for (var ns = this.getElementsByTagName('iframe'), j = ns.length; j--;)
				ns[j].src = zjq.src0;
		});
	}
});



zk.Event = zk.$extends(zk.Object, {
	
	
	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	
 	

	
	$init: function (target, name, data, opts, domEvent) {
		this.currentTarget = this.target = target;
		this.name = name;
		this.data = data;
		if (data && typeof data == 'object' && !jq.isArray(data))
			zk.$default(this, data);

		this.opts = opts||{rtags:{}};
		if (this.domEvent = domEvent)
			this.domTarget = domEvent.target;
	},
	
	addOptions: function (opts) {
		this.opts = zk.copy(this.opts, opts);
	},
	
	stop: function (opts) {
		var b = !opts || !opts.revoke;
		if (!opts || opts.propagation) this.stopped = b;
		if (!opts || opts.dom) this.domStopped = b;
		if (opts && opts.au) this.auStopped = b;
	}
});

zWatch = (function () {
	var _visiEvts = {onFitSize: true, onSize: true, onShow: true, onHide: true, beforeSize: true},
		_watches = {}, 
		_dirty,
		_Gun = zk.$extends(zk.Object, {
			$init: function (name, xinfs, args, org, fns) {
				this.name = name;
				this.xinfs = xinfs;
				this.args = args;
				this.origin = org;
				this.fns = fns;
			},
			fire: function (ref) {
				var infs, inf, xinf,
					name = this.name,
					xinfs = this.xinfs,
					args = this.args,
					fns = this.fns;
				if (ref) {
					for (var j = 0, l = xinfs.length; j < l; ++j)
						if (xinfs[j][0] == ref) {
							infs = xinfs[j][1]
							xinfs.splice(j--, 1);
							--l;
							_invoke(name, infs, ref, args, fns);
						}
				} else
					while (xinf = xinfs.shift())
						_invoke(name, xinf[1], xinf[0], args, fns);
			},
			fireDown: function (ref) {
				if (!ref || ref.bindLevel == null)
					this.fire(ref);

				(new _Gun(this.name, _visiChildSubset(this.name, this.xinfs, ref, true), this.args, this.origin, this.fns))
				.fire();
			}
		});

	function _invoke(name, infs, o, args, fns) {
		for (var j = 0, l = infs.length; j < l;) {
			var f = _fn(infs[j++], o, name);
			if (fns)
				fns.push([f, o]); 
			else
				f.apply(o, args);
		}
		if (name == 'onSize') { 
			var after = o['onAfterSize'];
			if (after)
				after.apply(o, args);
		}
	}
	
	function _visible(name, c) {
		return c.isWatchable_ && c.isWatchable_(name); 
	}
	
	function _visibleChild(name, p, c, cache) {
		for (var w = c; w; w = w.parent)
			if (p == w) 
				return !cache || c.isWatchable_(name, p, cache);
		return false;
	}
	
	function _visiChildSubset(name, xinfs, p, remove) {
		var found = [], bindLevel = p.bindLevel,
			cache = _visiEvts[name] && {}, pvisible;
		if (p.isWatchable_) 
			for (var j = xinfs.length; j--;) {
				var xinf = xinfs[j],
					o = xinf[0],
					diff = bindLevel > o.bindLevel;
				if (diff) 
					break;

				if (!pvisible && cache) { 
					if (!(pvisible = _visible(name, p))) 
						break; 
					cache[p.uuid] = true; 
				}

				if (_visibleChild(name, p, o, cache)) {
					if (remove)
						xinfs.splice(j, 1);
					found.unshift(xinf); 
				}
			}
		return found;
	}
	function _visiSubset(name, xinfs) {
		xinfs = xinfs.$clone(); 
		if (_visiEvts[name])
			for (var j = xinfs.length; j--;)
				if (!_visible(name, xinfs[j][0]))
					xinfs.splice(j, 1);
		return xinfs;
	}
	function _target(inf) {
		return jq.isArray(inf) ? inf[0]: inf;
	}
	function _fn(inf, o, name) {
		var fn = jq.isArray(inf) ? inf[1]: o[name];
		if (!fn)
			throw (o.className || o) + ':' + name + ' not found';
		return fn;
	}
	function _sync() {
		if (!_dirty) return;

		_dirty = false;
		for (var nm in _watches) {
			var wts = _watches[nm];
			if (wts.length && wts[0][0].bindLevel != null)
				wts.sort(_cmpLevel);
		}
	}
	function _bindLevel(a) {
		return (a = a.bindLevel) == null || isNaN(a) ? -1: a;
	}
	function _cmpLevel(a, b) {
		return _bindLevel(a[0]) - _bindLevel(b[0]);
	}
	zk._zsyncFns = function (name, org) {
		if (name == 'onSize' || name == 'onShow' || name == 'onHide') {
			jq.zsync(org);
			if (name == 'onSize')
                setTimeout('zk.doAfterResize()', 20); 
		}
		if (name == 'onResponse')
			jq.doSyncScroll();
	};
	
	function _reversefns(fns, args) {
		if (fns)
			
			
			
			for (var j = fns.length, k = j - 1, i, f, oldp, newp; j >= 0;) {
				if (--j < 0 || (oldp != (newp=fns[j][1].parent) && oldp)) {
					for (i = j; ++i <= k;) {
						f = fns[i];
						f[0].apply(f[1], args);
					}
					k = j;
				}
				oldp = newp;
			}
	}
	function _fire(name, org, opts, vararg) {
		var wts = _watches[name];
		if (wts && wts.length) {
			var down = opts && opts.down && org.bindLevel != null;
			if (down) _sync();

			var args = [],
				fns = opts && opts.reverse ? []: null,
				gun = new _Gun(name,
					down ? _visiChildSubset(name, wts, org): _visiSubset(name, wts),
					args, org, fns);
			args.push(gun);
			for (var j = 2, l = vararg.length; j < l;) 
				args.push(vararg[j++]);

			if (opts && opts.timeout >= 0)
				setTimeout(function () {
					gun.fire();
					_reversefns(fns, args);
					zk._zsyncFns(name, org);
				}, opts.timeout);
			else {
				gun.fire();
				_reversefns(fns, args);
				zk._zsyncFns(name, org);
			}
		} else
			zk._zsyncFns(name, org);
	}
	
	function _isListened(wts, inf) {
		if (wts) {
			if (jq.isArray(inf)) {
				var isListen = false;
				for (var i = wts.length; i > 0; i--) {
					if (jq.isArray(wts[i]) && wts[i].$equals(inf)) {
						isListen = true;
						break;
					}
				}
				return isListen;
			}
			return wts.$contains(inf);
		}
		return false;
	}


  return {
  	
	listen: function (infs) {
		for (var name in infs) {
			var wts = _watches[name],
				inf = infs[name],
				o = _target(inf),
				xinf = [o, [inf]];
			if (wts) {
				var bindLevel = o.bindLevel;
				if (bindLevel != null) {
					for (var j = wts.length;;) {
						if (--j < 0) {
							wts.unshift(xinf);
							break;
						}
						if (wts[j][0] == o) {
							if (!_isListened(wts[j][1], inf)) 
								wts[j][1].push(inf);
							break;
						}
						if (bindLevel >= wts[j][0].bindLevel) { 
							wts.splice(j + 1, 0, xinf);
							break;
						}
					}
				} else
					for (var j = wts.length;;) {
						if (--j < 0) {
							wts.push(xinf);
							break;
						}
						if (wts[j][0] == o) {
							wts[j][1].push(inf);
							break;
						}
					}
			} else {
				_watches[name] = [xinf];
			}
		}
	},
	
	unlisten: function (infs) {
		for (var name in infs) {
			var wts = _watches[name];
			if (wts) {
				var inf = infs[name],
					o = _target(inf);
				for (var j = wts.length; j--;)
					if (wts[j][0] == o) {
						wts[j][1].$remove(inf);
						if (!wts[j][1].length)
							wts.splice(j, 1);
						break;
					}
			}
		}
	},
	
	unlistenAll: function (name) {
		delete _watches[name];
	},
	
	fire: function (name, org, opts) {
		_fire(name, org, opts, arguments);
	},
	
	fireDown: function (name, org, opts) {
		_fire(name, org, zk.copy(opts,{down:true}), arguments);
	},
	onBindLevelMove: function () { 
		_dirty = true;
	}
  };
})();
zWatch.listen({onBindLevelMove: zWatch});


(function () {
	var _aftAnims = [], 
		_jqstop = jq.fx.stop;

	jq.fx.stop = function () {
		_jqstop();
		for (var fn; fn = _aftAnims.shift();)
			fn();
	};

	function _addAnique(id, data) {
		var ary = zk._anique[id];
		if (!ary)
			ary = zk._anique[id] = [];
		ary.push(data);
	}
	function _doAnique(id) {
		var ary = zk._anique[id];
		if (ary) {
			var al = ary.length;
			while (al) {
				var data = ary.shift();
				if (jq(data.el).is(':animated')) {
					ary.unshift(data);
					break;
				}
				zk(data.el)[data.anima](data.wgt, data.opts);
				al--;
			}

			if (!al)
				delete zk._anique[id];
		}
	}

	function _saveProp(self, set) {
		var ele = self.jq;
		for(var i = set.length; i--;)
			if(set[i] !== null) ele.data('zk.cache.'+set[i], ele[0].style[set[i]]);
		return self;
	}
	function _restoreProp(self, set) {
		var ele = self.jq;
		for(var i = set.length; i--;)
			if(set[i] !== null) ele.css(set[i], ele.data('zk.cache.'+set[i]));
		return self;
	}
	function _checkAnimated(self, wgt, opts, anima) {
		if (self.jq.is(':animated')) {
			_addAnique(wgt.uuid, {el: self.jq[0], wgt: wgt, opts: opts, anima: anima});
			return true;
		}
		return false;
	}
	function _checkPosition(self, css) {
		var pos = self.jq.css('position');
		if (!pos || pos == 'static')
			css.position = 'relative';
		return self;
	}


zk.copy(zk, {
	
	animating: function () {
		return !!jq.timers.length;
	},
	
	afterAnimate: function (fn, delay) {
		if (zk.animating())
			_aftAnims.push(fn);
		else if (delay < 0) {
			fn();
			return true;
		} else
			setTimeout(fn, delay);
	},
	_anique: {}
});


zk.copy(zjq.prototype, {
	
	getAnimationSpeed : function (defaultValue) {
		var animationSpeed = jq(this.$().$n()).data('animationspeed'),
			jqSpeed = jq.fx.speeds;
		
		if(typeof animationSpeed === 'string') {
			if(jqSpeed[animationSpeed])
				return jqSpeed[animationSpeed];
			else
				animationSpeed = parseInt(animationSpeed);
		}
		
		
		return typeof animationSpeed === 'number' && !isNaN(animationSpeed) ? animationSpeed + 1 : (defaultValue || jqSpeed._default);
	},
	
	slideDown: function (wgt, opts) {
		if (_checkAnimated(this, wgt, opts, 'slideDown'))
			return this;

		var anchor = opts ? opts.anchor || 't': 't',
			prop = ['top', 'left', 'height', 'width', 'overflow', 'position'],
			anima = {},
			css = {overflow: 'hidden'},
			dims = this.dimension();

		opts = opts || {};
		_checkPosition(_saveProp(this, prop), css);

		switch (anchor) {
		case 't':
			css.height = '0';
			anima.height = jq.px0(dims.height);
			break;
		case 'b':
			css.height = '0';
			css.top = jq.px(dims.top + dims.height);
			anima.height = jq.px0(dims.height);
			anima.top = jq.px(dims.top);
			break;
		case 'l':
			css.width = '0';
			anima.width = jq.px0(dims.width);
			break;
		case 'r':
			css.width = '0';
			css.left = jq.px(dims.left + dims.width);
			anima.width = jq.px0(dims.width);
			anima.left = jq.px(dims.left);
			break;
		}

		return this.defaultAnimaOpts(wgt, opts, prop, true)
			.jq.css(css).show().animate(anima, {
			queue: false, easing: opts.easing, duration: this.getAnimationSpeed(opts.duration || 250),
			complete: opts.afterAnima
		});
	},
	
	slideUp: function (wgt, opts) {
		if (_checkAnimated(this, wgt, opts, 'slideUp'))
			return this;
		
		var anchor = opts ? opts.anchor || 't': 't',
			prop = ['top', 'left', 'height', 'width', 'overflow', 'position'],
			anima = {},
			css = {overflow: 'hidden'},
			dims = this.dimension();

		opts = opts || {};
		_checkPosition(_saveProp(this, prop), css);

		switch (anchor) {
		case 't':
			anima.height = 'hide';
			break;
		case 'b':
			css.height = jq.px0(dims.height);
			anima.height = 'hide';
			anima.top = jq.px(dims.top + dims.height);
			break;
		case 'l':
			anima.width = 'hide';
			break;
		case 'r':
			css.width = jq.px0(dims.width);
			anima.width = 'hide';
			anima.left = jq.px(dims.left + dims.width);
			break;
		}

		return this.defaultAnimaOpts(wgt, opts, prop)
			.jq.css(css).animate(anima, {
			queue: false, easing: opts.easing, duration: this.getAnimationSpeed(opts.duration || 250),
			complete: opts.afterAnima
		});
	},
	
	slideOut: function (wgt, opts) {
		if (_checkAnimated(this, wgt, opts, 'slideOut'))
			return this;
		
		var anchor = opts ? opts.anchor || 't': 't',
			prop = ['top', 'left', 'position'],
			anima = {},
			css = {},
			dims = this.dimension();

		opts = opts || {};
		_checkPosition(_saveProp(this, prop), css);

		switch (anchor) {
		case 't':
			anima.top = jq.px(dims.top - dims.height);
			break;
		case 'b':
			anima.top = jq.px(dims.top + dims.height);
			break;
		case 'l':
			anima.left = jq.px(dims.left - dims.width);
			break;
		case 'r':
			anima.left = jq.px(dims.left + dims.width);
			break;
		}

		return this.defaultAnimaOpts(wgt, opts, prop)
			.jq.css(css).animate(anima, {
			queue: false, easing: opts.easing, duration: this.getAnimationSpeed(opts.duration || 350),
			complete: opts.afterAnima
		});
	},
	
	slideIn: function (wgt, opts) {
		if (_checkAnimated(this, wgt, opts, 'slideIn'))
			return this;
		
		var anchor = opts ? opts.anchor || 't': 't',
			prop = ['top', 'left', 'position'],
			anima = {},
			css = {},
			dims = this.dimension();

		opts = opts || {};
		_checkPosition(_saveProp(this, prop), css);

		switch (anchor) {
		case 't':
			css.top = jq.px(dims.top - dims.height);
			anima.top = jq.px(dims.top);
			break;
		case 'b':
			css.top = jq.px(dims.top + dims.height);
			anima.top = jq.px(dims.top);
			break;
		case 'l':
			css.left = jq.px(dims.left - dims.width);
			anima.left = jq.px(dims.left);
			break;
		case 'r':
			css.left = jq.px(dims.left + dims.width);
			anima.left = jq.px(dims.left);
			break;
		}

		return this.defaultAnimaOpts(wgt, opts, prop, true)
			.jq.css(css).show().animate(anima, {
			queue: false, easing: opts.easing, duration: this.getAnimationSpeed(opts.duration || 350),
			complete: opts.afterAnima
		});
	},
	_updateProp: function(prop) { 
		_saveProp(this, prop);
	},
	
	defaultAnimaOpts: function (wgt, opts, prop, visible) {
		var self = this;
		jq.timers.push(function() {
			if (!visible)
				zWatch.fireDown('onHide', wgt);
			if (opts.beforeAnima)
				opts.beforeAnima.call(wgt, self);
		});

		var aftfn = opts.afterAnima;
		opts.afterAnima = function () {
			if (prop) _restoreProp(self, prop);
			if (visible) {
				
				if (zk.ie == 8 || zk.ie == 10) zk(self.jq[0]).redoCSS(); 
				zUtl.fireShown(wgt);
			} else {
				self.jq.hide();
			}
			if (aftfn) aftfn.call(wgt, self.jq.context);
			wgt.afterAnima_(visible);
			setTimeout(function () {
				_doAnique(wgt.uuid);
			});
		};
		return this;
	}
});
})();

(function () {
	var _drags = [],
		_dragging = {},
		_actTmout, 
		_stackup, _activedg, _initPt, _dnEvt,
		_lastPt, _lastScrlPt;

	function _activate(dg, devt, pt) {
		_actTmout = setTimeout(function () { 
			_actTmout = null; 
			
			if (!(zk.ie < 11) || !_activedg || _activedg.node == dg.node)
				_activedg = dg; 
		}, dg.opts.delay);
		_initPt = pt;
	}
	function _deactivate() {
		_activedg = null;
		if (_dnEvt) setTimeout(function(){_dnEvt=null;}, 0);
	}

	function _docmousemove(devt) {
		if(!_activedg || _activedg.dead) return;

		var evt = jq.Event.zk(devt),
			pt = [evt.pageX, evt.pageY];
		
		
		
		if(_lastPt && _lastPt[0] == pt[0]
		&& _lastPt[1] == pt[1])
			return;

		_lastPt = pt;
		_activedg._updateDrag(pt, evt);
		devt.stop();
			
			
	}
	function _docmouseup(devt) {
		if(_actTmout) { 
			clearTimeout(_actTmout); 
			_actTmout = null; 
		}
		var evt = jq.Event.zk(devt),
			adg = _activedg;
		if(!adg) {
			
			if (evt.which == 1)
				_dnEvt = null;
			return;
		}

		_lastPt = _activedg = null;
		adg._endDrag(evt);
		if (evt.domStopped) devt.stop();
		
		if(adg._suicide) {
			adg._suicide = false;
			adg.destroy();
		}
	}
	function _dockeypress(devt) {
		if(_activedg) _activedg._keypress(devt);
	}

	
	function _defStartEffect(dg) {
		var node = dg.node;
		node._$opacity = jq(node).css('opacity');
		_dragging[node] = true;
		new zk.eff.Opacity(node, {duration:0.2, from:node._$opacity, to:0.7}); 
	}
	function _defEndEffect(dg) {
		var node = dg.node,
			toOpacity = typeof node._$opacity == 'number' ? node._$opacity : 1.0;
		new zk.eff.Opacity(node, {duration:0.2, from:0.7,
			to:toOpacity, queue: {scope:'_draggable', position:'end'},
			afterFinish: function () { 
				delete _dragging[node];
			}
		});
	}
	function _defRevertEffect(dg, offset) {
		var dx, dy;
		if ((dx=offset[0]) || (dy=offset[1])) {
			var node = dg.node,
				orgpos = node.style.position,
				dur = Math.sqrt(Math.abs(dy^2)+Math.abs(dx^2))*0.02;
			new zk.eff.Move(node, { x: -dx, y: -dy,
				duration: dur, queue: {scope:'_draggable', position:'end'},
				afterFinish: function () {node.style.position = orgpos;}});
		}
	}
	

zk.Draggable = zk.$extends(zk.Object, {
	
	
	
	
	
	
	
	
	
	$init: function (control, node, opts) {
		if (!_stackup) {
		
			jq(_stackup = jq.newStackup(null, 'z_ddstkup')).hide();
			document.body.appendChild(_stackup);
		}

		this.control = control;
		this.node = node = node ? jq(node, zk)[0]: control.node || (control.$n ? control.$n() : null);
		if (!node)
			throw 'Handle required for '+control;

		opts = zk.$default(opts, {

			scrollSensitivity: 20,
			scrollSpeed: 15,
			initSensitivity: 3,
			delay: 0,
			fireOnMove: true
		});

		if (opts.reverteffect == null)
			opts.reverteffect = _defRevertEffect;
		if (opts.endeffect == null) {
			opts.endeffect = _defEndEffect;
			if (opts.starteffect == null)
				opts.starteffect = _defStartEffect;
		}

		if(opts.handle) this.handle = jq(opts.handle, zk)[0];
		if(!this.handle) this.handle = node;

		if(opts.scroll && !opts.scroll.scrollTo && !opts.scroll.outerHTML) {
			opts.scroll = jq(opts.scroll, zk)[0];
			this._isScrollChild = zUtl.isAncestor(opts.scroll, node);
		}

		this.delta = this._currentDelta();
		this.opts = opts;
		this.dragging = false;   

		jq(this.handle).bind('zmousedown', this.proxy(this._mousedown));

		
		if(_drags.length == 0)
			jq(document).bind('zmouseup', _docmouseup)
				.bind('zmousemove', _docmousemove)
				.keypress(_dockeypress);
		_drags.push(this);
	},
	
	destroy: function () {
		if(this.dragging) {
			
			
			this._suicide = true;
			return;
		}
		jq(this.handle).unbind('zmousedown', this.proxy(this._mousedown));

		
		_drags.$remove(this);
		if(_drags.length == 0)
			jq(document).unbind('zmouseup', _docmouseup)
				.unbind('zmousemove', _docmousemove)
				.unbind('keypress', _dockeypress);
		if (_activedg == this) 
			_activedg = null;

		this.node = this.control = this.handle = null;
		this.dead = true;
	},

	
	_currentDelta: function () {
		var $node = jq(this.node);
		return [zk.parseInt($node.css('left')), zk.parseInt($node.css('top'))];
	},

	_startDrag: function (evt) {
		zWatch.fire('onStartDrag', this, evt);

		
		zk(document.body).disableSelection(); 
		jq.clearSelection(); 
		if (this.opts.overlay) { 
			var stackup = document.createElement('div');
			document.body.appendChild(stackup);
			stackup.className = 'z-dd-stackup';
			zk(stackup).disableSelection();
			var st = (this.stackup = stackup).style;
			st.width = jq.px0(jq(document).width());
			st.height = jq.px0(jq(document).height());
		}
		zk.dragging = this.dragging = true;

		var node = this.node,
			opt;
		if(opt = this.opts.ghosting)
			if (typeof opt == 'function') {
				this.delta = this._currentDelta();
				this.orgnode = this.node;

				var $node = zk(this.node),
					ofs = $node.cmOffset();
				this.z_scrl = $node.scrollOffset();
				this.z_scrl[0] -= jq.innerX(); this.z_scrl[1] -= jq.innerY();
					
				ofs[0] -= this.z_scrl[0]; ofs[1] -= this.z_scrl[1];

				node = this.node = opt(this, ofs, evt);
			} else {
				this._clone = jq(node).clone()[0];
				this.z_orgpos = node.style.position; 
				if (this.z_orgpos != 'absolute')
					jq(node).absolutize();
				node.parentNode.insertBefore(this._clone, node);
			}

		if (this.opts.stackup) {
			if (zk(_stackup).isVisible()) 
				this._stackup = jq.newStackup(node, node.id + '-ddstk');
			else {
				this._stackup = _stackup;
				this._syncStackup();
				node.parentNode.insertBefore(_stackup, node);
			}
		}

		this.orgZ = -1;
		if(opt = this.opts.zIndex) { 
			if (typeof opt == 'function')
				opt = opt(this);
			if (opt >= 0) {
				this.orgZ = zk.parseInt(jq(node).css('z-index'));
				node.style.zIndex = opt;
			}
		}

		if(this.opts.scroll) {
			if (this.opts.scroll == window) {
				var where = this._getWndScroll(this.opts.scroll);
				this.orgScrlLeft = where.left;
				this.orgScrlTop = where.top;
			} else {
				this.orgScrlLeft = this.opts.scroll.scrollLeft;
				this.orgScrlTop = this.opts.scroll.scrollTop;
			}
		}

		if(this.opts.starteffect)
			this.opts.starteffect(this, evt);
	},
	_syncStackup: function () {
		if (this._stackup) {
			var node = this.node,
				st = this._stackup.style;
			st.display = 'block';
			st.left = node.offsetLeft + 'px';
			st.top = node.offsetTop + 'px';
			st.width = node.offsetWidth + 'px';
			st.height = node.offsetHeight + 'px';
		}
	},

	_updateDrag: function (pt, evt) {
		if(!this.dragging) {
			var v = this.opts.initSensitivity;
			if (v && pt[0] <= _initPt[0] + v && pt[0] >= _initPt[0] - v
			&& pt[1] <= _initPt[1] + v && pt[1] >= _initPt[1] - v)
				return;
			this._startDrag(evt);
		}
		this._updateInnerOfs();

		this._draw(pt, evt);
		if (this.opts.change) this.opts.change(this, pt, evt);
		this._syncStackup();

		if(this.opts.scroll) {
			this._stopScrolling();

			var p;
			if (this.opts.scroll == window) {
				var o = this._getWndScroll(this.opts.scroll);
				p = [o.left, o.top, o.left + o.width, o.top + o.height];
			} else {
				p = zk(this.opts.scroll).viewportOffset();
				p[0] += this.opts.scroll.scrollLeft + this._innerOfs[0];
				p[1] += this.opts.scroll.scrollTop + this._innerOfs[1];
				p.push(p[0]+this.opts.scroll.offsetWidth);
				p.push(p[1]+this.opts.scroll.offsetHeight);
			}

			var speed = [0,0],
				v = this.opts.scrollSensitivity;
			if(pt[0] < (p[0]+v)) speed[0] = pt[0]-(p[0]+v);
			if(pt[1] < (p[1]+v)) speed[1] = pt[1]-(p[1]+v);
			if(pt[0] > (p[2]-v)) speed[0] = pt[0]-(p[2]-v);
			if(pt[1] > (p[3]-v)) speed[1] = pt[1]-(p[3]-v);
			this._startScrolling(speed);
		}

		
		if(navigator.appVersion.indexOf('AppleWebKit')>0) window.scrollBy(0,0);

		evt.stop();
	},

	_finishDrag: function (evt, success) {
		this.dragging = false;
		if (this.stackup) {
			jq(this.stackup).remove();
			delete this.stackup;
		}

		
		zk(document.body).enableSelection();
		setTimeout(jq.clearSelection, 0);

		var stackup = this._stackup;
		if (stackup) {
			if (stackup == _stackup) jq(stackup).hide();
			else jq(stackup).remove();
			delete this._stackup;
		}

		var node = this.node;
		if(this.opts.ghosting)
			if (typeof this.opts.ghosting == 'function') {
				if (this.opts.endghosting)
					this.opts.endghosting(this, this.orgnode);
				if (node != this.orgnode) {
					jq(node).remove();
					this.node = this.orgnode;
				}
				delete this.orgnode;
			} else {
				if (this.z_orgpos != 'absolute') { 
					zk(this.node).relativize();
					node.style.position = this.z_orgpos;
				}
				jq(this._clone).remove();
				this._clone = null;
			}

		var pt = [evt.pageX, evt.pageY];
		var revert = this.opts.revert;
		if(revert && typeof revert == 'function')
			revert = revert(this, pt, evt);

		var d = this._currentDelta(),
			d2 = this.delta;
		if(revert && this.opts.reverteffect) {
			this.opts.reverteffect(this,
				[d[0]-this.delta[0], d[1]-this.delta[1]]);
		} else {
			this.delta = d;
		}

		if(this.orgZ != -1)
			node.style.zIndex = this.orgZ;

		if(this.opts.endeffect) 
			this.opts.endeffect(this, evt);

		var wgt = this.control;
		if (this.opts.fireOnMove && zk.Widget.isInstance(wgt)) {
			if (d[0] != d2[0] || d[1] != d2[1]) {
				wgt.fire('onMove', zk.copy({
					left: node.style.left,
					top: node.style.top
				}, evt.data), {ignorable: true});
			}
		}
		_deactivate(this);
		var self = this;
		setTimeout(function(){
			zk.dragging=false;
			zWatch.fire('onEndDrag', self, evt);
		}, zk.ios ? 500: 0);
			
	},

	_mousedown: function (devt) {
		var node = this.node,
			evt = jq.Event.zk(devt),
			target = devt.target;
		if (_actTmout || _dragging[node] || evt.which != 1
			|| (zk.webkit && jq.nodeName(target, 'select'))
			|| (zk(target).isInput() && this.control != zk.Widget.$(target)))
			return;
			
			

		var pt = [evt.pageX, evt.pageY];
		
		if (this.opts.ignoredrag && this.opts.ignoredrag(this, pt, evt)) {
			if (evt.domStopped) devt.stop();
			return;
		}

		
		
		var pos = zk(node).cmOffset(),
			ofs = [pt[0] - pos[0], pt[1] - pos[1]], v;
		
		if ( (v=node.clientWidth) && ofs[0] > v && node.offsetWidth > v + 3
		|| (v=node.clientHeight) && ofs[1] > v && node.offsetHeight > v + 3) 
			return;

		this.offset = ofs;
		_activate(this, devt, pt);
		
		if ((!(zk.ie < 11) || zk.ie8) && !zk.mobile) {
			if (!zk.Draggable.ignoreStop(target)) { 
				devt.stop();
				
				zWatch.fire('onFloatUp', evt.target);
			}
			
			
			
			
			
			
			
			
			
			

			_dnEvt = jq.Event.zk(devt, this.control);
			
		}
	},
	_keypress: function (devt) {
		if(devt.keyCode == 27) {
			this._finishDrag(jq.Event.zk(devt), false);
			devt.stop();
		}
	},

	_endDrag: function (evt) {
		if(this.dragging) {
			this._stopScrolling();
			this._finishDrag(evt, true);
			evt.stop();
		} else
			_deactivate(this);
	},

	_draw: function (point, evt) {
		var node = this.node,
			$node = zk(node),
			pos = $node.cmOffset(),
			opts = this.opts;
		if(opts.ghosting) {
			var r = $node.scrollOffset();
			pos[0] += r[0] - this._innerOfs[0]; pos[1] += r[1] - this._innerOfs[1];
		}

		var d = this._currentDelta(),
			scroll = opts.scroll;
		pos[0] -= d[0]; pos[1] -= d[1];

		if(scroll && (scroll != window && this._isScrollChild)) {
			pos[0] -= scroll.scrollLeft-this.orgScrlLeft;
			pos[1] -= scroll.scrollTop-this.orgScrlTop;
		}

		var p = [point[0]-pos[0]-this.offset[0],
			point[1]-pos[1]-this.offset[1]],
			snap = opts.snap;

		if(snap)
			if(typeof snap == 'function') {
				p = snap(this, p);
			} else {
				if(snap instanceof Array) {
					p = [Math.round(p[0]/snap[0])*snap[0],
						Math.round(p[1]/snap[1])*snap[1]];
				} else {
					p = [Math.round(p[0]/snap)*snap,
						Math.round(p[1]/snap)*snap];
				}
			}

		
		if (this.z_scrl) {
			p[0] -= this.z_scrl[0]; p[1] -= this.z_scrl[1];
		}

		var style = node.style;
		if (typeof opts.draw == 'function') {
			opts.draw(this, this.snap_(p, opts), evt);
		} else if (typeof opts.constraint == 'function') {
			var np = opts.constraint(this, p, evt); 
			if (np) p = np;
			p = this.snap_(p, opts);
			style.left = jq.px(p[0]);
			style.top  = jq.px(p[1]);
		} else {
			p = this.snap_(p, opts);
			if((!opts.constraint) || (opts.constraint=='horizontal'))
				style.left = jq.px(p[0]);
			if((!opts.constraint) || (opts.constraint=='vertical'))
				style.top  = jq.px(p[1]);
		}

		if(style.visibility=='hidden') style.visibility = ''; 
	},

	_stopScrolling: function () {
		if(this.scrollInterval) {
			clearInterval(this.scrollInterval);
			this.scrollInterval = null;
			_lastScrlPt = null;
		}
	},
	_startScrolling: function (speed) {
		if(speed[0] || speed[1]) {
			this.scrollSpeed = [speed[0]*this.opts.scrollSpeed,speed[1]*this.opts.scrollSpeed];
			this.lastScrolled = new Date();
			this.scrollInterval = setInterval(this.proxy(this._scroll), 10);
		}
	},

	_scroll: function () {
		var current = new Date(),
			delta = current - this.lastScrolled;
		this.lastScrolled = current;
		if(this.opts.scroll == window) {
			if (this.scrollSpeed[0] || this.scrollSpeed[1]) {
				var o = this._getWndScroll(this.opts.scroll),
					d = delta / 1000;
				this.opts.scroll.scrollTo(o.left + d*this.scrollSpeed[0],
					o.top + d*this.scrollSpeed[1]);
			}
		} else {
			this.opts.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1000;
			this.opts.scroll.scrollTop  += this.scrollSpeed[1] * delta / 1000;
		}

		this._updateInnerOfs();
		if (this._isScrollChild) {
			_lastScrlPt = _lastScrlPt || _lastPt;
			_lastScrlPt[0] += this.scrollSpeed[0] * delta / 1000;
			_lastScrlPt[1] += this.scrollSpeed[1] * delta / 1000;
			if (_lastScrlPt[0] < 0)
				_lastScrlPt[0] = 0;
			if (_lastScrlPt[1] < 0)
				_lastScrlPt[1] = 0;
			this._draw(_lastScrlPt);
		}

		if(this.opts.change) {
			var devt = window.event ? jq.event.fix(window.event): null,
				evt = devt ? jq.Event.zk(devt): null;
			this.opts.change(this,
				evt ? [evt.pageX, evt.pageY]: _lastPt, evt);
		}
	},

	_updateInnerOfs: function () {
		this._innerOfs = [jq.innerX(), jq.innerY()];
	},
	_getWndScroll: function (w) {
		var T, L, W, H,
			doc = w.document,
			de = doc.documentElement;
		if (de && de.scrollTop) {
			T = de.scrollTop;
			L = de.scrollLeft;
		} else if (w.document.body) {
			T = doc.body.scrollTop;
			L = doc.body.scrollLeft;
		}
		if (w.innerWidth) {
			W = w.innerWidth;
			H = w.innerHeight;
		} else if (de && de.clientWidth) {
			W = de.clientWidth;
			H = de.clientHeight;
		} else {
			W = doc.body.offsetWidth;
			H = doc.body.offsetHeight
		}
		return {top: T, left: L, width: W, height: H};
	},

	
	snap_: function (pos, opts) {
		if (!opts.snap && pos[1] < 0)
			pos[1] = 0;
		return pos;
	}

},{
	ignoreMouseUp: function () { 
		return zk.dragging ? true: _dnEvt;
	},
	ignoreClick: function () { 
		return zk.dragging;
	},
	ignoreStop: function (target) { 
		
		return zk(target).isInput()
			
			
			|| ((zk.ie > 8 || zk.chrome || zk.opera) && jq.nodeName(target, 'select'))
			|| (jq(target).parents('a').length && !jq.nodeName(target, 'img'))
			|| jq.nodeName(target, 'option'); 
	}
});
})();


(function() {

	var _defSKUOpts, _useSKU;



zk.eff = {
	shallStackup: function () {
		return _useSKU;
	},
	_skuOpts: function (opts) {
		return zk.$default(opts,
			_defSKUOpts || (_defSKUOpts = {stackup: zk.eff.shallStackup()}));
	},
	
	_onVParent: function(evt, opts) {
		if (opts && (sdw = opts.shadow) && (stackup = sdw.stackup)) { 
			var $stk = jq(stackup);
			if ($stk.parent()[0] != document.body);
				$stk.insertBefore(sdw.node);
		}
	}	
};


zk.eff.Shadow = zk.$extends(zk.Object, {
	$init: function (element, opts) {
		this.wgt = zk.Widget.$(element.id);
		this.opts = zk.eff._skuOpts(opts);
		this.node = element;
		
		zWatch.listen({ onVParent: [this.node, zk.eff._onVParent] });
	},
	destroy: function () {
		jq(this.stackup).remove();
		jq(this.node).removeClass(this.wgt.getZclass() + '-shadow');
		zWatch.unlisten({ onVParent: [this.node, zk.eff._onVParent] }); 
		this.wgt = this.node = this.stackup = null;
	},
	hide: function(){
		jq(this.stackup).hide();
		jq(this.node).removeClass(this.wgt.getZclass() + '-shadow');
	},
	sync: function () {
		var node = this.node, $node = jq(node);
		if (!node || !$node.zk.isVisible(true)) {
			if (this.opts.stackup && node) {
				if (!this.stackup) 
					this.stackup = jq.newStackup(node, node.id + '-sdwstk', node);
			}
			this.hide();
			return false;
		}
		
		$node.addClass(this.wgt.getZclass() + '-shadow');
		
		var opts = this.opts,
			l = node.offsetLeft, t = node.offsetTop,
			w = node.offsetWidth, h = node.offsetHeight,
			stackup = this.stackup;
			
		if(opts.stackup) {
			if(!stackup)
				stackup = this.stackup =
					jq.newStackup(node, node.id + '-sdwstk', node);

			var st = stackup.style;
			st.left = jq.px(l);
			st.top = jq.px(t);
			st.width = jq.px0(w);
			st.height = jq.px0(h);
			st.zIndex = zk.parseInt($node.css('zIndex'));
			st.display = 'block';
		}
		return true;
	},
	getBottomElement: function () {
		return this.stackup;
	}
});

	
	
	function _syncMaskPos() {
		var n = this.mask,
			st = n.style;
		if (st.display != 'none') {
			var ofs = zk(n).toStyleOffset(jq.innerX(), jq.innerY());
			st.left = jq.px(ofs[0]);
			st.top = jq.px(ofs[1]);
			st.width = jq.px0(jq.innerWidth());
			st.height = jq.px0(jq.innerHeight());

			if (n = this.stackup)
				zk.set(n.style, st, ['left', 'top', 'width', 'height']);
		}
	}


zk.eff.FullMask = zk.$extends(zk.Object, {
	
	$init: function (opts) {
		opts = zk.eff._skuOpts(opts);
		var mask = this.mask = jq(opts.mask||[], zk)[0];
		if (this.mask) {
			if (opts.anchor)
				opts.anchor.parentNode.insertBefore(mask, opts.anchor);
			if (opts.id) mask.id = opts.id;
			if (opts.zIndex != null) mask.style.zIndex = opts.zIndex;
			if (opts.visible == false) mask.style.display = 'none';
		} else {
			var maskId = opts.id || 'z_mask',
				html = '<div id="' + maskId + '" class="z-modal-mask"';
			if (opts.zIndex != null || opts.visible == false) {
				html += ' style="';
				if (opts.zIndex != null) html += 'z-index:' + opts.zIndex;
				if (opts.visible == false) html += ';display:none';
				html +='"';
			}

			html += '></div>'
			if (opts.anchor)
				jq(opts.anchor, zk).before(html);
			else
				jq(document.body).append(html);
			mask = this.mask = jq(maskId, zk)[0];
		}
		if (opts.stackup)
			this.stackup = jq.newStackup(mask, mask.id + '-mkstk');

		_syncMaskPos.call(this);

		var f;
		jq(mask).click(jq.Event.stop); 
		jq(window).resize(f = this.proxy(_syncMaskPos))
			.scroll(f);
	},
	
	destroy: function () {
		var mask = this.mask, f;
		jq(mask).unbind('click', jq.Event.stop)
			.remove()
		jq(window).unbind('resize', f = this.proxy(_syncMaskPos))
			.unbind('scroll', f);
		jq(this.stackup).remove();
		this.mask = this.stackup = null;
	},
	
	hide: function () {
		this.mask.style.display = 'none';
		if (this.stackup) this.stackup.style.display = 'none';
	},
	
	sync: function (el) {
		if (!zk(el).isVisible(true)) {
			this.hide();
			return;
		}

		if (this.mask.nextSibling != el) {
			var p = el.parentNode;
			p.insertBefore(this.mask, el);
			if (this.stackup)
				p.insertBefore(this.stackup, this.mask);
		}

		var st = this.mask.style;
		st.display = 'block';
		st.zIndex = el.style.zIndex;

		_syncMaskPos.call(this, true);

		if (this.stackup) {
			st = this.stackup.style;
			st.display = 'block';
			st.zIndex = el.style.zIndex;
		}
	}
});

 
zk.eff.Mask = zk.$extends(zk.Object, {
	
	$init: function(opts) {
		opts = opts || {};
		var $anchor = zk(opts.anchor);
		
		if (!$anchor.jq.length || !$anchor.isRealVisible(true)) return; 
		
		this._opts = opts;
		
		var maskId = opts.id || 'z_applymask',
			progbox = jq(maskId, zk)[0];
		
		if (progbox) return this;
		
		var msg = opts.message || ((window.msgzk?msgzk.LOADING:'Loading')+'...'),
			n = document.createElement('div');
		
		document.body.appendChild(n);
		var xy = opts.offset || $anchor.revisedOffset(), 
			w = opts.width || $anchor.offsetWidth(),
			h = opts.height || $anchor.offsetHeight();
		jq(n).replaceWith(
		'<div id="'+maskId+'" style="display:none">' 
		+ '<div class="z-apply-mask" style="display:block;top:' + xy[1]
		+ 'px;left:' + xy[0] + 'px;width:' + w + 'px;height:' + h + 'px;"></div>'
		+ '<div id="'+maskId+'-z_loading" class="z-apply-loading"><div class="z-apply-loading-indicator">'
		+ '<span class="z-apply-loading-icon"></span> '
		+ msg+ '</div></div></div>');
		
		this.mask = jq(maskId, zk)[0];
		this.wgt = zk.Widget.$(opts.anchor);
		if (this.wgt) {
			zWatch.listen( {
				onHide: [
					this.wgt, this.onHide
				],
				onSize: [
					this.wgt, this.onSize
				]
			});
			this.wgt.__mask = this;
		}
		
		this.sync();
	},
	
	hide: function () {
		this.mask.style.display = 'none';
	},
	onHide: function () {
		this.__mask.hide();
	}, 
	
	sync: function () {
		var $anchor = zk(this._opts.anchor);
		
		if (!$anchor.isVisible(true)) {
			this.hide();
			return;
		}
		
		var opts = this._opts,
			st = this.mask.firstChild.style,
			xy = opts.offset || $anchor.revisedOffset(), 
			w = opts.width || $anchor.offsetWidth(),
			h = opts.height || $anchor.offsetHeight();

		st.top = jq.px(xy[1]);
		st.left = jq.px(xy[0]);
		st.width = jq.px(w);
		st.height = jq.px(h);
		
		
		
		
		var body = document.body,
			html = body.parentNode,
			rleaf = $anchor.jq,
			zi = 'auto', 
			zic, zicv;
		
		for (var offp = rleaf.offsetParent(); offp[0] != body && offp[0] != html; offp = offp.offsetParent())
			if ((zic = offp.css('z-index')) && zic != 'auto') {
				zi = zk.parseInt(zic);
				rleaf = offp[0];
			}
		
		for (var n = rleaf[0]; n && n.style; n = n.parentNode) {
			
			if (n.tagName == 'HTML' && zk.webkit)
				n.style.zIndex = 'auto';
			var zic = n.style.zIndex || jq(n).css('z-index');
			if (zic && zic != 'auto') {
				zicv = zk.parseInt(zic);
				if (zi == 'auto' || zicv > zi)
					zi = zicv;
			}
		}
		
		if (zi != 'auto') { 
			st.zIndex = zi;
			this.mask.lastChild.style.zIndex = zi;
		}
		
		this.mask.style.display = 'block';
		
		var loading = jq(this.mask.id+'-z_loading', zk)[0];
		if (loading) {
			if (loading.offsetHeight > h) 
				loading.style.height = jq.px0(zk(loading).revisedHeight(h));
			if (loading.offsetWidth > w)
				loading.style.width = jq.px0(zk(loading).revisedWidth(w));
			loading.style.top = jq.px0(xy[1] + ((h - loading.offsetHeight) /2)); 
			loading.style.left = jq.px0(xy[0] + ((w - loading.offsetWidth) /2));
		}
		
		this.mask.style.visibility = '';
	},
	onSize: function () {
		this.__mask.sync();
	},

	
	destroy: function () {
		jq(this.mask).remove();
		if (this.wgt) {
			zWatch.unlisten({onHide: [this.wgt, this.onHide], onSize: [this.wgt, this.onSize]});
			delete this.wgt.__mask;
		}
		this.mask = this.wgt = null;
	}
});


zk.eff.Actions = {
	
	slideDown: function (n, opts) {
		zk(n).slideDown(this, opts);
	},
	
	slideUp: function (n, opts) {
		zk(n).slideUp(this, opts);
	},
	
	slideIn: function (n, opts) {
		zk(n).slideIn(this, opts);
	},
	
	slideOut: function (n, opts) {
		zk(n).slideOut(this, opts);
	}
};

jq(function() {
	
	var _lastFloat, _autohideCnt = 0, _callback;

	function _onFloatUp(ctl) {
		var wgt = ctl.origin;
		++_autohideCnt;
		setTimeout(function () {
			if (!--_autohideCnt) {
				if (wgt)
					wgt = wgt.getTopWidget();
				if (wgt != _lastFloat) {
					_lastFloat = wgt
					zk._wgtutl.autohide(); 
				}
			}
		}, 120); 
	}
	function _autohide() {
		_lastFloat = false; 
		++_autohideCnt;
		setTimeout(function () {
			if (!--_autohideCnt)
				zk._wgtutl.autohide();
		}, 100); 
	}

	_useSKU = zk.useStackup;
	if (_useSKU == 'auto' || (_callback = _useSKU == 'auto/gecko')) {
		if (zk.gecko && _callback)
			_useSKU = false;
		else {
			_callback = zk.webkit || zk.opera;
			_useSKU = !_callback || zk.ie; 
		}
	} else if (_useSKU == null)
		_useSKU = zk.ie; 

	 
		var w2hide = function (name) {
			if (name == 'onSize' || name == 'onMove'
			|| name == 'onShow' || name == 'onHide'
			|| name == 'onResponse')
				_autohide();
		};
		zk.override(zWatch, _callback = {}, {
			fire: function (name) {
				_callback.fire.apply(this, arguments);
				w2hide(name);
			},
			fireDown: function (name) {
				_callback.fireDown.apply(this, arguments);
				w2hide(name);
			}
		});
		zWatch.listen({onFloatUp: ['', _onFloatUp]});
	
}); 

})();



zk.BigDecimal = zk.$extends(zk.Object, {
	_precision: 0,
	$define: {
		
		
		precision: null
	},
	
	$init: function (value) {
		value = value ? '' + value: '0';
		var jdot = -1;
		for (var j = 0, len = value.length; j < len; ++j) {
			var cc = value.charAt(j);
			if (((cc < '0' || cc > '9') && cc != '-' && cc != '+') || 
				(j && (cc == '-' || cc == '+')))
				if (jdot < 0 && cc == '.') {
					jdot = j;
				} else {
					value = value.substring(0, j);
					break;
				}
		}
		if (jdot >= 0) {
			value = value.substring(0, jdot) + value.substring(jdot + 1);
			this._precision = value.length - jdot;
			this._dot = true;
		}
		this._value = value;
	},
	$toNumber: function () {
		var v = parseFloat(this._value), p;
		if (p = this._precision)
			v /= Math.pow(10, p);
		return v;
	},
	
	$toString: function() { 
		if (this._value.length == 0) return ''; 
		var j = this._value.length - this._precision,
			valFixed = '';
		if (j < 0)
			for(var len = -j; len-- > 0;)
				valFixed += '0';
		return this._value.substring(0, j) + (this._dot || this._precision ? '.' + valFixed + this._value.substring(j) : '');
	},
	
	$toLocaleString: function() { 
		if (this._value.length == 0) return ''; 
		var j = this._value.length - this._precision;
		if (j <= 0) {
			var valFixed = '';
			for(var len = -j; len-- > 0;)
				valFixed += '0';
			return '0' + (this._precision ? zk.DECIMAL + valFixed + this._value : '');
		}
		return this._value.substring(0, j) + (this._precision ? zk.DECIMAL + this._value.substring(j) : '');
	}
});


zk.Long = zk.$extends(zk.Object, {
	
	$init: function (value) {
	
	
	
		value = value ? '' + value: '0';
		var len = value.length;
		for (var j = 0; j < len; ++j) {
			var cc = value.charAt(j);
			if ((cc < '0' || cc > '9') && (j > 0 || (cc != '-' && cc != '+'))) {
				value = value.substring(0, j);
				break;
			}
		}
		if(len == 1) {
			var c = value.charAt(0);
			if(cc < '0' || cc > '9')
				value = 'NaN';
		}
		this._value = value;
	},
	
	scale: function (digits) {
		var val = this._value||'',
			n = val.length;
		if (n)
			if (digits > 0) {
				if (n > 1 || val.charAt(0) != '0')
					while (digits-- > 0) 
						val += '0';
			} else if (digits < 0)
				this._value = (n += digits) <= 0 ? '0': val.substring(0, n);
	},
	$toNumber: function () {
		return parseFloat(this._value)
	},
	
	$toString: zkf = function() { 
		return this._value;
	},
	
	$toLocaleString: zkf
});


(function () {
	var _decs = {lt: '<', gt: '>', amp: '&', quot: '"'},
		_encs = {};
	for (var v in _decs)
		_encs[_decs[v]] = v;

	function _pathname(url) {
		var j = url.indexOf('//');
		if (j > 0) {
			j = url.indexOf('/', j + 2);
			if (j > 0) return url.substring(j);
		}
	}

	function _frames(ary, w) {
		
		ary.push(w);
		for (var fs = w.frames, j = 0, l = fs.length; j < l; ++j)
			_frames(ary, fs[j]);
	}
	
	function _onSizeTarget(wgt) {
		var r1 = wgt, p1 = r1,
			j1 = -1;
		for (; p1 && p1._hflex == 'min'; p1 = p1.parent) {
			delete p1._hflexsz;
			r1 = p1;
			++j1;
			if (p1.ignoreFlexSize_('w')) 
				break;
		}

		var r2 = wgt, p2 = r2,
			j2 = -1;
		for (; p2 && p2._vflex == 'min'; p2 = p2.parent) {
			delete p2._vflexsz;
			r2 = p2;
			++j2;
			if (p2.ignoreFlexSize_('h')) 
				break;
		}
		return j1 > 0 || j2 > 0 ? j1 > j2 ? r1 : r2: wgt;
	}


zUtl = { 
	
    
	isChar: function (cc, opts) {
		return (opts.digit && cc >= '0' && cc <= '9')
			|| (opts.upper && cc >= 'A' && cc <= 'Z')
			|| (opts.lower && cc >= 'a' && cc <= 'z')
			|| (opts.whitespace && (cc == ' ' || cc == '\t' || cc == '\n' || cc == '\r'))
			|| opts[cc];
	},

	
	
	parseMap: function (text, separator, quote) {
		var map = {};
		if (text) {
			var ps = text.split(separator || ',');
			if (quote) {
				var tmp = [],
					re = new RegExp(quote, 'g'),
					key = '', t, pair;
				while((t = ps.shift()) !== undefined) {
					if ((pair = (key += t).match(re)) && pair.length != 1) {
						if (key)
							tmp.push(key);
						key = '';
					} else
						key += separator;
				}
				ps = tmp;
			}
			for (var len = ps.length; len--;) {
				var key = ps[len].trim(),
					index = key.indexOf('=');
				if (index != -1)
					map[key.substring(0, index)] = key.substring(index + 1, key.length).trim();
			}
		}
		return map;
	},

	
	encodeXML: function (txt, opts) {
		txt = txt != null ? String(txt):'';
		var tl = txt.length,
			pre = opts && opts.pre,
			multiline = pre || (opts && opts.multiline),
			maxlength = opts ? opts.maxlength : 0;

		if (!multiline && maxlength && tl > maxlength) {
			var j = maxlength;
			while (j > 0 && txt.charAt(j - 1) == ' ')
				--j;
			opts.maxlength = 0; 
			return zUtl.encodeXML(txt.substring(0, j) + '...', opts);
		}

		var out = [], k = 0, enc;
		if (multiline || pre)
			for (var j = 0; j < tl; ++j) {
				var cc = txt.charAt(j);
				if (enc = _encs[cc]) {
					out.push(txt.substring(k, j), '&', enc, ';');
					k = j + 1;
				} else if (multiline && cc == '\n') {
					out.push(txt.substring(k, j), '<br/>\n');
					k = j + 1;
				} else if (pre && (cc == ' ' || cc == '\t')) {
					out.push(txt.substring(k, j), '&nbsp;');
					if (cc == '\t')
						out.push('&nbsp;&nbsp;&nbsp;');
					k = j + 1;
				}
			}
		else
			for (var j = 0; j < tl; ++j)
				if (enc = _encs[txt.charAt(j)]) {
					out.push(txt.substring(k, j), '&', enc, ';');
					k = j + 1;
				}

		if (!k) return txt;
		if (k < tl)
			out.push(txt.substring(k));
		return out.join('');
	},
	
	decodeXML: function (txt) {
		var out = '';
		if (!txt) return out;

		var k = 0, tl = txt.length;
		for (var j = 0; j < tl; ++j) {
			var cc = txt.charAt(j);
			if (cc == '&') {
				var l = txt.indexOf(';', j + 1);
				if (l >= 0) {
					var dec = txt.charAt(j + 1) == '#' ?
						String.fromCharCode(txt.charAt(j + 2).toLowerCase() == 'x' ?
							parseInt(txt.substring(j + 3, l), 16):
							parseInt(txt.substring(j + 2, l), 10)):
						_decs[txt.substring(j + 1, l)];
					if (dec) {
						out += txt.substring(k, j) + dec;
						k = (j = l) + 1;
					}
				}
			}
		}
		return !k ? txt:
			k < tl ? out + txt.substring(k): out;
	},

	
 	cellps0: ' cellpadding="0" cellspacing="0" border="0"',
 	
 	img0: '<img style="height:0;width:0"/>',
 	
 	i0: '<i style="height:0;width:0"/>',
 
 	
	now: jq.now,
	
	
	today: function (fmt) {
		var d = new Date(), hr = 0, min = 0, sec = 0, msec = 0;
		if (typeof fmt == 'string') {
			var fmt0 = fmt.toLowerCase();
			if (fmt0.indexOf('h') >= 0 || fmt0.indexOf('k') >= 0) hr = d.getHours();
			if (fmt.indexOf('m') >= 0) min = d.getMinutes();
			if (fmt.indexOf('s') >= 0) sec = d.getSeconds();
			if (fmt.indexOf('S') >= 0) msec = d.getMilliseconds();
		} else if (fmt)
			return d;
		return new Date(d.getFullYear(), d.getMonth(), d.getDate(),
			hr, min, sec, msec);
	},

	
	isAncestor: function (p, c) {
		if (!p) return true;
		for (; c; c = c.getParent ? c.getParent(): c.parent)
			if (p == c)
				return true;
		return false;
	},

	
	
	progressbox: function (id, msg, mask, icon, _opts) {
		if (mask && zk.Page.contained.length) {
			for (var c = zk.Page.contained.length, e = zk.Page.contained[--c]; e; e = zk.Page.contained[--c]) {
				if (!e._applyMask)
					e._applyMask = new zk.eff.Mask({
						id: e.uuid + '-mask',
						message: msg,
						anchor: e.$n()
					});
			}
			return;
		}

		if (_opts && _opts.busy) {
			zk.busy++;
			jq.focusOut(); 
		}

		var x = jq.innerX(), y = jq.innerY(),
			style = ' style="left:'+x+'px;top:'+y+'px"',
			idtxt = id + '-t',
			idmsk = id + '-m',
			html = '<div id="'+id+'"';
		if (mask)
			html += '><div id="' + idmsk + '" class="z-modal-mask"'+style+'></div';
		html += '><div id="'+idtxt+'" class="z-loading"'+style
			+'><div class="z-loading-indicator"><span class="z-loading-icon"></span> '
			+msg+'</div></div>';
		if (icon)
			html += '<div class="' + icon + '"></div>';
		jq(document.body).append(html + '</div>');

		var $n = jq(id, zk),
			n = $n[0],
			$txt = jq(idtxt, zk),
			txt = $txt[0],
			st = txt.style;
		if (mask) {
			
			var zIndex = $txt.css('z-index');
			if (zIndex == 'auto')
				zIndex = 1;
			n.z_mask = new zk.eff.FullMask({
				mask: jq(idmsk, zk)[0],
				zIndex: zIndex - 1
			});
		}

		if (mask && $txt.length) { 
			st.left = jq.px((jq.innerWidth() - txt.offsetWidth) / 2 + x);
			st.top = jq.px((jq.innerHeight() - txt.offsetHeight) / 2 + y);
		} else {
			var pos = zk.progPos;
			if (pos) {
				var left,
					top,
					width = jq.innerWidth(),
					height = jq.innerHeight(),
					wdgap = width - zk(txt).offsetWidth(),
					hghgap = height - zk(txt).offsetHeight();

				if (pos.indexOf('mouse') >= 0) {
					var offset = zk.currentPointer;
					left = offset[0] + 10;
					top = offset[1] + 10;
				} else {
					if (pos.indexOf('left') >= 0) left = x;
					else if (pos.indexOf('right') >= 0)	left = x + wdgap -1;
					else if (pos.indexOf('center') >= 0) left = x + wdgap / 2;
					else left = 0;
					
					if (pos.indexOf('top') >= 0) top = y;
					else if (pos.indexOf('bottom') >= 0) top = y + hghgap - 1;
					else if (pos.indexOf('center') >= 0) top = y + hghgap / 2;
					else top = 0;
					
					left = left < x ? x : left;
					top = top < y ? y : top;
				}
				st.left = jq.px(left);
				st.top = jq.px(top);
			}
		}

		$n.zk.cleanVisibility();
	},
	
	destroyProgressbox: function (id, _opts) {
		if (_opts && _opts.busy && --zk.busy < 0)
			zk.busy = 0;
		var $n = jq(id, zk), n;
		if ($n.length) {
			if (n = $n[0].z_mask) n.destroy();
			$n.remove();
		}

		for (var c = zk.Page.contained.length, e = zk.Page.contained[--c]; e; e = zk.Page.contained[--c])
			if (e._applyMask) {
				e._applyMask.destroy();
				e._applyMask = null;
			}
	},

	
	
	go: function (url, opts) {
		opts = opts || {};
		if (opts.target) {
			open(url, opts.target);
		} else if (opts.overwrite) {
			location.replace(url ? url: location.href);
		} else {
			if (url) {
				location.href = url;

				var j = url.indexOf('#');
				
				if(j < 0)
					return;
				
				var	un = j >= 0 ? url.substring(0, j): url,
					pn = _pathname(location.href);
				
				j = pn.indexOf('#');
				if (j >= 0) pn = pn.substring(0, j);
				if (pn != un)
					return;
				
			}
			location.reload();
		}
	},

	
	frames: function (w) {
		var ary = [];
		_frames(ary, w);
		return ary;
	},

	
	intsToString: function (ary) {
		if (!ary) return '';

		var sb = [];
		for (var j = 0, k = ary.length; j < k; ++j)
			sb.push(ary[j]);
		return sb.join();
	},
	
	stringToInts: function (text, defaultValue) {
		if (text == null)
			return null;

		var list = [];
		for (var j = 0;;) {
			var k = text.indexOf(',', j),
				s = (k >= 0 ? text.substring(j, k): text.substring(j)).trim();
			if (s.length == 0) {
				if (k < 0) break;
				list.push(defaultValue);
			} else
				list.push(zk.parseInt(s));

			if (k < 0) break;
			j = k + 1;
		}
		return list;
	},
	
	mapToString: function (map, assign, separator) {
		assign = assign || '=';
		separator = separator || ' ';
		var out = [];
		for (var v in map)
			out.push(separator, v, assign, map[v]);
		out[0] = '';
		return out.join('');
	},
	
	
	appendAttr: function (nm, val, force)  {
		return val || force ? ' ' + nm + '="' + val + '"': '';
	},
	
	fireSized: function (wgt, bfsz) {
		
		if (wgt.desktop) {
			if (zUtl.isImageLoading() || zk.clientinfo) {
				var f = arguments.callee;
				setTimeout(function () {
					return f(wgt, bfsz);
				}, 20);
				return;
			}
			wgt = _onSizeTarget(wgt);
			if (!(bfsz < 0)) 
				zWatch.fireDown('beforeSize', wgt, null, bfsz > 0);
			zWatch.fireDown('onFitSize', wgt, {reverse: true});
			zWatch.fireDown('onSize', wgt);
		}
	},
	
	fireShown: function (wgt, bfsz) {
		zWatch.fireDown('onShow', wgt);
		zUtl.fireSized(wgt, bfsz);
	},
	
	loadImage: function (url) {
		if (!_imgMap[url]) {
			_imgMap[url] = true;
			_loadImage(url);
		}
	},
	
	isImageLoading: function () {
		for (var n in _imgMap)
			return true;
		return false;
	}
};

var _imgMap = {};
function _loadImage(url) {
	var img = new Image(),
		f = function () {
			delete _imgMap[url];
		};
	img.onerror = img.onload = f;
	img.src = url;
}
})();


(function (undefined) {
	var _binds = {}, 
		_globals = {}, 
		_floatings = [], 
		_nextUuid = 0,
		_domevtfnm = {}, 
		_domevtnm = {onDoubleClick: 'dblclick'}, 
		_wgtcls = {}, 
		_hidden = [], 
		_noChildCallback, _noParentCallback, 
		_syncdt, 
		_rdque = [], _rdtid, 
		_ignCanActivate, 
		REGEX_DQUOT = /\"/g; 

	
	function _isProlog(el) {
		var txt;
		return el && el.nodeType == 3 
			&& (txt=el.nodeValue) && !txt.trim().length;
	}

	
	function _domEvtInf(wgt, evtnm, fn, keyword) { 
		if (typeof fn != 'function') {
			if (!fn && !(fn = _domevtfnm[evtnm]))
				_domevtfnm[evtnm] = fn = '_do' + evtnm.substring(2);

			var f = wgt[fn];
			if (!f)
				throw 'Listener ' + fn + ' not found in ' + wgt.className;
			fn = f;
		}

		var domn = _domevtnm[evtnm];
		if (!domn)
			domn = _domevtnm[evtnm] = evtnm.substring(2).toLowerCase();
		return [domn, _domEvtProxy(wgt, fn, evtnm, keyword)];
	}
	function _domEvtProxy(wgt, f, evtnm, keyword) {
		var fps = wgt._$evproxs, fp;
		if (!fps) wgt._$evproxs = fps = {};
		if (keyword)
			f.__keyword = keyword;
		else if (fp = fps[f]) return fp;
		return fps[f] = _domEvtProxy0(wgt, f, keyword);
	}
	function _domEvtProxy0(wgt, f, keyword) {
		return function (evt) {
			var devt = evt; 
			evt = jq.Event.zk(devt, wgt); 

			switch (devt.type){
			case 'focus':
				if (wgt.canActivate()) {
					zk.currentFocus = wgt;
					
					zWatch.fire('onFloatUp', wgt, {triggerByFocus: true}); 
					break;
				}
				return; 
			case 'blur':
				
				
				if (!zk._cfByMD) zk.currentFocus = null;
				break;
			case 'click':
			case 'dblclick':
			case 'mouseup': 
				if (zk.Draggable.ignoreClick())
					return;
			}
			
			
			var args;
			if (keyword) {
				args = [].slice.call(arguments);
				args.push(keyword);
			} else
				args = arguments;
			var ret = f.apply(wgt, args);
			if (ret === undefined) ret = evt.returnValue;
			if (evt.domStopped) devt.stop();
			if (evt.stopped) devt.originalEvent['zkstopped'] = true;
			return devt.type == 'dblclick' && ret === undefined ? false: ret;
		};
	}

	function _unlink(wgt, child) {
		var p = child.previousSibling, n = child.nextSibling;
		if (p) p.nextSibling = n;
		else wgt.firstChild = n;
		if (n) n.previousSibling = p;
		else wgt.lastChild = p;
		child.nextSibling = child.previousSibling = child.parent = null;

		--wgt.nChildren;
	}
	
	function _replaceLink(from, to) {
		var p = to.parent = from.parent,
			q = to.previousSibling = from.previousSibling;
		if (q) q.nextSibling = to;
		else if (p) p.firstChild = to;

		q = to.nextSibling = from.nextSibling;
		if (q) q.previousSibling = to;
		else if (p) p.lastChild = to;
	}

	function _bind0(wgt) { 
		_binds[wgt.uuid] = wgt;
		if (wgt.id)
			_addGlobal(wgt);
	}
	function _unbind0(wgt) {
		if (wgt.id)
			_rmGlobal(wgt);
		delete _binds[wgt.uuid];
		wgt.desktop = null;
		wgt.clearCache();
	}
	function _bindrod(wgt) {
		_bind0(wgt);
		if (!wgt.z_rod)
			wgt.z_rod = 9; 

		for (var child = wgt.firstChild; child; child = child.nextSibling)
			_bindrod(child);
	}
	function _unbindrod(wgt, nest) {
		_unbind0(wgt);

		if (!nest || wgt.z_rod === 9) { 
			delete wgt.z_rod;

			for (var child = wgt.firstChild; child; child = child.nextSibling) {
				_unbindrod(child, true);
				
				if (child.$instanceof(zk.Native))
					zAu._storeStub(child);
			}
		}
	}

	function _fixBindLevel(wgt, v) {
		wgt.bindLevel = v++;
		for (wgt = wgt.firstChild; wgt; wgt = wgt.nextSibling)
			_fixBindLevel(wgt, v);
	}

	function _addIdSpace(wgt) {
		if (wgt._fellows) wgt._fellows[wgt.id] = wgt;
		var p = wgt.parent;
		if (p) {
			p = p.$o();
			if (p) p._fellows[wgt.id] = wgt;
		}
	}
	function _rmIdSpace(wgt) {
		if (wgt._fellows) delete wgt._fellows[wgt.id];
		var p = wgt.parent;
		if (p) {
			p = p.$o();
			if (p) delete p._fellows[wgt.id];
		}
	}
	function _addIdSpaceDown(wgt) {
		var ow = wgt.parent;
		ow = ow ? ow.$o(): null;
		if (ow)
			_addIdSpaceDown0(wgt, ow);
	}
	function _addIdSpaceDown0(wgt, owner) {
		if (wgt.id) owner._fellows[wgt.id] = wgt;
		if (!wgt._fellows)
			for (wgt = wgt.firstChild; wgt; wgt = wgt.nextSibling)
				_addIdSpaceDown0(wgt, owner);
	}
	function _rmIdSpaceDown(wgt) {
		var ow = wgt.parent;
		ow = ow ? ow.$o(): null;
		if (ow)
			_rmIdSpaceDown0(wgt, ow);
	}
	function _rmIdSpaceDown0(wgt, owner) {
		if (wgt.id)
			delete owner._fellows[wgt.id];
		if (!wgt._fellows)
			for (wgt = wgt.firstChild; wgt; wgt = wgt.nextSibling)
				_rmIdSpaceDown0(wgt, owner);
	}
	
	function _addGlobal(wgt) {
		var gs = _globals[wgt.id];
		if (gs)
			gs.push(wgt);
		else
			_globals[wgt.id] = [wgt];
	}
	function _rmGlobal(wgt) {
		var gs = _globals[wgt.id];
		if (gs) {
			gs.$remove(wgt);
			if (!gs.length) delete _globals[wgt.id];
		}
	}

	
	function _exists(wgt) {
		if (document.getElementById(wgt.uuid)) 
			return true;

		for (wgt = wgt.firstChild; wgt; wgt = wgt.nextSibling)
			if (_exists(wgt))
				return  true;
	}

	function _fireClick(wgt, evt) {
		if (!wgt.shallIgnoreClick_(evt) && 
			!wgt.fireX(evt).stopped && evt.shallStop) {
			evt.stop();
			return false;	
		}
		return !evt.stopped;
	}

	function _rmDom(wgt, n) {
		
		
		
		var act;
		if (wgt._visible && (act = wgt.actions_['hide'])) {
			wgt._rmAftAnm = function () {
				jq(n).remove();
			};
			n.style.visibility = ""; 
			act[0].call(wgt, n, act[1]);
		} else
			jq(n).remove();
	}

	
	
	function _dragCtl(wgt, invoke) {
		var p;
		return wgt && (p = wgt.parent) && p.dragControl && (!invoke || p.dragControl(wgt));
	}

	
	function _bkFocus(wgt) {
		var cf = zk.currentFocus;
		if (cf && zUtl.isAncestor(wgt, cf)) {
			zk.currentFocus = null;
			return {focus: cf, range: _bkRange(cf)};
		}
	}
	function _bkRange(wgt) {
		if (zk.ie < 11 && zk.cfrg) { 
			var cfrg = zk.cfrg;
			delete zk.cfrg;
			return cfrg;
		}
		return wgt.getInputNode && (wgt = wgt.getInputNode())
			&& zk(wgt).getSelectionRange();
	}
	
	function _rsFocus(cfi) {
		var cf;
		if (cfi && (cf = cfi.focus) && cf.desktop && !zk.currentFocus) {
			_ignCanActivate = true;
				
			try {
				cf.focus();
				
				if (cfi.range && cf.getInputNode && (cf = cf.getInputNode()) && zk(cf).isRealVisible())
					zk(cf).setSelectionRange(cfi.range[0], cfi.range[1]);
			} finally {
				_ignCanActivate = false;
			}
		}
	}
	
	function _listenFlex(wgt) {
		if (!wgt._flexListened){
			zWatch.listen({onSize: [wgt, zFlex.onSize], beforeSize: [wgt, zFlex.beforeSize]});
			if (wgt._hflex == 'min' || wgt._vflex == 'min')
				wgt.listenOnFitSize_();
			else
				wgt.unlistenOnFitSize_();
			wgt._flexListened = true;
		}
	}
	function _unlistenFlex(wgt) {
		if (wgt._flexListened) {
			zWatch.unlisten({onSize: [wgt, zFlex.onSize], beforeSize: [wgt, zFlex.beforeSize]});
			wgt.unlistenOnFitSize_();
			delete wgt._flexListened;
		}
	}
	
	
	zk.DnD = { 
		
		getDrop: function (drag, pt, evt) {
			var wgt = evt.target;
			return wgt ? wgt.getDrop_(drag.control): null;
		},
		
		ghost: function (drag, ofs, msg) {
			if (msg != null)  {
				jq(document.body).append(
					'<div id="zk_ddghost" class="z-drop-ghost z-drop-disallow" style="position:absolute;top:'
					+ofs[1]+'px;left:'+ofs[0]+'px;"><div class="z-drop-content"><span id="zk_ddghost-img" class="z-drop-icon"></span>&nbsp;'+msg+'</div></div>');
				drag._dragImg = jq('#zk_ddghost-img')[0];
				return jq('#zk_ddghost')[0];
			}

			var dgelm = jq(drag.node).clone()[0];
			dgelm.id = 'zk_ddghost';
			zk.copy(dgelm.style, {
				position: "absolute", left: ofs[0] + 'px', top: ofs[1] + 'px'
			});
			jq(dgelm).addClass('z-drag-ghost');
			document.body.appendChild(dgelm);
			return dgelm;
		}
	};
	function DD_cleanLastDrop(drag) {
		if (drag) {
			var drop;
			if (drop = drag._lastDrop) {
				drag._lastDrop = null;
				drop.dropEffect_();
			}
			drag._lastDropTo = null;
		}
	}
	function DD_pointer(evt, height) {
		if (zk.ios)
			return [evt.pageX - 50, evt.pageY - height - 30];
		return [evt.pageX + 7, evt.pageY + 5];
	}
	function DD_enddrag(drag, evt) {
		DD_cleanLastDrop(drag);
		var pt = [evt.pageX, evt.pageY],
			wgt = zk.DnD.getDrop(drag, pt, evt);
		if (wgt) wgt.onDrop_(drag, evt);
	}
	function DD_dragging(drag, pt, evt) {
		var dropTo;
		if (!evt || (dropTo = evt.domTarget) == drag._lastDropTo)
			return;

		var dropw = zk.DnD.getDrop(drag, pt, evt),
			found = dropw && dropw == drag._lastDrop;
		if (!found) {
			DD_cleanLastDrop(drag); 
			if (dropw) {
				drag._lastDrop = dropw;
				dropw.dropEffect_(true);
				found = true;
			}
		}

		var dragImg = drag._dragImg;
		if (dragImg) {
			if (found) {
				jq(drag.node).removeClass('z-drop-disallow').addClass('z-drop-allow');
				
				jq(dragImg).removeClass('z-icon-times').addClass('z-icon-check');
			} else {
				jq(drag.node).removeClass('z-drop-allow').addClass('z-drop-disallow');
				
				jq(dragImg).removeClass('z-icon-check').addClass('z-icon-times');
			}
		}

		drag._lastDropTo = dropTo; 
		
		if (zk.mobile)
			zk(drag.node).redoCSS();
	}
	function DD_ghosting(drag, ofs, evt) {
		return drag.control.cloneDrag_(drag, DD_pointer(evt, jq(drag.node).height()));
	}
	function DD_endghosting(drag, origin) {
		drag.control.uncloneDrag_(drag);
		drag._dragImg = null;
	}
	function DD_constraint(drag, pt, evt) {
		return DD_pointer(evt, jq(drag.node).height());
	}
	function DD_ignoredrag(drag, pt, evt) {
		
		
		return drag.control.ignoreDrag_(pt,evt,drag); 
	}

	function _topnode(n) {
		for (var v, body = document.body; n && n != body; n = n.parentNode) 
			if ((v=n.style) && ((v=v.position) == 'absolute' || v == 'relative'))
				return n;
	}
	function _zIndex(n) {
		return n ? zk.parseInt(n.style.zIndex): 0;
	}

	function _getFirstNodeDown(wgt) {
		var n = wgt.$n();
		if (n) return n;
		for (var w = wgt.firstChild; w; w = w.nextSibling) {
			n = w.getFirstNode_();
			if (n) return n;
		}
	}
	
	function _floatVisibleDependent(self, wgt) {
		for (; wgt; wgt = wgt.parent)
			if (wgt == self) return true;
			else if (!wgt.isVisible()) break;
		return false;
	}
	
	function _fullScreenZIndex(zi) {
		var pseudoFullscreen = null;
		if (document.fullscreenElement) {
			pseudoFullscreen = ':fullscreen';
		} else if (document.mozFullScreen) {
			
			
			
			return 2147483648;
		} else if (document.webkitIsFullScreen) {
			pseudoFullscreen = ':-webkit-full-screen';
		}
		if (pseudoFullscreen) {
			var fsZI = jq.css(jq(pseudoFullscreen)[0], 'zIndex');
			return fsZI == 'auto' ? 2147483648 : ++fsZI;
		}
		return zi;
	}

	
	function _topZIndex(wgt) {
		var zi = 1800; 
		
		
		
		zi = _fullScreenZIndex(zi);
		
		
		for (var j = _floatings.length; j--;) {
			var w = _floatings[j].widget,
				wzi = zk.parseInt(w.getFloatZIndex_(_floatings[j].node));
			if (wzi >= zi && !zUtl.isAncestor(wgt, w) && w.isVisible())
				zi = wzi + 1;
		}
		return zi;
	}

	function _prepareRemove(wgt, ary) {
		for (wgt = wgt.firstChild; wgt; wgt = wgt.nextSibling) {
			var n = wgt.$n();
			if (n) ary.push(n);
			else _prepareRemove(wgt, ary);
		}
	}

	
	function _doDeferRender(wgt) {
		if (wgt._z$rd) { 
			delete wgt._z$rd;
			wgt._norenderdefer = true;
			wgt.replaceHTML('#' + wgt.uuid, wgt.parent ? wgt.parent.desktop: null, null, true);
			if (wgt.parent)
				wgt.parent.onChildRenderDefer_(wgt);
		}
	}

	
	function _rerender(wgt, timeout) {
		if (_rdtid)
			clearTimeout(_rdtid);
		_rdque.push(wgt);
		_rdtid = setTimeout(_rerender0, timeout);
	}
	function _rerender0() {
		_rdtid = null;
		l_out:
		for (var wgt; wgt = _rdque.shift();) {
			if (!wgt.desktop)
				continue;

			for (var j = _rdque.length; j--;)
				if (zUtl.isAncestor(wgt, _rdque[j]))
					_rdque.splice(j, 1); 
				else if (zUtl.isAncestor(_rdque[j], wgt))
					continue l_out; 

			wgt.rerender(-1);
		}
	}
	
	function _rerenderNow(wgt, skipper) {
		var rdque = [];
		for (var j = _rdque.length; j--;)
			if (zUtl.isAncestor(wgt, _rdque[j])) {
				if (!skipper || !skipper.skipped(wgt, _rdque[j]))
					rdque = rdque.concat(_rdque.splice(j, 1));
			}
		
		
		if (!_rdque.length && _rdtid) {
			clearTimeout(_rdtid);
			_rdtid = null; 
		}
		
		l_out2:
			for (var w; w = rdque.shift();) {
				if (!w.desktop)
					continue;

				for (var j = rdque.length; j--;)
					if (zUtl.isAncestor(w, rdque[j]))
						rdque.splice(j, 1); 
					else if (zUtl.isAncestor(rdque[j], w))
						continue l_out2; 

				w.rerender(-1);
			}
	}
	function _rerenderDone(wgt, skipper ) {
		for (var j = _rdque.length; j--;)
			if (zUtl.isAncestor(wgt, _rdque[j])) {
				if (!skipper || !skipper.skipped(wgt, _rdque[j]))
					_rdque.splice(j, 1);
			}
	}

	function _markCache(cache, visited, visible) {
		if (cache)
			for (var p; p = visited.pop();)
				cache[p.uuid] = visible;
		return visible;
	}
	var _dragoptions = {
		starteffect: zk.$void, 
		endeffect: DD_enddrag, change: DD_dragging,
		ghosting: DD_ghosting, endghosting: DD_endghosting,
		constraint: DD_constraint, 
		ignoredrag: DD_ignoredrag,
		zIndex: 88800
	};

var Widget =

zk.Widget = zk.$extends(zk.Object, {
	_visible: true,
	
	nChildren: 0,
	
	bindLevel: -1,
	_mold: 'default',
	
	className: 'zk.Widget',
	
	widgetName: 'widget',
	
	

	
	
	actions_: {}, 

	_floating: false,

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	

	
	

	
	$init: function (props) {
		this._asaps = {}; 
		this._lsns = {}; 
		this._bklsns = {}; 
		this._subnodes = {}; 
		this.effects_ = {};
		this._subzcls = {}; 

		
		
		
		if (this.z$is)
			this._fellows = {};

		
		if (props !== zkac)
			this.afterInit(function () {
				
				if (props && typeof props == 'object' && !props.$oid)
					for (var nm in props)
						this.set(nm, props[nm]);

				if ((zk.spaceless || this.rawId) && this.id)
					this.uuid = this.id; 
				if (!this.uuid)
					this.uuid = Widget.nextUuid();
			});
	},

	$define: {
		
		
		mold: function () {
			this.rerender();
		},
		
		
		style: function () {
			this.updateDomStyle_();
		},
		
		
		sclass: function () {
			this.updateDomClass_();
		},
		
		
		zclass: function () {
			this._subzcls = {}; 
			this.rerender();
		},
		
		
		width: function (v) {
			if (!this._nhflex) {
				var n = this.$n();
				if (n) n.style.width = v || '';
			}
		},
		
		
		height: function (v) {
			if (!this._nvflex) {
				var n = this.$n();
				if (n) n.style.height = v || '';
			}
		},
		
		
		left: function (v) {
			var n = this.$n();
			if (n) n.style.left = v || '';
		},
		
		
		top: function (v) {
			var n = this.$n();
			if (n) n.style.top = v || '';
		},
		
		
		tooltiptext: function (v) {
			var n = this.$n();
			
			if (n) n.title = v || '';
		},

		
		
		droppable: [
			function (v) {
				return v && 'false' != v ? v: null;
			},
			function (v) {
				var dropTypes;
				if (v && v != 'true') {
					dropTypes = v.split(',');
					for (var j = dropTypes.length; j--;)
						if (!(dropTypes[j] = dropTypes[j].trim()))
							dropTypes.splice(j, 1);
				}
				this._dropTypes = dropTypes;
			}
		],
		
		
		vflex: function(v) {
			this._nvflex = (true === v || 'true' == v) ? 1 : v == 'min' ? -65500 : zk.parseInt(v);
			if (this._nvflex < 0 && v != 'min')
				this._nvflex = 0;
			if (this.desktop) { 
				if (!this._nvflex) {
					this.setFlexSize_({height: 'auto'}); 
					delete this._vflexsz;
					if (!this._nhflex)
						_unlistenFlex(this);
				} else
					_listenFlex(this);

				var p;
				if ((p = this.parent) && !p.isBinding()) 
					zUtl.fireSized(p, -1); 
			}
		},
		
		
		hflex: function(v) {
			this.setHflex_(v);

			var p;
			if (this.desktop
			&& (p = this.parent) && !p.isBinding())
				zUtl.fireSized(p, -1); 
		},
		
		
		 renderdefer: null,
		
		
		action: function (v) {
			this.actions_ = {}; 
			if (v)
				for (var ps = v.split(';'), j = ps.length; j--;) {
					var p = ps[j], k = p.indexOf(':');
					if (k >= 0) {
						var nm = p.substring(0, k).trim(),
							val = p.substring(k + 1).trim(),
							opts, fn, l;
						if (nm && val) {
							k = val.indexOf('(');
							if (k >= 0) {
								if ((l = val.lastIndexOf(')')) > k)
									opts = jq.evalJSON(val.substring(k + 1, l));
								val = val.substring(0, k);
							}
							if (fn = zk.eff.Actions[val])
								this.actions_[nm] = [fn, opts];
							else
								zk.error('Unknown action: '+val);
							continue;
						}
					}
					zk.error('Illegal action: '+v+', '+this.className);
				}
		}
	},
	setHflex_: function (v) {
		this._nhflex = (true === v || 'true' == v) ? 1 : v == 'min' ? -65500 : zk.parseInt(v);
		if (this._nhflex < 0 && v != 'min')
			this._nhflex = 0;
		if (this.desktop) { 
		                    
		                    
		                    
			if (!this._nhflex) {
				this.setFlexSize_({width: 'auto'}); 
				delete this._hflexsz;
				if (!this._nvflex)
					_unlistenFlex(this);
			} else
				_listenFlex(this);
		}
	},
	
	afterAnima_: function (visible) {
		var fn;
		if (fn = this._rmAftAnm) {
			this._rmAftAnm = null;
			fn();
		}
	},

	
	setDraggable: function (v) {
		if (!v && v != null) v = 'false'; 
		this._draggable = v;

		if (this.desktop && !_dragCtl(this, true))
			if (v && v != 'false') this.initDrag_();
			else this.cleanDrag_();
	},
	
	getDraggable: function () {
		var v = this._draggable;
		return v ? v: _dragCtl(this) ? 'true': 'false';
	},
	
	$o: function () {
		for (var w = this; w; w = w.parent)
			if (w._fellows) return w;
	},
	
	
	
	$f: function (id, global) {
		var f = this.$o();
		if (!arguments.length)
			return f ? f._fellows: {};
		for (var ids = id.split('/'), j = 0, len = ids.length; j < len; ++j) {
			id = ids[j];
			if (id) {
				if (f) f = f._fellows[id];
				if (!f && global && (f=_globals[id])) f = f[0];
				if (!f || zk.spaceless) break;
				global = false;
			}
		}
		return f;
	},
	
	getId: function () {
		return this.id;
	},
	
	setId: function (id) {
		if (id != this.id) {
			if (this.id) {
				_rmIdSpace(this);
				_rmGlobal(this); 
			}

			if (id && (zk.spaceless || this.rawId))
				zk._wgtutl.setUuid(this, id);
			this.id = id;

			if (id) {
				_addIdSpace(this);
				if (this.desktop || this.z_rod)
					_addGlobal(this);
			}
		}
		return this;
	},

	
	
	set: function (name, value, extra) {
		var cc;
		if ((cc = value && value.$u) 
		&& !(value = Widget.$(cc))) { 
			var self = this;
			zk.afterMount(function () {
				var v = Widget.$(cc);
				
				if (v)
					zk._set(self, name, v, extra);
				else
					setTimeout(function () {
						zk._set(self, name, Widget.$(cc), extra);
					});
			}, -1);
			return this;
		}

		if (cc = this['set' + name.charAt(0).toUpperCase() + name.substring(1)]) {
		
			zk._set2(this, cc, null, value, extra);
			return this;
		}

		if ((cc = name.charAt(0)) == '$') {
			if (name.startsWith('$$on')) {
				var cls = this.$class,
					ime = cls._importantEvts;
				(ime || (cls._importantEvts = {}))[name.substring(2)] = value;
				return this;
			} else if (name.startsWith('$$0on')) {
				var cls = this.$class,
					ime = cls._duplicateIgnoreEvts;
				(ime || (cls._duplicateIgnoreEvts = {}))[name.substring(3)] = value;
				return this;
			} else if (name.startsWith('$$1on')) {
				var cls = this.$class,
					ime = cls._repeatIgnoreEvts;
				(ime || (cls._repeatIgnoreEvts = {}))[name.substring(3)] = value;
				return this;
			} else if (name.startsWith('$on')) {
				this._asaps[name.substring(1)] = value;
				return this;
			}
		} else if (cc == 'o' && name.charAt(1) == 'n'
			&& ((cc = name.charAt(2)) <= 'Z' && cc >= 'A')) {
			this.setListener(name, value);
			return this;
		}

		zk._set2(this, null, name, value, extra);
		return this;
	},
	
	get: function (name) {
		return zk.get(this, name);
	},
	
	getChildAt: function (j) {
		if (j >= 0 && j < this.nChildren)
			for (var w = this.firstChild; w; w = w.nextSibling)
				if (--j < 0)
					return w;
	},
	
	getChildIndex: function () {
		var w = this.parent, j = 0;
		if (w)
			for (w = w.firstChild; w; w = w.nextSibling, ++j)
				if (w == this)
					return j;
		return 0;
	},
	
	setChildren: function (children) {
		if (children)
			for (var j = 0, l = children.length; j < l;)
				this.appendChild(children[j++]);
		return this;
	},
	
	
	appendChild: function (child, ignoreDom) {
		if (child == this.lastChild)
			return false;

		var oldpt;
		if ((oldpt = child.parent) != this)
			child.beforeParentChanged_(this);

		if (oldpt) {
			_noParentCallback = true;
			try {
				oldpt.removeChild(child);
			} finally {
				_noParentCallback = false;
			}
		}

		child.parent = this;
		var ref = this.lastChild;
		if (ref) {
			ref.nextSibling = child;
			child.previousSibling = ref;
			this.lastChild = child;
		} else {
			this.firstChild = this.lastChild = child;
		}
		++this.nChildren;

		if (child.id || child.firstChild) 
			_addIdSpaceDown(child);

		if (!ignoreDom)
			if (this.shallChildROD_(child))
				_bindrod(child);
			else {
				var dt = this.desktop;
				if (dt) this.insertChildHTML_(child, null, dt);
			}

		child.afterParentChanged_(oldpt);
		if (!_noChildCallback)
			this.onChildAdded_(child);
		return true;
	},
	
	shallChildROD_: function (child) {
		return child.z_rod || this.z_rod;
	},
	
	insertBefore: function (child, sibling, ignoreDom) {
		if (!sibling || sibling.parent != this) {
			this.insertingBefore_ = true;
			try {
				return this.appendChild(child, ignoreDom);
			} finally {
				this.insertingBefore_ = false;
			}
		}

		if (child == sibling || child.nextSibling == sibling)
			return false;

		var oldpt;
		if ((oldpt = child.parent) != this)
			child.beforeParentChanged_(this);

		if (oldpt) {
			_noParentCallback = true;
			try {
				oldpt.removeChild(child);
			} finally {
				_noParentCallback = false;
			}
		}

		child.parent = this;
		var ref = sibling.previousSibling;
		if (ref) {
			child.previousSibling = ref;
			ref.nextSibling = child;
		} else this.firstChild = child;

		sibling.previousSibling = child;
		child.nextSibling = sibling;

		++this.nChildren;

		_addIdSpaceDown(child);

		if (!ignoreDom)
			if (this.shallChildROD_(child))
				_bindrod(child);
			else {
				var dt = this.desktop;
				if (dt) this.insertChildHTML_(child, sibling, dt);
			}

		child.afterParentChanged_(oldpt);
		if (!_noChildCallback)
			this.onChildAdded_(child);
		return true;
	},
	
	
	removeChild: function (child, ignoreDom) {
		var oldpt;
		if (!(oldpt = child.parent))
			return false;
		if (this != oldpt)
			return false;

		_rmIdSpaceDown(child);

		
		if (child.z_rod) {
			_unbindrod(child);
			
			
			jq(child.uuid, zk).remove();
		} else if (child.desktop) 
			this.removeChildHTML_(child, ignoreDom);

		if (!_noParentCallback)
			child.beforeParentChanged_(null);

		_unlink(this, child);


		if (!_noParentCallback)
			child.afterParentChanged_(oldpt);
		if (!_noChildCallback)
			this.onChildRemoved_(child);
		return true;
	},
	
	detach: function () {
		if (this.parent) this.parent.removeChild(this);
		else {
			var cf = zk.currentFocus;
			if (cf && zUtl.isAncestor(this, cf))
				zk.currentFocus = null;
			var n = this.$n();
			if (n) {
				this.unbind();
				_rmDom(this, n);
			}
		}
	},
	
	clear: function () {
		while (this.lastChild)
			this.removeChild(this.lastChild);
	},
	
	replaceWidget: function (newwgt) {
		_replaceLink(this, newwgt);

		_rmIdSpaceDown(this);
		_addIdSpaceDown(newwgt);

		var cf = zk.currentFocus, cfid, cfrg;
		if (cf && zUtl.isAncestor(this, cf)) {
			cfid = cf.uuid;
			cfrg = _bkRange(cf);
			zk.currentFocus = null;
		}

		var node = this.$n(),
			p = this.parent, shallReplace,
			dt = newwgt.desktop || this.desktop;
		if (this.z_rod) {
			_unbindrod(this);
			if (!(shallReplace = (dt = dt || (p ? p.desktop: p))
			&& (node = jq('#' + this.uuid))))
				_bindrod(newwgt);
		} else
			shallReplace = dt;

		var callback = [];
		if (shallReplace) {
			if (node) newwgt.replaceHTML(node, dt, null, true, callback);
			else {
				this.unbind();
				newwgt.bind(dt);
			}

			_fixBindLevel(newwgt, p ? p.bindLevel + 1: 0);
			zWatch.fire('onBindLevelMove', newwgt);
		}

		if (p)
			p.onChildReplaced_(this, newwgt);

		this.parent = this.nextSibling = this.previousSibling = null;
		
		
		
		if (callback && callback.length) {
			var f;
			while ((f = callback.shift()) && jq.isFunction(f))
				f();
		}
		if (cfid) {
			cf = zk.Widget.$(cfid);
			if (!cf)
				_rsFocus({focus: newwgt, range: cfrg}); 
			else if (zUtl.isAncestor(newwgt, cf))
				_rsFocus({focus: cf, range: cfrg});
		}
	},
	
	replaceCavedChildren_: function (subId, wgts, tagBeg, tagEnd) {
		_noChildCallback = true; 
		try {
			
			var cave = this.$n(subId), fc, oldwgts = [];
			for (var w = this.firstChild; w;) {
				var sib = w.nextSibling;
				if (jq.isAncestor(cave, w.$n())) {
					if (!fc || fc == w) fc = sib;
					this.removeChild(w, true); 
					oldwgts.push(w);
				}
				w = sib;
			}

			
			for (var j = 0, len = wgts.length; j < len; ++j)
				this.insertBefore(wgts[j], fc, true); 
		} finally {
			_noChildCallback = false;
		}

		if (fc = this.desktop) {
			
			var out = [];
			if (tagBeg) out.push(tagBeg);
			for (var j = 0, len = wgts.length; j < len; ++j)
				wgts[j].redraw(out);
			if (tagEnd) out.push(tagEnd);

			
			jq(cave).html(out.join(''));

			
			for (var j = 0, len = wgts.length; j < len; ++j) {
				wgts[j].bind(fc);
				
				
				var n = this._nrows;  
				this.onChildReplaced_(oldwgts[j], wgts[j]);
				this._nrows = n;
			}
		}
	},

	
	beforeParentChanged_: function () {
	},
	
	afterParentChanged_: function () {
	},

	
	
	isRealVisible: function (opts) {
		var dom = opts && opts.dom,
			cache = opts && opts.cache, visited = [], ck,
			wgt = this;
		
		
		if (!wgt.desktop)
			return false;
		
		while (wgt) {
			if (cache && (ck=wgt.uuid) && (ck=cache[ck]) !== undefined)
				return _markCache(cache, visited, ck);

			if (cache)
				visited.push(wgt);
	
			if (dom && !wgt.z_virnd) { 
			
			
			
				if (!zk(wgt.$n()).isVisible(opts.strict))
					return _markCache(cache, visited, false);
			} else if (!wgt._visible) 
				return _markCache(cache, visited, false);

			
			var wp = wgt.parent, p, n;
			if (wp && wp._visible && (p=wp.$n()) && (n=wgt.$n()))
				while ((n=zk(n).vparentNode(true)) && p != n)
					if ((n.style||{}).display == 'none') 
						return _markCache(cache, visited, false);

			if (opts && opts.until == wgt)
				break;

			wgt = wp;
		}
		return _markCache(cache, visited, true);
	},
	
	
	isVisible: function (strict) {
		var visible = this._visible;
		if (!strict || !visible)
			return visible;
		var n = this.$n();
		return n && zk(n).isVisible(); 
	},
	
	setVisible: function (visible) {
		if (this._visible != visible) {
			this._visible = visible;

			var p = this.parent, ocvCalled;
			if (this.desktop) {
				var parentVisible = !p || p.isRealVisible(),
					node = this.$n(),
					floating = this._floating;

				if (!parentVisible) {
					if (!floating) this.setDomVisible_(node, visible);
				} else if (visible) {
					var zi;
					if (floating)
						this.setZIndex(zi = _topZIndex(this), {fire:true});

					this.setDomVisible_(node, true);

					
					for (var j = 0, fl = _floatings.length; j < fl; ++j) {
						var w = _floatings[j].widget,
							n = _floatings[j].node;
						if (this == w)
							w.setDomVisible_(n, true, {visibility:1});
						else if (_floatVisibleDependent(this, w)) {
							zi = zi >= 0 ? ++zi: _topZIndex(w);
							w.setFloatZIndex_(n, zi);
							w.setDomVisible_(n, true, {visibility:1});
						}
					}

					if (ocvCalled = p) p.onChildVisible_(this);
						
					
					this.fire('onShow');
					
					var wgt = this;
					zk.afterAnimate(function() {zUtl.fireShown(wgt);}, -1);
				} else {
					this.fire('onHide');
					
					var wgt = this;
					zWatch.fireDown('onHide', this);

					for (var j = _floatings.length, bindLevel = this.bindLevel; j--;) {
						var w = _floatings[j].widget;
						if (bindLevel >= w.bindLevel)
							break; 
						if (_floatVisibleDependent(this, w))
							w.setDomVisible_(_floatings[j].node, false, {visibility:1});
					}

					this.setDomVisible_(node, false);
					
					
					if (wgt._nvflex || wgt._nhflex)
						zk.afterAnimate(function() {
							if (wgt.parent)
								zUtl.fireSized(wgt.parent);
						}, -1);
				}
			}
			if (p && !ocvCalled) p.onChildVisible_(this);
				
			jq.onSyncScroll(this);
		}
		return this;
	},
	
	zsync: function () {
		for (var nm in this.effects_) {
			var ef = this.effects_[nm];
			if (ef && ef.sync) ef.sync();
		}
	},
	
	show: function () {return this.setVisible(true);},
	
	hide: function () {return this.setVisible(false);},
	
	setDomVisible_: function (n, visible, opts) {
		if (!opts || opts.display) {
			var act;
			if (act = this.actions_[visible ? 'show': 'hide'])
				act[0].call(this, n, act[1]);
			else
				n.style.display = visible ? '' : 'none';
		}
		if (opts && opts.visibility)
			n.style.visibility = visible ? 'visible': 'hidden';
	},
	
	onChildAdded_: function () {
		jq.onSyncScroll(this);
	},
	
	onChildRemoved_: function () {
		jq.onSyncScroll(this);
	},
	
	onChildReplaced_: function (oldc, newc) {
		this.childReplacing_ = true;
		try {
			if (oldc) this.onChildRemoved_(oldc);
			if (newc) this.onChildAdded_(newc);
		} finally {
			this.childReplacing_ = false;
		}
	},
	
	onChildVisible_: function () {
	},
	
	onChildRenderDefer_: function () {
	},
	
	setTopmost: function () {
		if (!this.desktop) return -1;

		for (var wgt = this; wgt; wgt = wgt.parent)
			if (wgt._floating) {
				var zi = _topZIndex(wgt);
				for (var j = 0, fl = _floatings.length; j < fl; ++j) { 
					var w = _floatings[j].widget,
						n = _floatings[j].node;
					if (wgt == w)
						w.setFloatZIndex_(n, zi); 
					else if (zUtl.isAncestor(wgt, w) && w.isVisible())
						w.setFloatZIndex_(n, ++zi);
				}
				return zi;
			}
		return -1;
	},
	
	setFloatZIndex_: function (node, zi) {
		if (node != this.$n()) node.style.zIndex = zi; 
		else this.setZIndex(zi, {fire:true});
	},
	
	getFloatZIndex_: function (node) {
		return node != this.$n() ? node.style.zIndex: this._zIndex;
	},
	
	getTopWidget: function () {
		for (var wgt = this; wgt; wgt = wgt.parent)
			if (wgt._floating)
				return wgt;
	},
	
	isFloating_: function () {
		return this._floating;
	},
	
	setFloating_: function (floating, opts) {
		if (this._floating != floating) {
			if (floating) {
				
				var inf = {widget: this, node: opts && opts.node? opts.node: this.$n()},
					bindLevel = this.bindLevel;
				for (var j = _floatings.length;;) {
					if (--j < 0) {
						_floatings.unshift(inf);
						break;
					}
					if (bindLevel >= _floatings[j].widget.bindLevel) { 
						_floatings.splice(j + 1, 0, inf);
						break;
					}
				}
				this._floating = true;
			} else {
				for (var j = _floatings.length; j--;)
					if (_floatings[j].widget == this)
						_floatings.splice(j, 1);
				this._floating = false;
			}
		}
		return this;
	},

	
	getZIndex: _zkf = function () {
		return this._zIndex;
	},
	getZindex: _zkf,
	
	setZIndex: _zkf = function (zIndex, opts) {
		if (this._zIndex != zIndex) {
			this._zIndex = zIndex;
			var n = this.$n();
			if (n) {
				n.style.zIndex = zIndex >= 0 ? zIndex: '';
				if (opts && opts.fire) this.fire('onZIndex', (zIndex > 0 || zIndex === 0) ? zIndex: -1, {ignorable: true});
			}
		}
		return this;
	},
	setZindex: _zkf,

	
	getScrollTop: function () {
		var n = this.$n();
		return n ? n.scrollTop: 0;
	},
	
	getScrollLeft: function () {
		var n = this.$n();
		return n ? n.scrollLeft: 0;
	},
	
	setScrollTop: function (val) {
		var n = this.$n();
		if (n) n.scrollTop = val;
		return this;
	},
	
	setScrollLeft: function (val) {
		var n = this.$n();
		if (n) n.scrollLeft = val;
		return this;
	},
	
	scrollIntoView: function () {
		zk(this.$n()).scrollIntoView();
		return this;
	},

	
	redraw: function (out) {
		if (!this.deferRedraw_(out)) {
			var f;
			if (f = this.prolog)
				out.push(f);

			if ((f = this.$class.molds) && (f = f[this._mold]))
				return f.apply(this, arguments);

			zk.error('Mold '+this._mold+' not found in '+this.className);
		}
	},
	
	deferRedraw_: function (out) {
		var delay;
		if ((delay = this._renderdefer) >= 0) {
			if (!this._norenderdefer) {
				this.z_rod = this._z$rd = true;
				this.deferRedrawHTML_(out);
				out = null; 

				var wgt = this;
				setTimeout(function () {_doDeferRender(wgt);}, delay);
				return true;
			}
			delete this._norenderdefer;
			delete this.z_rod;
		}
		return false;
	},
	
	deferRedrawHTML_: function (out) {
		out.push('<div', this.domAttrs_({domClass:1}), ' class="z-renderdefer"></div>');
	},
	
	forcerender: function () {
		_doDeferRender(this);
	},
	
	updateDomClass_: function () {
		if (this.desktop) {
			var n = this.$n();
			if (n) n.className = this.domClass_();
			this.zsync();
		}
	},
	
	updateDomStyle_: function () {
		if (this.desktop) {
			var s = jq.parseStyle(this.domStyle_()),
				n = this.$n();
			
			if (!s.width && this._hflex)
				s.width = n.style.width;
			if (!s.height && this._vflex)
				s.height = n.style.height;
			zk(n).clearStyles().jq.css(s);

			var t = this.getTextNode();
			if (t && t != n) {
				s = this._domTextStyle(t, s);
				zk(t).clearStyles().jq.css(s);
			}
			this.zsync();
		}
	},
	_domTextStyle: function (t, s) {
		
		s = jq.filterTextStyle(s);
		
		if (t.style.width)
			s.width = t.style.width;
		if (t.style.height)
			s.height = t.style.height;
		return s;
	},
	getZclass: function () {
		var zcls = this._zclass;
		return zcls != null ? zcls : 'z-' + this.widgetName;
	},
	
	getTextNode: function () {
	},

	
	domStyle_: function (no) {
		var out = [], s;
		if (s = this.z$display) 
			out.push('display:', s, ';');
		else if (!this.isVisible() && (!no || !no.visible))
			out.push('display:none;');

		if ((!no || !no.style) && (s = this.getStyle())) {
			s = s.replace(REGEX_DQUOT,'\'');  
			out.push(s);
			if (s.charAt(s.length - 1) != ';')
				out.push(';');
		}
		if ((!no || !no.width) && (s = this.getWidth()))
			out.push('width:', s, ';');
		if ((!no || !no.height) && (s = this.getHeight())) 
			out.push('height:', s, ';');
		if ((!no || !no.left) && (s = this.getLeft()))
			out.push('left:', s, ';');
		if ((!no || !no.top) && (s = this.getTop()))
			out.push('top:', s, ';');
		if ((!no || !no.zIndex) && (s = this.getZIndex()) >= 0)
			out.push('z-index:', s, ';');
		return out.join('');
	},
	
	domClass_: function (no) {
		var s, z;
		if (!no || !no.sclass)
			s = this.getSclass();
		if (!no || !no.zclass)
			z = this.getZclass();
		return s ? z ? s + ' ' + z: s: z||'';
	},
	
	domAttrs_: function (no) {
		var out = [], attrs, s;
		if ((!no || !no.id) && (s = this.uuid))
			out.push(' id="', s, '"')
		if ((!no || !no.domStyle) && (s = this.domStyle_(no)))
			out.push(' style="', s, '"');
		if ((!no || !no.domClass) && (s = this.domClass_(no)))
			out.push(' class="', s, '"');
		if ((!no || !no.tooltiptext) && (s = this.domTooltiptext_()))
			out.push(' title="', zUtl.encodeXML(s), '"'); 
		for (var nm in (attrs = this.domExtraAttrs))
			out.push(' ', nm, '="', attrs[nm]||'', '"'); 
		return out.join('');
	},
	
	domTooltiptext_ : function () {
		return this.getTooltiptext();
	},
	
	domTextStyleAttr_: function () {
		var s = this.getStyle();
		return s ? zUtl.appendAttr('style', jq.filterTextStyle(s)): s;
	},

	
	replaceHTML: function (n, desktop, skipper, _trim_, _callback_) {
		if (!desktop) {
			desktop = this.desktop;
			if (!zk.Desktop._ndt) zk.stateless();
		}

		var cfi = skipper ? null: _bkFocus(this);

		var p = this.parent;
		if (p) p.replaceChildHTML_(this, n, desktop, skipper, _trim_);
		else {
			var oldwgt = this.getOldWidget_(n);
			if (oldwgt) oldwgt.unbind(skipper); 
			else if (this.z_rod) _unbindrod(this); 
			jq(n).replaceWith(this.redrawHTML_(skipper, _trim_));
			this.bind(desktop, skipper);
		}

		if (!skipper) {
			if (!jq.isArray(_callback_))
				zUtl.fireSized(this);
			else {
				
				var self = this;
				_callback_.push(function (){
					zUtl.fireSized(self);
				});
			}
				
		}

		_rsFocus(cfi);
		return this;
	},
	
	getOldWidget_: function (n) {
		return Widget.$(n, {strict:true});
	},
	
	redrawHTML_: function (skipper, trim) {
		var out = []; 
		this.redraw(out, skipper);
		out = out.join('');
		return trim ? out.trim(): out;
			
			
	},
	
	
	rerender: function (skipper) {
		if (this.desktop) {
			if (!skipper || skipper > 0) { 
				_rerender(this, skipper||0);
				return this;
			}
			if (skipper < 0)
				skipper = null; 

			var n = this.$n();
			if (n) {
				var oldrod = this.z$rod;
				this.z$rod = false;
					

				var skipInfo;
				if (skipper) {
					skipInfo = skipper.skip(this);
					if (skipInfo) {
						var cfi = _bkFocus(this);

						this.replaceHTML(n, null, skipper, true);

						skipper.restore(this, skipInfo);

						zWatch.fireDown('onRestore', this);
							
						zUtl.fireSized(this);

						_rsFocus(cfi);
					}
				}

				if (!skipInfo)
					this.replaceHTML(n, null, null, true);

				this.z$rod = oldrod;
			}
		}
		return this;
	},

	
	replaceChildHTML_: function (child, n, desktop, skipper, _trim_) {
		var oldwgt = child.getOldWidget_(n);
		if (oldwgt) oldwgt.unbind(skipper); 
		else if (this.shallChildROD_(child))
			_unbindrod(child); 
		jq(n).replaceWith(child.redrawHTML_(skipper, _trim_));
		child.bind(desktop, skipper);
	},
	
	insertChildHTML_: function (child, before, desktop) {
		var ben, html = child.redrawHTML_();
		if (before) {
			if (before.$instanceof(zk.Native)) { 
				ben = before.previousSibling;
				if (ben) {
					if (ben == child) 
						ben = ben.previousSibling;
					if (ben && (ben = ben.$n())) {
						jq(ben).after(html);
						child.bind(desktop);
						return;
					}
				}
				
			}
			before = before.getFirstNode_();
		}
		if (!before)
			for (var w = this;;) {
				ben = w.getCaveNode();
				if (ben) break;

				var w2 = w.nextSibling;
				if (w2 && (before = w2.getFirstNode_()))
					break;

				if (!(w = w.parent)) {
					ben = document.body;
					break;
				}
			}

		if (before) {
			var sib = before.previousSibling;
			if (_isProlog(sib)) before = sib;
			jq(before).before(html);
		} else
			jq(ben).append(html);
		child.bind(desktop);
	},
	
	getCaveNode: function () {
		return this.$n('cave') || this.$n();
	},
	
	getFirstNode_: function () {
		for (var w = this; w; w = w.nextSibling) {
			var n = _getFirstNodeDown(w);
			if (n) return n;
		}
	},
	
	removeChildHTML_: function (child, ignoreDom) {
		var cf = zk.currentFocus;
		if (cf && zUtl.isAncestor(child, cf))
			zk.currentFocus = null;

		var n = child.$n();
		if (n) {
			var sib = n.previousSibling;
			if (child.prolog && _isProlog(sib))
				jq(sib).remove();
		} else
			_prepareRemove(child, n = []);

		child.unbind();

		if (!ignoreDom)
			child.removeHTML_(n);
	},
	
	removeHTML_: function (n) {
		_rmDom(this, n);
		this.clearCache();
	},
	
	
	$n: function (subId) {
		if (subId) {
			var n = this._subnodes[subId];
			if (!n && this.desktop) {
				n = jq(this.uuid + '-' + subId, zk)[0];
				this._subnodes[subId] = n ? n : 'n/a';
			}
			return n == 'n/a' ? null : n;
		}
		var n = this._node;
		if (!n && this.desktop && !this._nodeSolved) {
			this._node = n = jq(this.uuid, zk)[0];
			this._nodeSolved = true;
		}
		return n;
	},
	
	isRealElement: function () {
		return true;
	},
	
	$s: function (subclass) {
		if (subclass) {
			var subcls = this._subzcls[subclass];
			if (!subcls) {
				subcls = this._subzcls[subclass] = this.getZclass() + '-' + subclass;
			}
			return subcls;
		}
		return this.getZclass();
	},
	
	clearCache: function () {
		this._node = null;
		this._subnodes = {};
		this._nodeSolved = false;
	},
	
	getPage: function () {
		var page, dt;
		for (page = this.parent; page; page = page.parent)
			if (page.$instanceof(zk.Page))
				return page;

		return (page = (dt = this.desktop)._bpg) ?
			page: (dt._bpg = new zk.Body(dt));
	},

	
	isBinding: function () {
		if (this.desktop)
			for (var w = this; w; w = w.parent)
				if (w._binding)
					return true;
	},
	
	rerenderNow_: function (skipper) { 
		_rerenderNow(this, skipper);
	},
	
	bind: function (desktop, skipper) {
		this._binding = true;

		_rerenderDone(this, skipper); 
		if (this.z_rod) 
			_bindrod(this);
		else {
			var after = [], fn;
			this.bind_(desktop, skipper, after);
			while (fn = after.shift())
				fn();
		}

		delete this._binding;
		return this;
	},
	
	unbind: function (skipper) {
		_rerenderDone(this, skipper); 
		if (this.z_rod)
			_unbindrod(this);
		else {
			var after = [];
			this.unbind_(skipper, after);
			for (var j = 0, len = after.length; j < len;)
				after[j++]();
		}
		return this;
	},

	
	bind_: function (desktop, skipper, after) {
		_bind0(this);

		this.desktop = desktop || (desktop = zk.Desktop.$(this.parent));

		var p = this.parent, v;
		this.bindLevel = p ? p.bindLevel + 1: 0;

		if ((v = this._draggable) && v != 'false' && !_dragCtl(this))
			this.initDrag_();
		
		if (this._nvflex || this._nhflex)
			_listenFlex(this);

		this.bindChildren_(desktop, skipper, after);
		var self = this;
		if (this.isListen('onBind')) {
			zk.afterMount(function () {
				if (self.desktop) 
					self.fire('onBind');
			});
		}
		
		if (this.isListen('onAfterSize')) 
			zWatch.listen({onSize: this});
		
		if (zk.mobile) {
			after.push(function (){
				setTimeout(function () {
					self.bindSwipe_();
					self.bindDoubleTap_();
					self.bindTapHold_();
				}, 300);
			});
		}
	},
	
	bindChildren_: function (desktop, skipper, after) {
		for (var child = this.firstChild, nxt; child; child = nxt) {
			nxt = child.nextSibling;
				

			if (!skipper || !skipper.skipped(this, child))
				if (child.z_rod) _bindrod(child);
				else child.bind_(desktop, null, after); 
		}
	},

	
	unbind_: function (skipper, after) {
		_unbind0(this);
		_unlistenFlex(this);

		this.unbindChildren_(skipper, after);
		this.cleanDrag_(); 
		this.unbindSwipe_();
		this.unbindDoubleTap_();
		this.unbindTapHold_();
		
		if (this.isListen('onAfterSize')) 
			zWatch.unlisten({onSize: this});
		
		if (this.isListen('onUnbind')) {
			var self = this;
			zk.afterMount(function () {
				if (!self.desktop) 
					self.fire('onUnbind');
			});
		}

		for (var nm in this.effects_) {
			var ef = this.effects_[nm];
			if (ef) ef.destroy();
		}
		this.effects_ = {};
	},
	
	unbindChildren_: function (skipper, after) {
		for (var child = this.firstChild, nxt; child; child = nxt) {
			nxt = child.nextSibling; 

			
			if (!skipper || !skipper.skipped(this, child))
				if (child.z_rod) _unbindrod(child);
				else if (child.desktop) {
					child.unbind_(null, after); 
					
					if (child.$instanceof(zk.Native))
						zAu._storeStub(child);
				}
		}
	},

	
	extraBind_: function (uuid, add) {
		if (add == false) delete _binds[uuid];
		else _binds[uuid] = this;
	},
	setFlexSize_: function(sz, isFlexMin) {
		var n = this.$n(),
			zkn = zk(n);
		if (sz.height !== undefined) {
			if (sz.height == 'auto')
				n.style.height = '';
			else if (sz.height != '' || (sz.height === 0 && !this.isFloating_())) 
				this.setFlexSizeH_(n, zkn, sz.height, isFlexMin);
			else
				n.style.height = this._height || '';
		}
		if (sz.width !== undefined) {
			if (sz.width == 'auto')
				n.style.width = '';
			else if (sz.width != '' || (sz.width === 0 && !this.isFloating_())) 
				this.setFlexSizeW_(n, zkn, sz.width, isFlexMin);
			else
				n.style.width = this._width || '';
		}
	},
	setFlexSizeH_: function(n, zkn, height, isFlexMin) {
		
		n.style.height = jq.px0(height - zkn.marginHeight());
	},
	setFlexSizeW_: function(n, zkn, width, isFlexMin) {
		
		n.style.width = jq.px0(width - zkn.marginWidth());
	},
	beforeChildrenFlex_: function(kid) {
		
		return true; 
	},
	afterChildrenFlex_: function(kid) {
		
	},
	
	afterChildMinFlexChanged_: function (kid, attr) { 
		
		
	},
	ignoreFlexSize_: function(attr) { 
		
		return false;
	},
	ignoreChildNodeOffset_: function(attr) { 
		
		return false;
	},
	beforeMinFlex_: function (attr) { 
		
		return null;
	},
	beforeParentMinFlex_: function (attr) { 
		
	},
	afterChildrenMinFlex_: function() {
		
	},
	afterResetChildSize_: function() {
		
	},
	isExcludedHflex_: function () {
		return jq(this.$n()).css('position') == 'absolute'; 
		
	},
	isExcludedVflex_: function () {
		return jq(this.$n()).css('position') == 'absolute'; 
		
	},
	
	
	getChildMinSize_: function (attr, wgt) { 
		if (attr == 'w') {
			
			var wd = zjq.minWidth(wgt);
			if(zk.ie > 8 && zk.isLoaded('zul.wgt') && wgt.$instanceof(zul.wgt.Image)) {
				wd = zk(wgt).offsetWidth();
			}
			return wd;
		} else {
			return zk(wgt).offsetHeight();
		}
	},
	
	
	getParentSize_: function(p) { 
		var zkp = zk(p);
		return {height: zkp.contentHeight(), width: zkp.contentWidth()};
	},
	getMarginSize_: function (attr) { 
		return zk(this).sumStyles(attr == 'h' ? 'tb' : 'lr', jq.margins);
	},
	getContentEdgeHeight_: function (height) {
		var p = this.$n(),
			fc = this.firstChild,
			
			fc = fc && zk.isLoaded('zul.wgt') && fc.$instanceof(zul.wgt.Caption) ? fc.nextSibling : fc;
	
		
		while (fc && fc.ignoreFlexSize_('h'))
			fc = fc.nextSibling;
		
		var c = fc ? fc.$n() : p.firstChild,
			zkp = zk(p),
			h = zkp.padBorderHeight();
		
		if (c) {
			c = c.parentNode;
			while (c && c.nodeType == 1 && p != c) {
				var zkc = zk(c);
				h += zkc.padBorderHeight() + zkc.sumStyles('tb', jq.margins);
				c = c.parentNode;
			}
			return h;
		}
		return 0;
	},
	getContentEdgeWidth_: function (width) {
		var p = this.$n(),
			fc = this.firstChild,
			
			fc = fc && zk.isLoaded('zul.wgt') && fc.$instanceof(zul.wgt.Caption) ? fc.nextSibling : fc;
	
		
		while (fc && fc.ignoreFlexSize_('w'))
			fc = fc.nextSibling;
		
		var	c = fc ? fc.$n() : p.firstChild,
			zkp = zk(p),
			w = zkp.padBorderWidth();
		
		if (c) {
			c = c.parentNode;
			while (c && c.nodeType == 1 && p != c) {
				var zkc = zk(c);
				w += zkc.padBorderWidth() + zkc.sumStyles('lr', jq.margins);
				c = c.parentNode;
			}
			return w;
		}
		return 0;
	},
	fixFlex_: function() {
		zFlex.fixFlex(this);
	},
	fixMinFlex_: function(n, orient) { 
		return zFlex.fixMinFlex(this, n, orient);
	},
	clearCachedSize_: function() {
		delete this._hflexsz;
		delete this._vflexsz;
	},
	resetSize_: function(orient) {
		var n = this.$n();
		if (n.scrollTop || n.scrollLeft) 
			return;
		n.style[orient == 'w' ? 'width': 'height'] = '';
	},
	
	initDrag_: function () {
		var n = this.getDragNode();
		if (n) { 
			this._drag = new zk.Draggable(this, n, this.getDragOptions_(_dragoptions));
			
			if (zk.ie9 && jq.nodeName(n, 'img'))
				jq(n).bind('mousedown', zk.$void);
		}
	},
	
	cleanDrag_: function () {
		var drag = this._drag;
		if (drag) {
			var n;
			if (zk.ie9 && (n = this.getDragNode()) && jq.nodeName(n, 'img'))
				jq(n).unbind('mousedown', zk.$void);

			this._drag = null;
			drag.destroy();
		}
	},
	
	getDragNode: function () {
		return this.$n();
	},
	
	getDragOptions_: function (map) {
		return map;
	},
	
	ignoreDrag_: function (pt) {
		return false;
	},
	
	getDrop_: function (dragged) {
		if (this == dragged) {
			return null; 
		} else {
			var dropType = this._droppable,
				dragType = dragged._draggable;
			if (dropType == 'true') return this;
			if (dropType && dragType != 'true')
				for (var dropTypes = this._dropTypes, j = dropTypes.length; j--;)
					if (dragType == dropTypes[j])
						return this;
		}
		return this.parent ? this.parent.getDrop_(dragged): null;
	},
	
	dropEffect_: function (over) {
		jq(this.$n()||[])[over ? 'addClass' : 'removeClass']('z-drag-over');
	},
	
	getDragMessage_: function () {
		if (jq.nodeName(this.getDragNode(), 'tr', 'td', 'th')) {
			var n = this.$n('real') || this.getCaveNode();
			return n ? n.textContent || n.innerText || '': '';
		}
	},
	
	onDrop_: function (drag, evt) {
		var data = zk.copy({dragged: drag.control}, evt.data);
		this.fire('onDrop', data, null, Widget.auDelay);
	},
	
	cloneDrag_: function (drag, ofs) {
		

		var msg = this.getDragMessage_();
		if (typeof msg == 'string' && msg.length > 9)
			msg = msg.substring(0, 9) + '...';

		var dgelm = zk.DnD.ghost(drag, ofs, msg);

		drag._orgcursor = document.body.style.cursor;
		document.body.style.cursor = 'pointer';
		jq(this.getDragNode()).addClass('z-dragged'); 
		return dgelm;
	},
	
	uncloneDrag_: function (drag) {
		document.body.style.cursor = drag._orgcursor || '';

		jq(this.getDragNode()).removeClass('z-dragged');
	},
	
	
	
	onSize: function() {},
	
	onAfterSize: function () {
		if (this.desktop && this.isListen('onAfterSize')) {
			var n = this.getCaveNode(),
				width = n.offsetWidth,
				height = n.offsetHeight;
			if (this._preWidth != width || this._preHeight != height) {
				this._preWidth = width;
				this._preHeight = height;
				this.fire('onAfterSize', {width: width, height: height});
			}
		}
	},
	
	
	bindSwipe_: zk.$void,
	
	unbindSwipe_: zk.$void,
	
	bindDoubleTap_: zk.$void,
	
	unbindDoubleTap_: zk.$void,
	
	bindTapHold_: zk.$void,
	
	unbindTapHold_: zk.$void,
	
	focus: function (timeout) {
		return this.canActivate({checkOnly:true})
			&& zk(this.$n()).isRealVisible()
			&& this.focus_(timeout);
	},
	
	focus_: function (timeout) {
		if (zk(this.$n()).focus(timeout)) {
			this.setTopmost();
			return true;
		}
		for (var w = this.firstChild; w; w = w.nextSibling) {
			
			if (w.isRealVisible() && w.focus_(timeout))
				return true;
		}
		return false;
	},
	
	canActivate: function (opts) {
		if (_ignCanActivate)
			return true;
		if (zk.busy && (!opts || !opts.checkOnly)) { 
			jq.focusOut(); 
			return false;
		}

		var modal = zk.currentModal;
		if (modal && !zUtl.isAncestor(modal, this)
		&& !jq.isAncestor(modal.$n(), this.$n())) { 
			var wgt = this.getTopWidget();
			
			
			if (wgt && wgt != modal && wgt.getZIndex() > modal.getZIndex())
				return true;
			
			if (!opts || !opts.checkOnly) {
				var cf = zk.currentFocus;
				
				if (cf && zUtl.isAncestor(modal, cf)) cf.focus(0);
				else modal.focus(0);
			}
			return false;
		}
		return true;
	},

	
	
	smartUpdate: function (nm, val, timeout) {
		zAu.send(new zk.Event(this, 'setAttr', [nm, val]),
			timeout >= 0 ? timeout: -1);
		return this;
	},

	
	
	fireX: function (evt, timeout) {
		var oldtg = evt.currentTarget;
		evt.currentTarget = this;
		try {
			var evtnm = evt.name,
				lsns = this._lsns[evtnm],
				len = lsns ? lsns.length: 0;
			if (len) {
				for (var j = 0; j < len;) {
					var inf = lsns[j++], o = inf[0];
					(inf[1] || o[evtnm]).call(o, evt);
					if (evt.stopped) return evt; 
				}
			}

			if (!evt.auStopped) {
				var toServer = evt.opts && evt.opts.toServer;
				if (toServer || (this.inServer && this.desktop)) {
					var asap = toServer || this._asaps[evtnm];
					if (asap == null) {
						var ime = this.$class._importantEvts;
						if (ime) {
							var ime = ime[evtnm];
							if (ime != null) 
								asap = ime;
						}
					}
					if (asap != null 
					|| evt.opts.sendAhead)
						this.sendAU_(evt,
							asap ? timeout >= 0 ? timeout : Widget.auDelay : -1);
				}
			}
			return evt;
		} finally {
			evt.currentTarget = oldtg;
		}
	},
	
	beforeSendAU_: function (wgt, evt) {
		var en = evt.name;
		if (en == 'onClick' || en == 'onRightClick' || en == 'onDoubleClick')
			evt.shallStop = true;
	},
	
	sendAU_: function (evt, timeout, opts) {
		(evt.target||this).beforeSendAU_(this, evt);
		evt = new zk.Event(this, evt.name, evt.data, evt.opts, evt.domEvent);
			
		if (evt.opts.sendAhead) zAu.sendAhead(evt, timeout);
		else zAu.send(evt, timeout);
	},
	
	shallIgnoreClick_: function (evt) {
	},

	
	fire: function (evtnm, data, opts, timeout) {
		return this.fireX(new zk.Event(this, evtnm, data, opts), timeout);
	},
	
	listen: function (infs, priority) {
		priority = priority ? priority: 0;
		for (var evt in infs) {
			var inf = infs[evt];
			if (jq.isArray(inf)) inf = [inf[0]||this, inf[1]];
			else if (typeof inf == 'function') inf = [this, inf];
			else inf = [inf||this, null];
			inf.priority = priority;

			var lsns = this._lsns[evt];
			if (!lsns) this._lsns[evt] = [inf];
			else
				for (var j = lsns.length;;)
					if (--j < 0 || lsns[j].priority >= priority) {
						lsns.splice(j + 1, 0, inf);
						break;
					}
		}
		return this;
	},
	
	unlisten: function (infs) {
		l_out:
		for (var evt in infs) {
			var inf = infs[evt],
				lsns = this._lsns[evt], lsn;
			for (var j = lsns ? lsns.length: 0; j--;) {
				lsn = lsns[j];
				if (jq.isArray(inf)) inf = [inf[0]||this, inf[1]];
				else if (typeof inf == 'function') inf = [this, inf];
				else inf = [inf||this, null];
				if (lsn[0] == inf[0] && lsn[1] == inf[1]) {
					lsns.splice(j, 1);
					continue l_out;
				}
			}
		}
		return this;
	},
	
	isListen: function (evt, opts) {
		var v = this._asaps[evt];
		if (v) return true;
		if (opts) {
			if (opts.asapOnly) {
				v = this.$class._importantEvts;
				return v && v[evt];
			}
			if (opts.any) {
				if (v != null) return true;
				v = this.$class._importantEvts;
				if (v && v[evt] != null) return true;
			}
		}

		var lsns = this._lsns[evt];
		return lsns && lsns.length;
	},
	
	setListeners: function (infs) {
		for (var evt in infs)
			this.setListener(evt, infs[evt]);
	},
	
	
	setListener: function (evt, fn) { 
		if (jq.isArray(evt)) {
			fn = evt[1];
			evt = evt[0]
		}

		var bklsns = this._bklsns,
			oldfn = bklsns[evt],
			inf = {};
		if (oldfn) { 
			delete bklsns[evt];
			inf[evt] = oldfn
			this.unlisten(inf);
		}
		if (fn) {
			inf[evt] = bklsns[evt]
				= typeof fn != 'function' ? new Function('var event=arguments[0];'+fn): fn;
			this.listen(inf);
		}
	},
	setOverride: function (nm, val) { 
		if (jq.isArray(nm)) {
			val = nm[1];
			nm = nm[0];
		}
		if (val) {
			var oldnm = '$' + nm;
			if (this[oldnm] == null && this[nm]) 
				this[oldnm] = this[nm];
			this[nm] = val;
				
		} else {
			var oldnm = '$' + nm;
			this[nm] = this[oldnm]; 
			delete this[oldnm];
		}
	},
	setOverrides: function (infs) { 
		for (var nm in infs)
			this.setOverride(nm, infs[nm]);
	},

	
	
	doSelect_: function(evt) {
		if (!evt.stopped) {
			var p = this.parent;
			if (p) p.doSelect_(evt);
		}
	},
	
	doTooltipOver_: function (evt) {
		if (!evt.stopped) {
			var p = this.parent;
			if (p) p.doTooltipOver_(evt);
		}
	},
	
	doTooltipOut_: function (evt) {
		if (!evt.stopped) {
			var p = this.parent;
			if (p) p.doTooltipOut_(evt);
		}
	},
	
	doClick_: function (evt) {
		if (_fireClick(this, evt)) {
			var p = this.parent;
			if (p) p.doClick_(evt);
		}
	},
	
	doDoubleClick_: function (evt) {
		if (_fireClick(this, evt)) {
			var p = this.parent;
			if (p) p.doDoubleClick_(evt);
		}
	},
	
	doRightClick_: function (evt) {
		if (_fireClick(this, evt)) {
			var p = this.parent;
			if (p) p.doRightClick_(evt);
		}
	},
	
	doMouseOver_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doMouseOver_(evt);
		}
	},
	
	doMouseOut_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doMouseOut_(evt);
		}
	},
	
	doMouseDown_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doMouseDown_(evt);
		}
	},
	
	doMouseUp_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doMouseUp_(evt);
		}
	},
	
	doMouseMove_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doMouseMove_(evt);
		}
	},

	
	doKeyDown_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doKeyDown_(evt);
		}
	},
	
	doKeyUp_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doKeyUp_(evt);
		}
	},
	
	doKeyPress_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doKeyPress_(evt);
		}
	},
	
	doSwipe_: function(evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doSwipe_(evt);
		}
	},

	
	doFocus_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doFocus_(evt);
		}
	},
	
	doBlur_: function (evt) {
		if (!this.fireX(evt).stopped) {
			var p = this.parent;
			if (p) p.doBlur_(evt);
		}
	},

	
	doResizeScroll_: function () {
		var p = this.parent;
		if (p) p.doResizeScroll_();
	},
	
	
	
	domListen_: function (n, evtnm, fn, keyword) {
		if (!this.$weave) {
			var inf = _domEvtInf(this, evtnm, fn, keyword);
			jq(n, zk).bind(inf[0], inf[1]);
		}
		return this;
	},
	
	domUnlisten_: function (n, evtnm, fn, keyword) {
		if (!this.$weave) {
			var inf = _domEvtInf(this, evtnm, fn, keyword);
			jq(n, zk).unbind(inf[0], inf[1]);
		}
		return this;
	},
	
	listenOnFitSize_: function () {
		if (!this._fitSizeListened && (this._hflex == 'min' || this._vflex == 'min')){
			zWatch.listen({onFitSize: [this, zFlex.onFitSize]});
			this._fitSizeListened = true;
		}
	},
	
	unlistenOnFitSize_: function () {
		if (this._fitSizeListened) {
			zWatch.unlisten({onFitSize: [this, zFlex.onFitSize]});
			delete this._fitSizeListened;
		}
	},
	
	fromPageCoord: function (x, y) {
		var ofs = zk(this).revisedOffset();
		return [x - ofs[0], y - ofs[1]];
	},
	
	isWatchable_: function (name, p, cache) {
		
		
		var strict = name != 'onShow', wgt;
		if (p)
			return this.isRealVisible({dom:true, strict:strict, until:p, cache: cache});

		for (wgt = this;;) {
			if (!wgt.$instanceof(zk.Native)) 
				break;

			
			
			if (!wgt._visible)
				return false;

			
			if (!(wgt = wgt.parent))
				return true; 
		}

		return zk(wgt.$n()).isRealVisible(strict);
	},
	toJSON: function () { 
		return this.uuid;
	},
	
	ignoreDescendantFloatUp_: function (des) {
		return false;
	},
	
	getDomEvtInf_: function (wgt, evtnm, fn, keyword) {
		return _domEvtInf(wgt, evtnm, fn, keyword);
	}

}, {
	
	$: function (n, opts) {
		if (n && n.zk && n.zk.jq == n) 
			n = n[0];

		if (!n || Widget.isInstance(n))
			return n;

		var wgt, id;
		if (typeof n == 'string') {
		
			if ((id = n.charAt(0)) == '#') n = n.substring(1);
			else if (id == '$') {
				id = _globals[n.substring(1)];
				return id ? id[0]: null;
			}
			wgt = _binds[n]; 
			if (!wgt)
				wgt = (id = n.indexOf('-')) >= 0 ? _binds[n.substring(0, id)]: null;
			return wgt;
		}

		if (!n.nodeType) { 
			var e1, e2;
			n = ((e1 = n.originalEvent) ? e1.z$target:null)
				|| ((e1 = n.target) && (e2 = e1.z$proxy) ? e2: e1) || n; 
		}

		opts = opts || {};
		if (opts.exact)
			return _binds[n.id];

		for (; n; n = zk(n).vparentNode(true)) {
			try {
				id = n.id || (n.getAttribute ? n.getAttribute('id') : '');
				if (id && typeof id == 'string') {
					wgt = _binds[id]; 
					if (wgt)
						return wgt;

					var j = id.indexOf('-');
					if (j >= 0) {
						wgt = _binds[id = id.substring(0, j)];
						if (wgt) {
							if (!opts.child)
								return wgt;

							var n2 = wgt.$n();
							if (n2 && jq.isAncestor(n2, n))
								return wgt;
						}
					}
				}
			} catch (e) { 
			}
			if (opts.strict)
				break;
		}
		return null;
	},

	
	mimicMouseDown_: function (wgt, noFocusChange, which) { 
		var modal = zk.currentModal;
		if (modal && !wgt) {
			var cf = zk.currentFocus;
			
			
			if (cf && zUtl.isAncestor(modal, cf)) cf.focus(0);
			else modal.focus(0);
		} else if (!wgt || wgt.canActivate()) {
			if (!noFocusChange) {
				zk._prevFocus = zk.currentFocus;
				zk.currentFocus = wgt;
				zk._cfByMD = true;
				setTimeout(function(){zk._cfByMD = false; zk._prevFocus = null;}, 0);
					
			}

			if (wgt) 
				zWatch.fire('onFloatUp', wgt, {triggerByClick: which}); 
			else
				for (var dtid in zk.Desktop.all)
					zWatch.fire('onFloatUp', zk.Desktop.all[dtid]); 
		}
	},
	
	getElementsByName: function (name) {
		var els = [];
		for (var wid in _binds) {
			if (name == '*' || name == _binds[wid].widgetName) {
				var n = _binds[wid].$n(), w;
				
				if (n && (w = Widget.$(_binds[wid]))) {
					els.push({
						n: n,
						w: w
					});
				}
			}
		}
		if (els.length) {
			
			
			els.sort(function(a, b) {
				var w1 = a.w,
					w2 = b.w;
				
				
				if (w1.bindLevel < w2.bindLevel) {
					do {
						w2 = w2.parent;
					} while (w1 && w1.bindLevel < w2.bindLevel);
				} else if (w1.bindLevel > w2.bindLevel) {
					do {
						w1 = w1.parent;
					} while (w2 && w1.bindLevel > w2.bindLevel);
				}
				var wp1 = w1.parent,
					wp2 = w2.parent;
				while (wp1 && wp2 && wp1 != wp2) {
					w1 = wp1;
					w2 = wp2;
					wp1 = wp1.parent;
					wp2 = wp2.parent;
				}
				if (w1 && w2) {
					return w1.getChildIndex() - w2.getChildIndex();
				}	
				return 0;
			});
			var tmp = [];
			for (var i = els.length; i--;)
				tmp.unshift(els[i].n);
			els = tmp;
		}
		return els;
	},
	
	getElementsById: function (id) {
		var els = [];
		for (var n, wgts = _globals[id], i = wgts?wgts.length:0; i--;) {
			n = wgts[i].$n();
			if (n) els.unshift(n);
		}
		return els;
	},

	
	
	uuid: function (id) {
		var uuid = typeof id == 'object' ? id.id || '' : id,
			j = uuid.indexOf('-');
		return j >= 0 ? uuid.substring(0, j): id;
	},
	
	nextUuid: function () {
		return '_z_' + _nextUuid++;
	},

	
	isAutoId: function (id) {
		return !id;
	},

	
	register: function (clsnm, blankprev) {
		var cls = zk.$import(clsnm);
		cls.prototype.className = clsnm;
		var j = clsnm.lastIndexOf('.');
		if (j >= 0) clsnm = clsnm.substring(j + 1);
		_wgtcls[cls.prototype.widgetName = clsnm.toLowerCase()] = cls;
		if (blankprev) cls.prototype.blankPreserved = true;
	},
	
	getClass: function (wgtnm) {
		return _wgtcls[wgtnm];
	},
	
	newInstance: function (wgtnm, props) {
		var cls = _wgtcls[wgtnm];
		if (!cls) {
			zk.error(cls = 'Unknown widget: '+wgtnm);
			throw cls;
		}
		return new cls(props);
	},
	
	auDelay: 38
});
zkreg = Widget.register; 


zk.RefWidget = zk.$extends(zk.Widget, {
	
	className: 'zk.RefWidget',
	
	widgetName: 'refWidget',
	bind_: function () {
		var w = Widget.$(this.uuid);
		if (!w) {
			zk.error('RefWidget not found: ' + this.uuid);
			return;
		}

		var p;
		if (p = w.parent) 
			_unlink(p, w); 

		_replaceLink(this, w);
		this.parent = this.nextSibling = this.previousSibling = null;

		_addIdSpaceDown(w); 

		
	}
});



zk.Desktop = zk.$extends(zk.Widget, {
	
	z_virnd: true,

	bindLevel: 0,
	
	className: 'zk.Desktop',
	
	widgetName: 'desktop',
	
	
	
	
	$init: function (dtid, contextURI, updateURI, reqURI, stateless) {
		this.$super('$init', {uuid: dtid}); 

		var Desktop = zk.Desktop, dts = Desktop.all, dt;

		this._aureqs = [];
		

		if (dt = dts[dtid]) {
			if (updateURI != null) dt.updateURI = updateURI;
			if (contextURI != null) dt.contextURI = contextURI;
		} else {
			this.uuid = this.id = dtid;
			this.updateURI = updateURI != null ? updateURI: zk.updateURI;
			this.contextURI = contextURI != null ? contextURI: zk.contextURI;
			this.requestPath = reqURI || '';
			this.stateless = stateless;
			dts[dtid] = this;
			++Desktop._ndt;
		}

		Desktop._dt = dt||this; 
		Desktop.sync(60000); 
	},
	bind_: zk.$void,
	unbind_: zk.$void,
	
	setId: zk.$void
},{
	
	$: function (dtid) {
		var Desktop = zk.Desktop, w;
		if (dtid) {
			if (Desktop.isInstance(dtid))
				return dtid;

			w = Desktop.all[dtid];
			if (w)
				return w;

			w = Widget.$(dtid);
			for (; w; w = w.parent) {
				if (w.desktop)
					return w.desktop;
				if (w.$instanceof(Desktop))
					return w;
			}
			return null;
		}

		if (w = Desktop._dt)
			return w;
		for (dtid in Desktop.all)
			return Desktop.all[dtid];
	},
	
	all: {},
	_ndt: 0, 
	
	sync: function (timeout) {
		var Desktop = zk.Desktop, dts = Desktop.all, dt;

		if (_syncdt) {
			clearTimeout(_syncdt);
			_syncdt = null;
		}

		if (timeout >= 0)
			_syncdt = setTimeout(function () {
				_syncdt = null;
				Desktop.sync();
			}, timeout); 
		else {
			for (var dtid in dts)
				if (!_exists(dt = dts[dtid]) && dt.firstChild) { 
					delete dts[dtid];
					--Desktop._ndt;
					if (Desktop._dt == dt)
						Desktop._dt = null;
					zAu._rmDesktop(dt);
				}

			if (!Desktop._dt)
				for (var dtid in dts) {
					Desktop._dt = dts[dtid];
					break;
				}
		}
		return Desktop._dt;
	}
});

zk._wgtutl = { 
	setUuid: function (wgt, uuid) { 
		if (!uuid)
			uuid = Widget.nextUuid();
		if (uuid != wgt.uuid) {
			var n = wgt.$n();
			if (n) {
				
				if (!wgt.rawId)
					throw 'id immutable after bound'; 
				n.id = uuid;
				delete _binds[wgt.uuid];
				_binds[uuid] = wgt;
				wgt.clearCache();
			}
			wgt.uuid = uuid;
		}
	},
	
	replace: function (from, to, kids) { 
		_replaceLink(from, to);
		from.parent = from.nextSibling = from.previousSibling = null;

		if (kids) {
			to.lastChild = from.lastChild;
			for (var p = to.firstChild = from.firstChild; p; p = p.nextSibling)
				p.parent = to;
			to.nChildren = from.nChildren;
			from.firstChild = from.lastChild = null;
			from.nChildren = 0;
		}
		from.nChildren = 0;
	},

	autohide: function () { 
		if (!_floatings.length) {
			for (var n; n = _hidden.shift();)
				n.style.visibility = n.getAttribute('z_ahvis')||'';
			return;
		}

		for (var tns = ['IFRAME', 'APPLET'], i = 2; i--;)
			l_nxtel:
			for (var ns = document.getElementsByTagName(tns[i]), j = ns.length; j--;) {
				var n = ns[j], $n = zk(n), visi;
				if ((!(visi=$n.isVisible(true)) && !_hidden.$contains(n))
				|| (!i && !n.getAttribute('z_autohide') && !n.getAttribute('z.autohide'))) 
					continue; 

				var tc = _topnode(n);
				function hide(f) {
					var tf = _topnode(f);
					if (tf == tc || _zIndex(tf) < _zIndex(tc) || !$n.isOverlapped(f))
						return;

					if (visi) {
						_hidden.push(n);
						try {
							n.setAttribute('z_ahvis', n.style.visibility);
						} catch (e) {
						}
						n.style.visibility = 'hidden';
					}
					return true; 
				}

				for (var k = _floatings.length; k--;)
					if (hide(_floatings[k].node))
						continue l_nxtel;

				if (_hidden.$remove(n))
					n.style.visibility = n.getAttribute('z_ahvis')||'';
			}
	}
};
})();


zk.Page = zk.$extends(zk.Widget, {
	
	z_virnd: true,

	_style: 'width:100%;height:100%',
	
	className: 'zk.Page',
	
	widgetName: 'page',

	
	$init: function (props, contained) {
		this._fellows = {};

		this.$super('$init', props);

		if (contained) zk.Page.contained.push(this);
	},
	
	redraw: _zkf = function (out) {
		out.push('<div', this.domAttrs_(), '>');
		for (var w = this.firstChild; w; w = w.nextSibling)
			w.redraw(out);
		out.push('</div>');
	}
},{
	$redraw: _zkf,
	
	contained: []
});
zkreg('zk.Page', true);


zk.Body = zk.$extends(zk.Page, {
	$init: function (dt) {
		this.$super('$init', {});
		this.desktop = dt;
	},
	$n: function (subId) {
		return subId ? null: document.body;
	},
	redraw: zk.$void
});

zk.Native = zk.$extends(zk.Widget, {
	
	z_virnd: true,

	
	className: 'zk.Native',
	
	widgetName: 'native',
	

	$n: function (subId) {
		return !subId && this.id ? jq('#' + this.id):
			this.$supers('$n', arguments); 
	},
	redraw: _zkf = function (out) {
		var s = this.prolog, p;
		if (s) {
			
			
			
			if (this.$instanceof(zk.Native) 
			&& !this.id && (p=this.parent) && !p.z_virnd) { 
				var j = 0, len = s.length, cond, cc;
				for (cond = {whitespace:1}; j < len; ++j) {
					if ((cc = s.charAt(j)) == '<')
						break; 
					if (!zUtl.isChar(cc, cond)) {
						j = len; 
						break;
					}
				}
				if (j < len) {
					cond = {upper:1,lower:1,digit:1,'-':1};
					while (++j < len)
						if (!zUtl.isChar(s.charAt(j), cond))
							break;
					s = s.substring(0, j) + ' id="' + this.uuid + '"' + s.substring(j); 
				}
			}
			
			out.push(zk.Native.replaceScriptContent(s));
			if (this.value && s.startsWith('<textarea'))
				out.push(this.value);
		}

		for (var w = this.firstChild; w; w = w.nextSibling)
			w.redraw(out);

		s = this.epilog;
		if (s) out.push(s);
	}
}, {
	$redraw: _zkf,
	replaceScriptContent: (function () {
		var Script_RE = new RegExp(/<script[^>]*>([\s\S]*?)<\/script>/g);
		var Replace_RE = new RegExp(/<\/(?=script>)/ig);
		return function (str) {
			try {
				var result = str.match(Script_RE);
				if (!result)
					return str.replace(Replace_RE, '<\\/');
				else {
					for (var i = 0, j = result.length; i < j; i++) {
						var substr = result[i];
						
						
						if (substr.length >= 17) {
							var cnt = substr.substring(8, substr.length - 9);
							var cnt2 = zk.Native.replaceScriptContent(cnt);
							if (cnt != cnt2)
								str = str.replace(cnt, cnt2);
						}
					}
				}
				return str;
			} catch (e) {}
			return str;
		};
	})()
});


zk.Macro = zk.$extends(zk.Widget, {
	
	className: 'zk.Macro',
	
	widgetName: 'macro',
	
	_enclosingTag: 'div',

	$init: function () {
		this._fellows = {};
		this.$supers('$init', arguments);
	},
	$define: {
		
		
		enclosingTag: function () {
			this.rerender();
		}
	},

	
	redraw: function (out) {
		var style = ' style="display: inline-block; min-width: 1px;"';
		out.push('<', this._enclosingTag, this.domAttrs_(), style, '>'); 
		for (var w = this.firstChild; w; w = w.nextSibling)
			w.redraw(out);
		out.push('</', this._enclosingTag, '>');
	}
});


zk.Skipper = zk.$extends(zk.Object, {
	
	skipped: function (wgt, child) {
		return wgt.caption != child;
	},
	
	skip: function (wgt, skipId) {
		var skip = jq(skipId || wgt.getCaveNode(), zk)[0];
		if (skip && skip.firstChild) {
			var cf = zk.currentFocus,
				iscf = cf && cf.getInputNode;
			
			if (iscf && zk.ie < 11) 
				zk.cfrg = zk(cf.getInputNode()).getSelectionRange();
			
			skip.parentNode.removeChild(skip);
				
			
			if (iscf && zk.chrome) 
				zk.currentFocus = cf;
			
			return skip;
		}
	},
	
	restore: function (wgt, skip) {
		if (skip) {
			var loc = jq(skip.id, zk)[0];
			for (var el; el = skip.firstChild;) {
				skip.removeChild(el);
				loc.appendChild(el);

				zjq._fixIframe(el); 
			}
		}
	}
});


	
	

zk.Skipper.nonCaptionSkipper = new zk.Skipper();



function zkopt(opts) {
	for (var nm in opts) {
		var val = opts[nm];
		switch (nm) {
		case 'pd': zk.procDelay = val; break;
		case 'td': zk.tipDelay =  val; break;
		case 'art': zk.resendTimeout = val; break;
		case 'dj': zk.debugJS = val; break;
		case 'kd': zk.keepDesktop = val; break;
		case 'pf': zk.pfmeter = val; break;
		case 'ta': zk.timerAlive = val; break;
		case 'gd': zk.groupingDenied = val; break;
		case 'to':
			zk.timeout = val;
			zAu._resetTimeout();
			break;
		case 'ed':
			switch (val) {
			case 'e':
				zk.feature.ee = true;
			case 'p':
				zk.feature.pe = true;
			}
			break;
		case 'eu': zAu.setErrorURI(val); break;
		case 'ppos': zk.progPos = val; break;
		case 'eup': zAu.setPushErrorURI(val);
		}
	}
}


zk.copy(zk, (function() {
	var _loaded = {'zk': true}, 
		_xloadings = [], 
		_loadedsemis = [], 
		_afterLoadFronts = [],
		_afterLoads = [],
		_afterPkgLoad = {}, 
		_pkgdepend = {},
		_pkgver = {},
		_pkghosts = {}, _defhost = [],
		_loading = zk.copy({'zul.lang': true}, _loaded); 

	
	
	function markLoading(nm) {
		
		_loading[nm] = true;

		_xloadings.push(nm);
		if (updCnt() == 1) {
			zk.disableESC();
		}
	}
	function doEnd(afs, wait) {
		for (var fn; fn = afs.shift();) {
			if (updCnt() || (wait && _loadedsemis.length)) {
				afs.unshift(fn);
				return;
			}
			fn();
		}
	}
	function updCnt() {
		return (zk.loading = _xloadings.length);
	}

  return { 
	setLoaded: _zkf = function (pkg, wait) { 
		_xloadings.$remove(pkg);
		_loading[pkg] = true;

		if (wait) {
			if (!_loaded[pkg]) _loadedsemis.push(pkg);
		} else {
			_loadedsemis.$remove(pkg);
			_loaded[pkg] = true;

			var afpk = _afterPkgLoad[pkg];
			if (afpk) {
				delete _afterPkgLoad[pkg];
				_afterLoadFronts.$addAll(afpk);
			}

			var deps = _pkgdepend[pkg];
			if (deps) {
				delete _pkgdepend[pkg];
				for (var pn; pn = deps.unshift();)
					zk.load(pn);
			}
		}

		if (!updCnt()) {
			try {
				zk.enableESC();
			} catch (ex) {
			}
			doEnd(_afterLoadFronts);
			doEnd(_afterLoads, 1);
		}
	},
	
	setScriptLoaded: _zkf,

	
	isLoaded: function (pkg, loading) {
		return (loading && _loading[pkg]) || _loaded[pkg];
	},
	
	
	load: function (pkg, dt, func) {
		if (typeof dt == 'function')
			if (func) throw 'At most one function allowed';
			else {
				func = dt;
				dt = null;
			}

		if (func) zk.afterLoad(pkg, func, true);

		var loading;
		for (var pkgs = pkg.split(','), j = pkgs.length; j--;) {
			pkg = pkgs[j].trim();
			if (!zk._load(pkg, dt))
				loading = true;
		}
		return !loading;
	},
	_load: function (pkg, dt) { 
		if (!pkg || _loading[pkg])
			return !zk.loading && !_loadedsemis.length;
			

		markLoading(pkg);

		var modver = zk.getVersion(pkg) || zk.build,
			e = document.createElement('script'),
			uri = pkg + '.wpd',
			host = zk.getHost(pkg, true);
		e.type = 'text/javascript';
		e.charset = 'UTF-8';

		if (uri.charAt(0) != '/') uri = '/' + uri;

		if (host) uri = host + '/web/js' + uri;
		else {
			if (modver) uri = '/web/_zv' + modver + '/js' + uri;
			else uri = '/web/js' + uri;
			uri = zk.ajaxURI(uri, {desktop:dt,au:true});
		}

		e.src = uri;
		jq.head().appendChild(e);
		return false;
	},

	
	loadScript: function (src, name, charset) {
		if (name)
			markLoading(name);

		var e = document.createElement('script');
		e.type = 'text/javascript';
		e.charset = charset || 'UTF-8';
		e.src = src;
		jq.head().appendChild(e);
		return this;
	},
	
	loadCSS: function (href, id, media) {
		var ln = document.createElement('link');
		if (id) ln.id = id;
		ln.rel = 'stylesheet';
		ln.type = 'text/css';
		ln.href = href;
		if (media) ln.media = media;
		jq.head().appendChild(ln);
		return this;
	},

	
	getVersion: function (pkg) {
		for (var ver; pkg; pkg = pkg.substring(0, pkg.lastIndexOf('.')))
			if (ver = _pkgver[pkg])
				return ver;
	},
	
	setVersion: function (pkg, ver) {
		_pkgver[pkg] = ver;
	},
	
	depends: function (a, b) {
		if (a && b) 
			if (_loaded[a]) zk.load(b);
			else {
				if (_pkgdepend[a]) _pkgdepend[a].push(b);
				else _pkgdepend[a] = [b];
			}
	},

	
	
	afterLoad: function (a, b, front) {
		if (typeof a == 'string') {
			if (!b) return true;

			for (var pkgs = a.split(','), j = pkgs.length; j--;) {
				var p = pkgs[j].trim();
				if (p && !_loaded[p]) {
					while (j--) {
						var p2 = pkgs[j].trim();
						if (p2 && !_loaded[p2]) { 
							var a1 = a, b1 = b;
							b = function () {
								zk.afterLoad(a1, b1, front); 
							};
							break;
						}
					}

					if (_afterPkgLoad[p]) _afterPkgLoad[p].push(b);
					else _afterPkgLoad[p] = [b];
					return false;
				}
			}

			
			a = b;
		}

		if (a) {
			if (zk.loading || _loadedsemis.length) {
				(front ? _afterLoadFronts: _afterLoads).push(a);
				return false;
			}
			a(); 
			return true;
		}
	},
	
	getHost: function (pkg, js) {
		for (var p in _pkghosts)
			if (pkg.startsWith(p))
				return _pkghosts[p][js ? 1: 0];
		return _defhost[js ? 1: 0];
	},
	
	setHost: function (host, updURI, pkgs) {
		var hostUpd = host + updURI;
		if (!_defhost.length)
			for (var scs = document.getElementsByTagName('script'), j = 0, len = scs.length;
			j < len; ++j) {
				var src = scs[j].src;
				if (src)
					if (src.startsWith(host)) {
						_defhost = [host, hostUpd];
						break;
					} else if (src.indexOf('/zk.wpd') >= 0)
						break;
			}
		for (var j = 0; j < pkgs.length; ++j)
			_pkghosts[pkgs[j]] = [host, hostUpd];
	}
  }
})());




function zkpi(nm, wv) {
	return zk.isLoaded(nm) ? null: {n: nm, p: zk.$package(nm, false, wv)};
}


function zkpb(pguid, dtid, contextURI, updateURI, reqURI, props) {
	zkx([0, pguid,
		zk.copy(props, {dt: dtid, cu: contextURI, uu: updateURI, ru: reqURI}),[]]);
}

zkpe = zk.$void;


function zkver(ver, build, ctxURI, updURI, modVers, opts) {
	zk.version = ver;
	zk.build = build;
	zk.contextURI = ctxURI;
	zk.updateURI = updURI;

	for (var nm in modVers)
		zk.setVersion(nm, modVers[nm]);

	if (!zk.feature)
		zk.feature = {standard: true};
	zkopt(opts);
}


function zkmld(wgtcls, molds) {
	if (!wgtcls.superclass) {
		zk.afterLoad(function () {zkmld(wgtcls, molds);});
		return;
	}

	var ms = wgtcls.molds = {};
	for (var nm in molds) {
		var fn = molds[nm];
		ms[nm] = typeof fn == 'function' ? fn: fn[0].molds[fn[1]];
	}		
}


function zkamn(pkg, fn) {
	zk.load(pkg, function () {
		setTimeout(function(){
			zk.afterMount(fn);
		}, 20);
	});
}

(function () {
	var Widget = zk.Widget,
		_wgt_$ = Widget.$, 
		_crInfBL0 = [], _crInfBL1 = [], 
		_crInfAU0 = [], 
		_aftMounts = [], 
		_aftResizes = [], 
		_mntctx = {}, 
		_paci = {s: 0, e: -1, f0: [], f1: []}, 
		_t0 = jq.now();

	
	
	
	
	
	
	
	jq(function () {
		function _stateless() {
			var dts = zk.Desktop.all;
			for (var dtid in dts)
				if (dts[dtid].stateless) return true;
		}
		_paci.i = setInterval(function () {
			var stateless;
			if ((zk.booted && !zk.mounting) || (stateless = _stateless()))
				if (stateless || _paci.s == _paci.e) { 
					clearInterval(_paci.i);
					var fs = _paci.f0.concat(_paci.f1);
					_paci = null;
					for (var f; f = fs.shift();)
						f();
				} else
					_paci.e = _paci.s;
		}, 25);
	});
	
	zk._apac = function (fn, _which_) {
		if (_paci)
			return _paci[_which_ || 'f1'].push(fn);
		zk.afterMount(fn); 
	};



	
	

	zk.afterMount = function (fn, delay) { 
		if (fn)
			if (!jq.isReady)
				jq(function () {zk.afterMount(fn);}); 
			else if (zk.mounting)
				_aftMounts.push(fn); 
			else if (zk.loading)
				zk.afterLoad(fn);
			else if (delay < 0) {
				fn();
				return true; 
			} else
				setTimeout(fn, delay);
	};


    
    

    zk.afterResize = function (fn) {
        if (fn)
            _aftResizes.push(fn);
    }
    zk.doAfterResize = function () {
        for (var fn; fn = _aftResizes.shift();) {
            fn();
        }
    }
	function _curdt() {
		return _mntctx.curdt || (_mntctx.curdt = zk.Desktop.$());
	}
	
	function mountpkg(infs) {
		var types = {};
		for (var j = infs.length; j--;) {
			var inf = infs[j];
			if (!inf.pked) { 
				inf.pked = true;
				getTypes(types, inf[0], inf[1]);
			}
		}

		for (var type in types) {
			var j = type.lastIndexOf('.');
			if (j >= 0)
				zk._load(type.substring(0, j), types[type]); 
		}
	}
	
	function getTypes(types, dt, wi) {
		var type = wi[0];
		if (type === 0) 
			type = wi[2].wc;
		else if (type === 1) 
			wi[0] = type = 'zhtml.Widget';
		if (type)
			types[type] = dt;

		for (var children = wi[3], j = children.length; j--;)
			getTypes(types, dt, children[j]);
	}
	
	function mtBL() {
		for (;;) {
			if (zk.loading)
				return zk.afterLoad(mtBL); 

			var inf = _crInfBL0.shift();
			if (!inf)
				break; 

			_crInfBL1.push([inf[0], create(inf[3]||inf[0], inf[1], true), inf[2], inf[4]]);
				
				
				
				
				

			if (breathe(mtBL)) 
				return; 
		}

		mtBL0();
	}
	function mtBL0() {
		for (;;) {
			if (_crInfBL0.length)
				return; 

			if (zk.loading)
				return zk.afterLoad(mtBL0);

			if (zk.ie < 11 && !jq.isReady) 
				return jq(mtBL0);

			var inf = _crInfBL1.shift();
			if (!inf) break;

			var wgt = inf[1];
			if (inf[2])
				wgt.bind(inf[0]); 
			else {
				var $jq;
				if (zk.processing
						&& ($jq = jq('#zk_proc')).length) {
					if ($jq.hasClass('z-loading') && $jq.parent().hasClass('z-temp')) {
						$jq[0].id = 'zna';
						if (!jq('#zk_proc').length) 
							zUtl.progressbox('zk_proc', window.msgzk?msgzk.PLEASE_WAIT:'Processing...', true);
					}
				}
				wgt.replaceHTML('#' + wgt.uuid, inf[0]);
			}

			doAuCmds(inf[3]); 
		}

		mtBL1();
	}
	function mtBL1() {
		if (_crInfBL0.length || _crInfBL1.length)
			return; 

		zk.booted = true;
		zk.mounting = false;
		doAfterMount(mtBL1);
		_paci && ++_paci.s;
		if (!zk.clientinfo) {
			zk.endProcessing();
		}

		zk.bmk.onURLChange();
		if (zk.pfmeter) {
			var dts = zk.Desktop.all;
			for (var dtid in dts)
				zAu._pfdone(dts[dtid], dtid);
		}
	}

	
	function mtAU() {
		for (;;) {
			if (zk.loading)
				return zk.afterLoad(mtAU);

			var inf = _crInfAU0.shift(), filter, wgt;
			if (!inf)
				break; 

			if (filter = inf[4][1]) 
				Widget.$ = function (n, opts) {return filter(_wgt_$(n, opts));}
			try {
				wgt = create(null, inf[1]);
			} finally {
				if (filter) Widget.$ = _wgt_$;
			}
			inf[4][0](wgt); 

			if (breathe(mtAU))
				return; 
		}
		mtAU0();
	}
	function mtAU0() {
		zk.mounting = false;
		doAfterMount(mtAU0);

		zAu._doCmds(); 
		doAfterMount(mtAU0);
	}
	function doAfterMount(fnext) {
		for (var fn; fn = _aftMounts.shift();) {
			fn();
			if (zk.loading) {
				zk.afterLoad(fnext); 
				return true; 
			}
		}
	}

	function doAuCmds(cmds) {
		if (cmds && cmds.length)
			zk._apac(function () {
				for (var j = 0; j < cmds.length; j += 2)
					zAu.process(cmds[j], cmds[j + 1]);
			}, 'f0');
	}

	
	function create(parent, wi, ignoreDom) {
		var wgt, stub, v,
			type = wi[0],
			uuid = wi[1],
			props = wi[2]||{};
		if (type === 0) { 
			type = zk.cut(props, 'wc')
			var cls = type ? zk.$import(type): zk.Page;
			(wgt = new cls({uuid: uuid}, zk.cut(props, 'ct'))).inServer = true;
			if (parent) parent.appendChild(wgt, ignoreDom);
		} else {
			if ((stub = type == '#stub') || type == '#stubs') {
				if (!(wgt = _wgt_$(uuid) 
						|| zAu._wgt$(uuid))) 
					throw 'Unknown stub '+uuid;
				var w = new Widget();
				
				
				if (wgt.desktop || wgt.z_rod === 9)
					wgt.unbind(); 
				zk._wgtutl.replace(wgt, w, stub);
					
					
			} else {
				var cls = zk.$import(type);
				if (!cls)
					throw 'Unknown widget: ' + type;
				(wgt = new cls(zkac)).inServer = true;
					
				wgt.uuid = uuid;
				if (v = wi[4])
					wgt.setMold(v);
			}
			if (parent) parent.appendChild(wgt, ignoreDom);

			
			if (v = zk.cut(props, 'z$al'))
				zk.afterLoad(function () {
					for (var p in v)
						wgt.set(p, v[p](), true); 
				});
		}

		for (var nm in props)
			wgt.set(nm, props[nm], true); 

		for (var j = 0, childs = wi[3], len = childs.length;
		j < len; ++j)
			create(wgt, childs[j]);
		return wgt;
	}

	
	function breathe(fn) {
		var t = jq.now(), dt = t - _t0;
		if (dt > 2500) { 
			_t0 = t;
			dt >>= 6;
			setTimeout(fn, dt < 10 ? dt: 10); 
				
			return true;
		}
	}

  zk.copy(window, {
	
	zkdt: function (dtid, contextURI, updateURI, reqURI) {
		var dt = zk.Desktop.$(dtid);
		if (dt == null) {
			dt = new zk.Desktop(dtid, contextURI, updateURI, reqURI);
			if (zk.pfmeter) zAu._pfrecv(dt, dtid);
		} else {
			if (updateURI != null) dt.updateURI = updateURI;
			if (contextURI != null) dt.contextURI = contextURI;
			if (reqURI != null) dt.requestPath = reqURI;
		}
		_mntctx.curdt = dt;
		return dt;
	},

	
	zkx: function (wi, extra, aucmds, js) { 
		zk.mounting = true;

		try {
			if (js) jq.globalEval(js);

			var mount = mtAU, infs = _crInfAU0, delay, owner;
			if (!extra || !extra.length) { 
				delay = extra;
				if (wi) {
					extra = aucmds;
					aucmds = null;
				}
				mount = mtBL;
				infs = _crInfBL0;
			} 

			if (wi) {
				if (wi[0] === 0) { 
					var props = wi[2],
						dt = zkdt(zk.cut(props, 'dt'), zk.cut(props, 'cu'), zk.cut(props, 'uu'), zk.cut(props, 'ru'));
					if (owner = zk.cut(props, 'ow'))
						owner = Widget.$(owner);
					var zf;
					if ((zf = zk.feature) && (zf.pe || zf.ee) && zk.clientinfo !== undefined) {
						zAu.cmd0.clientInfo(dt.uuid);
						if (extra) {
							var newExtra = [];
							for (var j = 0; j < extra.length; j += 2) {
								if (extra[j] != 'clientInfo')
									newExtra.push(extra[j], extra[j + 1]);
							}
							extra = newExtra;
						}
					} else
						delete zk.clientinfo;
				}

				infs.push([_curdt(), wi, _mntctx.bindOnly, owner, extra]);
					
				mountpkg(infs);
			}

			if (delay)
				setTimeout(mount, 0); 
			else if (!breathe(mount)) 
				mount();

			doAuCmds(aucmds);
		} catch (e) {
			zk.mounting = false;
			zk.error('Failed to mount: '+(e.message||e));
			setTimeout(function(){
				throw e;
			},0);				
		}
	},
	
	
	zkx_: function (args, stub, filter) {
		_t0 = jq.now(); 
		args[1] = [stub, filter]; 
		zkx.apply(this, args); 
	},

	
	zkac: function () {
		doAuCmds(arguments);
	},

	
	zkmx: function () {
		zkmb();
		try {
			zkx.apply(window, arguments);
		} finally {
			zkme();
		}
	},

	
	zkmb: function (bindOnly) {
		_mntctx.bindOnly = bindOnly;
		var t = 390 - (jq.now() - _t0);
		zk.startProcessing(t > 0 ? t: 0);
	},
	
	zkme: function () {
		_mntctx.curdt = null;
		_mntctx.bindOnly = false;
	}
  });

})(window);


jq(function() {
	var Widget = zk.Widget,
		_bfUploads = [],
		_reszInf = {},
		_subevts = { 
			onClick: 'doSelect_',
			onRightClick: 'doSelect_',
			onMouseOver: 'doTooltipOver_',
			onMouseOut: 'doTooltipOut_'
		};

	
	zk.copy(zk, {
		
		beforeUnload: function (fn, opts) { 
			if (opts && opts.remove) _bfUploads.$remove(fn);
			else _bfUploads.push(fn);
		}
	});

	function _doEvt(wevt) {
		var wgt = wevt.target;
		if (wgt && !wgt.$weave) {
			var en = wevt.name,
				fn = _subevts[en];
			if (fn) {
				
				if (!zk.ios || (fn != 'doTooltipOver_' && fn != 'doTooltipOut_')) {
					wgt[fn].call(wgt, wevt);
				}
			}
			if (!wevt.stopped && (!wevt.originalEvent || !wevt.originalEvent['zkstopped'])) 
				wgt['do' + en.substring(2) + '_'].call(wgt, wevt);
			if (wevt.domStopped)
				wevt.domEvent.stop();
		}
	}
	
	function _docMouseDown(evt, wgt, noFocusChange) {
		zk.clickPointer[0] = evt.pageX;
		zk.clickPointer[1] = evt.pageY;

		if (!wgt) wgt = evt.target;

		var target = evt.domTarget,
			body = document.body,
			old = zk.currentFocus;
		if ((target != body && target != body.parentNode) ||
				(evt.pageX < body.clientWidth && evt.pageY < body.clientHeight)) 
			
			Widget.mimicMouseDown_(wgt, noFocusChange, evt.which); 
			
		_doEvt(evt);
		
		
		
		if (old && zk.ie < 11) {
			var n = jq(old)[0];
			if (n)
				setTimeout(function () {
					try {
						var cf = zk.currentFocus;
						if (cf != old && !n.offsetWidth && !n.offsetHeight) {
							zk.focusBackFix = true;
							cf.focus();
						}
					} catch (e) { 
					} finally {
						delete zk.focusBackFix;
					}
				});
		}
	}

	function _docResize() {
		if (!_reszInf.time) return; 

		var now = jq.now();
		if (zk.mounting || zk.loading || now < _reszInf.time || zk.animating()) {
			setTimeout(_docResize, 10);
			return;
		}

		_reszInf.time = null; 
		_reszInf.lastTime = now + 1000;
			

		zAu._onClientInfo();

		_reszInf.inResize = true;
		try {
			zWatch.fire('beforeSize'); 
			zWatch.fire('onFitSize', null, {reverse:true}); 
			zWatch.fire('onSize'); 
			_reszInf.lastTime = jq.now() + 8;
		} finally {
			_reszInf.inResize = false;
		}
	}
	
	function _afterKeyDown(wevt) {
		var dts = zk.Desktop.all, Page = zk.Page;
		for (var dtid in dts)
			for (var wgt = dts[dtid].firstChild; wgt; wgt = wgt.nextSibling)
				if (wgt.$instanceof(Page)) {
					for (var w = wgt.firstChild; w; w = w.nextSibling)
						if (_afterKD(w, wevt))
							return;
				} else if (_afterKD(wgt, wevt))
					return; 
	}
	function _afterKD(wgt, wevt) {
		if (!wgt.afterKeyDown_)
			return; 
		wevt.target = wgt; 
		return wgt.afterKeyDown_(wevt,true);
	}

	var lastTimestamp, lastTarget;
	jq(document)
	.keydown(function (evt) {
		var wgt = Widget.$(evt, {child:true}),
			wevt = new zk.Event(wgt, 'onKeyDown', evt.keyData(), null, evt);
		if (wgt) {
			_doEvt(wevt);
			if (!wevt.stopped && wgt.afterKeyDown_) {
				wgt.afterKeyDown_(wevt);
				if (wevt.domStopped)
					wevt.domEvent.stop();
			}
		} else if (zk.invokeFirstRootForAfterKeyDown)
			_afterKeyDown(wevt);

		if (evt.keyCode == 27
		&& (zk._noESC > 0 || zAu.shallIgnoreESC())) 
			return false; 
	})
	.keyup(function (evt) {
		var wgt = zk.keyCapture;
		if (wgt) zk.keyCapture = null;
		else wgt = Widget.$(evt, {child:true});
		_doEvt(new zk.Event(wgt, 'onKeyUp', evt.keyData(), null, evt));
	})
	.keypress(function (evt) {
		var wgt = zk.keyCapture;
		if (!wgt) wgt = Widget.$(evt, {child:true});
		_doEvt(new zk.Event(wgt, 'onKeyPress', evt.keyData(), null, evt));
	})
	.bind('zcontextmenu', function (evt) {
		
		
		
		zk.clickPointer[0] = evt.pageX;
		zk.clickPointer[1] = evt.pageY;

		var wgt = Widget.$(evt, {child:true});
		if (wgt) {
			if (zk.ie < 11)
				evt.which = 3;
			var wevt = new zk.Event(wgt, 'onRightClick', evt.mouseData(), {}, evt);
			_doEvt(wevt);
			if (wevt.domStopped)
				return false;
		}
		return !(zk.ie < 11) || evt.returnValue;
	})
	.bind('zmousedown', function(evt){
		if (zk.mobile) {
			zk.currentPointer[0] = evt.pageX;
			zk.currentPointer[1] = evt.pageY;
		}
		var wgt = Widget.$(evt, {child:true});
		_docMouseDown(
			new zk.Event(wgt, 'onMouseDown', evt.mouseData(), null, evt),
			wgt);
	})
	.bind('zmouseup', function(evt){
		var e = zk.Draggable.ignoreMouseUp(), wgt;
		if (e === true)
			return; 

		if (e != null) {
			_docMouseDown(e, null, true); 

			
			if ((wgt = e.target) && wgt != zk.currentFocus
			&& !zk.Draggable.ignoreStop(wgt.$n()))
				try {wgt.focus();} catch (e) {}
				
		}

		wgt = zk.mouseCapture;
		if (wgt) zk.mouseCapture = null;
		else wgt = Widget.$(evt, {child:true});
		_doEvt(new zk.Event(wgt, 'onMouseUp', evt.mouseData(), null, evt));
	})
	.bind('zmousemove', function(evt){
		zk.currentPointer[0] = evt.pageX;
		zk.currentPointer[1] = evt.pageY;

		var wgt = zk.mouseCapture;
		if (!wgt) wgt = Widget.$(evt, {child:true});
		_doEvt(new zk.Event(wgt, 'onMouseMove', evt.mouseData(), null, evt));
	})
	.mouseover(function (evt) {
		if (zk.mobile) return; 
		zk.currentPointer[0] = evt.pageX;
		zk.currentPointer[1] = evt.pageY;

		_doEvt(new zk.Event(Widget.$(evt, {child:true}), 'onMouseOver', evt.mouseData(), {ignorable:1}, evt));
	})
	.mouseout(function (evt) {
		_doEvt(new zk.Event(Widget.$(evt, {child:true}), 'onMouseOut', evt.mouseData(), {ignorable:1}, evt));
	})
	.click(function (evt) {
		if (zk.Draggable.ignoreClick()) return;
		
		if (zk.android 
				&& (lastTimestamp && lastTimestamp + 400 > evt.timeStamp) 
				&& (lastTarget && lastTarget == evt.target)) { 
			return;
		} else {
			lastTimestamp = evt.timeStamp;
			lastTarget = evt.target;
			
			zjq._fixClick(evt);
			
			if (evt.which == 1)
				_doEvt(new zk.Event(Widget.$(evt, {child:true}),
					'onClick', evt.mouseData(), {}, evt));
			
		}
	})
	.bind('zdblclick', function (evt) {
		if (zk.Draggable.ignoreClick()) return;

		var wgt = Widget.$(evt, {child:true});
		if (wgt) {
			var wevt = new zk.Event(wgt, 'onDoubleClick', evt.mouseData(), {}, evt);
			_doEvt(wevt);
			if (wevt.domStopped)
				return false;
		}
	})
	.bind((document.hidden !== undefined ? '' : zk.vendor_) + 'visibilitychange', function (evt) {
		zAu._onVisibilityChange();
	});
	
	var _sizeHandler = function(evt){
		if (zk.mounting)
			return;

		
		
		
		
		
		
		
		

		var now = jq.now();
		if ((_reszInf.lastTime && now < _reszInf.lastTime) || _reszInf.inResize)
			return; 

		var delay = zk.ie < 11 || zk.android ? 250: 50;
		_reszInf.time = now + delay - 1; 
		setTimeout(_docResize, delay);

		if (zk.mobile && zAu._cInfoReg) {
			if (!jq('#zk_proc').length && !jq('#zk_showBusy').length) {
				zUtl.progressbox('zk_proc', window.msgzk?msgzk.PLEASE_WAIT:'Processing...', true);
			}
		}
	};
	
	if(zk.mobile)
		jq(window).bind('orientationchange', _sizeHandler);
	else
		jq(window).resize(_sizeHandler);

	jq(window).scroll(function () {
		zWatch.fire('onScroll'); 
	})
	.unload(function () {
		zk.unloading = true; 

		
		if (zk.ie || !zk.rmDesktoping) {
			rmDesktop();
		}
	});
	
	function rmDesktop () {
		
		
		
		
		var bRmDesktop = !zk.opera && !zk.keepDesktop;
		if (bRmDesktop || zk.pfmeter) {
			zk.rmDesktoping = true;
			try {
				var dts = zk.Desktop.all;
				for (var dtid in dts)
					zAu._rmDesktop(dts[dtid], !bRmDesktop);
			} catch (e) { 
			}
		}
	};

	var _oldBfUnload = window.onbeforeunload;
	window.onbeforeunload = function () {
		if (!zk.skipBfUnload) {
			if (zk.confirmClose)
				return zk.confirmClose;

			for (var j = 0; j < _bfUploads.length; ++j) {
				var s = _bfUploads[j]();
				if (s) return s;
			}
		}

		if (_oldBfUnload) {
			var s = _oldBfUnload.apply(window, arguments);
			if (s) return s;
		}

		zk.unloading = true; 
		
		
		if (!zk.ie) {
			rmDesktop();
		}
		
	};

	zk.afterMount(function(){jq('script.z-runonce').remove();});
		
		
}); 


zk.bmk = (function () { 
	var _curbk = '', _initbk = '';

	function getBookmark() {
		var nm = location.hash,
			j = nm.indexOf('#');
		nm = j >= 0 ? decodeURIComponent(nm.substring(j + 1)): '';
		return nm || _initbk;
	}
	
	function checkBookmark() {
		var nm = getBookmark();
		if (nm != _curbk) {
			_curbk = nm;
			zAu.send(new zk.Event(null, 'onBookmarkChange', nm), 50);
			zk.bmk.onURLChange();
		}
	}
	function _simplifyURL(url) {
		var j = url.lastIndexOf(';');
		if (j >= 0) url = url.substring(0, j);
		j = url.lastIndexOf('#');
		if (j >= 0) url = url.substring(0, j);
		j = url.lastIndexOf('?');
		if (j >= 0) url = url.substring(0, j);
		return url;
	}
	function _toHash(nm, hashRequired) {
		nm = encodeURIComponent(nm);
		return (!hashRequired && zk.webkit) || !nm ? nm: '#' + nm;
	}
	function _bookmark(nm, replace) {
		if (_curbk != nm) {
			var oldnm = _curbk;
			_curbk = nm; 

			if (replace)
				location.replace(location.href.replace(/#.*/, '') + _toHash(nm, true));
			else
				location.hash = _toHash(nm);
			zk.bmk.onURLChange();
		}
	}

	var _startCheck = function () {
		_startCheck = null;
		checkBookmark();
		setInterval(checkBookmark, 250);
			
			
	};
	zk._apac(_startCheck); 

  return {
	
	bookmark: function (nm, replace) {
		if (_startCheck)
			_curbk = _initbk = nm;
		else
			(zk.bmk.bookmark = _bookmark)(nm, replace);
	},
	
	onIframeLoaded: zk.ie < 11 ? function (src) {
		var j = src.indexOf('?'),
			nm = j >= 0 ? src.substring(j + 1): '';
		location.hash = nm ?  '#' + nm: '';
		checkBookmark();
	}: zk.$void,

	
	onURLChange: function () { 
		try {
			var ifr = window.frameElement;
			if (!parent || parent == window || !ifr) 
				return;

			var l0 = parent.location, l1 = location,
				url = l0.protocol != l1.protocol || l0.host != l1.host
				|| l0.port != l1.port ? l1.href: l1.pathname,
				j = url.lastIndexOf(';'), k = url.lastIndexOf('?');
			if (j >= 0 && (k < 0 || j < k)) {
				var s = url.substring(0, j);
				url = k < 0 ? s: s + url.substring(k);
			}
			if (l1.hash && '#' != l1.hash) url += l1.hash;

			var $ifr = jq(ifr);
			if ($ifr.attr('z_xsrc') != ifr.src) {
				var ifrsrc = ifr.src, loc = location.pathname;
				$ifr.attr('z_xsrc', ifrsrc);

			
			
			
			
			
			
				ifrsrc = _simplifyURL(ifrsrc);
				loc = _simplifyURL(loc);
				if (ifrsrc.endsWith(loc)
				|| loc.endsWith(ifrsrc)) { 
					$ifr.attr('z_xurl', url);
					return; 
				}
			}

			if (parent.onIframeURLChange && $ifr.attr('z_xurl') != url) {
				parent.onIframeURLChange(ifr.id, url);
				$ifr.attr('z_xurl', url);
			}
		} catch (e) { 

		}
	}
  };
})();


(function () {
	var _errURIs = {}, _errCode,
		_perrURIs = {}, 
		_onErrs = [], 
		cmdsQue = [], 
		ajaxReq, ajaxReqInf, pendingReqInf, ajaxReqTries,
		sendPending, ctlUuid, ctlTime, ctlCmd, responseId,
		seqId = (jq.now() % 9999) + 1, 
		doCmdFns = [],
		idTimeout, 
		pfIndex = 0, 
		_detached = [], 
		Widget = zk.Widget,
		_portrait = {'0': true, '180': true}, 
		_initLandscape = jq.innerWidth() > jq.innerHeight(), 
		_initDefault = _portrait[window.orientation]; 
	
	
	function checkProgressing() {
		if (!zAu.processing()) {
			_detached = []; 
			if (!zk.clientinfo)
				zk.endProcessing();
				
				
				

			zAu.doneTime = jq.now();
		}
	}
	function pushReqCmds(reqInf, req) {
		var dt = reqInf.dt,
			rt = req.responseText;
		if (!rt) {
			if (zk.pfmeter) zAu._pfdone(dt, pfGetIds(req));
			return false; 
		}

		var cmds = [];
		cmds.rtags = reqInf.rtags;
		if (zk.pfmeter) {
			cmds.dt = dt;
			cmds.pfIds = pfGetIds(req);
		}

		rt = jq.evalJSON(rt);
		var	rid = rt.rid;
		if (rid) {
			rid = parseInt(rid); 
			if (!isNaN(rid)) cmds.rid = rid;
		}

		pushCmds(cmds, rt.rs);
		return true;
	}
	function pushCmds(cmds, rs) {
		for (var j = 0, rl = rs ? rs.length: 0; j < rl; ++j) {
			var r = rs[j],
				cmd = r[0],
				data = r[1];

			if (!cmd) {
				zAu.showError('ILLEGAL_RESPONSE', 'command required');
				continue;
			}

			cmds.push({cmd: cmd, data: data || []});
		}

		cmdsQue.push(cmds);
	}
	function dataNotReady(cmd, data) {
		for (var j = data.length, id, w; j--;)
			if (id = data[j] && data[j].$u) {
				if (!(w = Widget.$(id))) { 
					zk.afterMount(function () {
						do
							if (id = data[j] && data[j].$u)
								data[j] = Widget.$(id);
						while (j--)
						doProcess(cmd, data);
					}, -1);
					return true; 
				}
				data[j] = w;
			}
	}
	function doProcess(cmd, data) { 
		if (!dataNotReady(cmd, data)) {
			
			var fn = zAu.cmd1[cmd];
			if (fn) {
				if (!data.length)
					return zAu.showError('ILLEGAL_RESPONSE', 'uuid required', cmd);

				data[0] = Widget.$(data[0]); 
			} else {
				
				fn = zAu.cmd0[cmd];
				if (!fn)
					return zAu.showError('ILLEGAL_RESPONSE', 'Unknown', cmd);
			}
			fn.apply(zAu, data);
		}
	}

	function ajaxReqResend(reqInf, timeout) {
		if (seqId == reqInf.sid) {
			pendingReqInf = reqInf; 
			setTimeout(ajaxReqResend2, timeout ? timeout: 0);
		}
	}
	function ajaxReqResend2() {
		var reqInf = pendingReqInf;
		if (reqInf) {
			pendingReqInf = null;
			if (seqId == reqInf.sid)
				ajaxSendNow(reqInf);
		}
	}
	function onError(req, errCode) {
		
		for (var errs = _onErrs.$clone(), fn; fn = errs.shift();)
			if (fn(req, errCode))
				return true; 
	}
	
	function onResponseReady() {
		var req = ajaxReq, reqInf = ajaxReqInf;
		try {
			if (req && req.readyState == 4) {
				ajaxReq = ajaxReqInf = null;
				if (zk.pfmeter) zAu._pfrecv(reqInf.dt, pfGetIds(req));

				var sid = req.getResponseHeader('ZK-SID'), rstatus;
				if ((rstatus = req.status) == 200) { 
					if (sid && sid != seqId) {
						_errCode = 'ZK-SID ' + (sid ? 'mismatch': 'required');
						afterResponse(); 
						return;
					} 

					var v;
					if ((v = req.getResponseHeader('ZK-Error'))
					&& !onError(req, v = zk.parseInt(v)||v)
					&& (v == 5501 || v == 5502) 
					&& zAu.confirmRetry('FAILED_TO_RESPONSE',
							v == 5501 ? 'Request out of sequence': 'Activation timeout')) {
						ajaxReqResend(reqInf);
						return;
					}
					if (v != 410) 
						zAu._resetTimeout();

					if (pushReqCmds(reqInf, req)) { 
						
						if (sid && ++seqId > 9999) seqId = 1;
						ajaxReqTries = 0;
						pendingReqInf = null;
					}
				} else if ((!sid || sid == seqId) 
				&& !onError(req, _errCode = rstatus)) {
					var eru = _errURIs['' + rstatus];
					if (typeof eru == 'string') {
						zUtl.go(eru);
						return;
					}
                    
                    if (typeof zAu.ajaxErrorHandler == 'function') {
                        ajaxReqTries = zAu.ajaxErrorHandler(req, rstatus, req.statusText, ajaxReqTries);
                        if (ajaxReqTries > 0) {
                            ajaxReqTries--;
                            ajaxReqResend(reqInf, zk.resendTimeout);
                            return;
                        }
                    } else {
    					
    					
    					switch (rstatus) { 
    					default:
    						if (!ajaxReqTries) break;
    						
    					case 12002: 
    					case 12030: 
    					case 12031:
    					case 12152: 
    					case 12159:
    					case 13030:
    					case 503: 
    						if (!ajaxReqTries) ajaxReqTries = 3; 
    						if (--ajaxReqTries) {
    							ajaxReqResend(reqInf, zk.resendTimeout);
    							return;
    						}
    					}
    
    					if (!reqInf.ignorable && !zk.unloading) {
    						var msg = req.statusText;
    						if (zAu.confirmRetry('FAILED_TO_RESPONSE', rstatus+(msg?': '+msg:''))) {
    							ajaxReqTries = 2; 
    							ajaxReqResend(reqInf);
    							return;
    						}
					   }
					}
				}
			}
		} catch (e) {
			if (!window.zAu)
				return; 

			ajaxReq = ajaxReqInf = null;
			try {
				if(req && typeof req.abort == 'function') req.abort();
			} catch (e2) {
			}

			
			
			if (reqInf && !reqInf.ignorable && !zk.unloading) {
				var msg = _exmsg(e);
				_errCode = '[Receive] ' + msg;
				
				
				if (zAu.confirmRetry('FAILED_TO_RESPONSE', (msg&&msg.indexOf('NOT_AVAILABLE')<0?msg:''))) {
					ajaxReqResend(reqInf);
					return;
				}
			}
		}

		afterResponse();
	}
	function afterResponse() {
		zAu._doCmds(); 

		
		if (sendPending && !ajaxReq && !pendingReqInf) {
			sendPending = false;
			var dts = zk.Desktop.all;
			for (var dtid in dts)
				ajaxSend2(dts[dtid], 0);
		}
	}
	function _exmsg(e) {
		var msg = e.message||e, m2 = '';
		if (e.name) m2 = ' ' +e.name;



		return msg + (m2 ? ' (' + m2.substring(1) + ')': m2);
	}

	function ajaxSend(dt, aureq, timeout) {
		
		
		if (!dt) {
			
			var wgt = aureq.target.parent;
			while(!wgt.desktop){
				wgt = wgt.parent;
			}
			dt = wgt.desktop;			
		}
		
		zAu.addAuRequest(dt, aureq);

		ajaxSend2(dt, timeout);
			
	}
	function ajaxSend2(dt, timeout) {
		if (!timeout) timeout = 0;
		if (dt && timeout >= 0)
			setTimeout(function(){zAu.sendNow(dt);}, timeout);
	}
	function ajaxSendNow(reqInf) {
		var setting = zAu.ajaxSettings,
			req = setting.xhr();
		zAu.sentTime = jq.now(); 
		try {
			req.onreadystatechange = onResponseReady;
			req.open('POST', reqInf.uri, true);
			req.setRequestHeader('Content-Type', setting.contentType);
			req.setRequestHeader('ZK-SID', reqInf.sid);
			if (_errCode) {
				req.setRequestHeader('ZK-Error-Report', _errCode);
				_errCode = null;
			}

			if (zk.pfmeter) zAu._pfsend(reqInf.dt, req);

			ajaxReq = req;
			ajaxReqInf = reqInf;
			
			req.send(reqInf.content);

			if (!reqInf.implicit)
				zk.startProcessing(zk.procDelay); 
		} catch (e) {
			
			try {
				if(typeof req.abort == 'function') req.abort();
			} catch (e2) {
			}

			if (!reqInf.ignorable && !zk.unloading) {
				var msg = _exmsg(e);
				_errCode = '[Send] ' + msg;
				if (zAu.confirmRetry('FAILED_TO_SEND', msg)) {
					ajaxReqResend(reqInf);
					return;
				}
			}
		}
	}
	
	function toJSON(target, data) {
		if (!jq.isArray(data)) {
			if (data.pageX != null && data.x == null)  {
				var ofs = target && target.desktop ? 
						target.fromPageCoord(data.pageX, data.pageY):
						[data.pageX, data.pageY];
				data.x = ofs[0];
				data.y = ofs[1];
			}

			var v;
			for (var n in data)
				if (jq.type(v = data[n]) == 'date')
					data[n] = '$z!t#d:' + jq.d2j(v);
		}
		return jq.toJSON(data);
	}

	function doCmdsNow(cmds) {
		var rtags = cmds.rtags||{}, ex;
		try {
			while (cmds && cmds.length) {
				if (zk.mounting) return false;

				var cmd = cmds.shift();
				try {
					doProcess(cmd.cmd, cmd.data);
				} catch (e) {
					zk.mounting = false; 
					zAu.showError('FAILED_TO_PROCESS', null, cmd.cmd, e);
					if (!ex) ex = e;
				}
			}
		} finally {
		
			if (!cmds || !cmds.length) {
				
				zWatch.fire('onCommandReady', null, {timeout:-1, rtags: rtags}); 

				zWatch.fire('onResponse', null, {timeout:0, rtags: rtags}); 
				if (rtags.onClientInfo) {
					setTimeout(zk.endProcessing, 50); 
					delete zk.clientinfo;
				}
					
			}
		}
		if (ex)
			throw ex;
		return true;
	}
	function _asBodyChild(child) {
		jq(document.body).append(child);
	}

	
	
	function pfGetIds(req) {
		return req.getResponseHeader('ZK-Client-Complete');
	}
	function pfAddIds(dt, prop, pfIds) {
		if (pfIds && (pfIds = pfIds.trim())) {
			var s = pfIds + '=' + Math.round(jq.now());
			if (dt[prop]) dt[prop] += ',' + s;
			else dt[prop] = s;
		}
	}

	
	function fireClientInfo() {
		zAu.cmd0.clientInfo();
	}
	function sendTimeout() {
		zAu.send(new zk.Event(null, 'dummy', null, {ignorable: true, serverAlive: true}));
			
	}

	
	function _wgt2map(wgt, map) {
		map[wgt.uuid] = wgt;
		for (wgt = wgt.firstChild; wgt; wgt = wgt.nextSibling)
			_wgt2map(wgt, map);
	}

	function _beforeAction(wgt, actnm) {
		var act;
		if (wgt._visible && (act = wgt.actions_[actnm])) {
			wgt.z$display = 'none'; 
			return act;
		}
	}
	function _afterAction(wgt, act) {
		if (act) {
			delete wgt.z$display;
			act[0].call(wgt, wgt.$n(), act[1]);
			return true;
		}
	}


zAu = {
	_resetTimeout: function () { 
		if (idTimeout) {
			clearTimeout(idTimeout);
			idTimeout = null;
		}
		if (zk.timeout > 0)
			idTimeout = setTimeout(sendTimeout, zk.timeout * 1000);
  	},
	_onClientInfo: function () { 
		if (zAu._cInfoReg) setTimeout(fireClientInfo, 20);
			
			
			
	},
	
	_wgt$: function (uuid) {
		var map = _detached.wgts = _detached.wgts || {}, wgt;
		while (wgt = _detached.shift())
			_wgt2map(wgt, map);
		return map[uuid];
	},
	_onVisibilityChange: function () { 
		if (zk.visibilitychange) zAu.cmd0.visibilityChange();
	},
	
	_storeStub: function (wgt) {
		if (wgt)
			_detached.push(wgt);
	},
	
	
	onError: function (fn) {
		_onErrs.push(fn);
	},
	
	unError: function (fn) {
		_onErrs.$remove(fn);
	},

	
	confirmRetry: function (msgCode, msg2) {
		var msg = msgzk[msgCode];
		return jq.confirm((msg?msg:msgCode)+'\n'+msgzk.TRY_AGAIN+(msg2?'\n\n('+msg2+')':''));
	},
	
	showError: function (msgCode, msg2, cmd, ex) {
		var msg = msgzk[msgCode];
		zk.error((msg?msg:msgCode)+'\n'+(msg2?msg2+': ':'')+(cmd||'')
			+ (ex?'\n'+_exmsg(ex):''));
	},
	
	getErrorURI: function (code) {
		return _errURIs['' + code];
	},
	
	
	setErrorURI: function (code, uri) {
		if (arguments.length == 1) {
			for (var c in code)
				zAu.setErrorURI(c, code[c]);
		} else
			_errURIs['' + code] = uri;
	},
	
	getPushErrorURI: function (code) {
		return _perrURIs['' + code];
	},
	
	
	setPushErrorURI: function (code, uri) {
		if (arguments.length == 1) {
			for (var c in code)
				zAu.setPushErrorURI(c, code[c]);
			return;
		}
		_perrURIs['' + code] = uri;
	},

	
	
	processing: function () {
		return zk.mounting || cmdsQue.length || ajaxReq || pendingReqInf;
	},

	
	send: function (aureq, timeout) {
		if (timeout < 0)
			aureq.opts = zk.copy(aureq.opts, {defer: true});

		var t = aureq.target;
		if (t) {
			ajaxSend(t.className == 'zk.Desktop' ? t: t.desktop, aureq, timeout);
		} else {
			var dts = zk.Desktop.all;
			for (var dtid in dts)
				ajaxSend(dts[dtid], aureq, timeout);
		}
	},
	
	sendAhead: function (aureq, timeout) {
		var t = aureq.target;
		if (t) {
			var dt = t.className == 'zk.Desktop' ? t: t.desktop;
			zAu.getAuRequests(dt).unshift(aureq);
			ajaxSend2(dt, timeout);
		} else {
			var dts = zk.Desktop.all;
			for (var dtid in dts) {
				zAu.getAuRequests(dt).unshift(aureq);
				ajaxSend2(dts[dtid], timeout);
			}
			return;
		}
	},

	
	_rmDesktop: function (dt, dummy) {
		jq.ajax(zk.$default({
			url: zk.ajaxURI(null, {desktop:dt,au:true}),
			data: {dtid: dt.id, cmd_0: dummy ? 'dummy': 'rmDesktop', opt_0: 'i'},
			beforeSend: function (xhr) {
				if (zk.pfmeter) zAu._pfsend(dt, xhr, true);
			},
			
			
			
			async: !!zk.ie 
				
		}, zAu.ajaxSettings), null, true);
		
		
		if (!dummy && zk.portlet2Data && zk.portlet2Data[dt.id]) {
			delete zk.portlet2Data[dt.id];
		}
	},

	
	
	process: function (cmd, data) {
		doProcess(cmd, data ? jq.evalJSON(data): []);
	},
	
	shallIgnoreESC: function () {
		return ajaxReq;
	},
	
	doCmds: function (dtid, rs) {
		var cmds = [];
		cmds.dt = zk.Desktop.$(dtid);
		pushCmds(cmds, rs);
		zAu._doCmds();
	},
	_doCmds: function () { 
		for (var fn; fn = doCmdFns.shift();)
			fn();

		var ex, j = 0, rid = responseId;
		for (; j < cmdsQue.length; ++j) {
			if (zk.mounting) return; 

			var cmds = cmdsQue[j];
			if (rid == cmds.rid || !rid || !cmds.rid 
			|| zk.Desktop._ndt > 1) { 
				cmdsQue.splice(j, 1);

				var oldrid = rid;
				if (cmds.rid) {
					if ((rid = cmds.rid + 1) >= 1000)
						rid = 1; 
					responseId = rid;
				}

				try {
					if (doCmdsNow(cmds)) { 
						j = -1; 
						if (zk.pfmeter) {
							var fn = function () {zAu._pfdone(cmds.dt, cmds.pfIds);};
							if (zk.mounting) doCmdFns.push(fn);
							else fn();
						}
					} else { 
						responseId = oldrid; 
						cmdsQue.splice(j, 0, cmds); 
						return; 
					}
				} catch (e) {
					if (!ex) ex = e;
					j = -1; 
				}
			}
		}

		if (cmdsQue.length) { 
			setTimeout(function () {
				if (cmdsQue.length && rid == responseId) {
					var r = cmdsQue[0].rid;
					for (j = 1; j < cmdsQue.length; ++j) { 
						var r2 = cmdsQue[j].rid,
							v = r2 - r;
						if (v > 500 || (v < 0 && v > -500)) r = r2;
					}
					responseId = r;
					zAu._doCmds();
				}
			}, 3600);
		} else
			checkProgressing();

		if (ex) throw ex;
	},

	
	beforeSend: function (uri, aureq) {
		var target, tag;
		if ((target = aureq.target) && (tag = target.autag)) {
			tag = '/' + encodeURIComponent(tag);
			if (uri.indexOf('/_/') < 0) {
				var v = target.desktop;
				if ((v = v ? v.requestPath: "") && v.charAt(0) != '/')
					v = '/' + v; 
				tag = '/_' + v + tag;
			}

			var j = uri.lastIndexOf(';');
			if (j >= 0) uri = uri.substring(0, j) + tag + uri.substring(j);
			else uri += tag;
		}
		return uri;
	},
	
	encode: function (j, aureq, dt) {
		var target = aureq.target,
			opts = aureq.opts||{},
			portlet2Namespace = '';
			
		
		if(zk.portlet2Data && zk.portlet2Data[dt.id]) {
			portlet2Namespace = zk.portlet2Data[dt.id].namespace || '';
		}
		var content = j ? '': portlet2Namespace + 'dtid='+dt.id;

		content += '&' + portlet2Namespace + 'cmd_'+j+'='+aureq.name;
		if ((opts.implicit || opts.ignorable) && !(opts.serverAlive))
			content += '&' + portlet2Namespace + 'opt_'+j+'=i';
			

		if (target && target.className != 'zk.Desktop')
			content += '&' + portlet2Namespace + 'uuid_'+j+'='+target.uuid;

		var data = aureq.data, dtype = typeof data;
		if (dtype == 'string' || dtype == 'number' || dtype == 'boolean'
		|| jq.isArray(data))
			data = {'':data};
		if (data)
			content += '&' + portlet2Namespace + 'data_'+j+'='+encodeURIComponent(toJSON(target, data));
		return content;
	},

	
	sendNow: function (dt) {
		if (zAu.disabledRequest) {
			return false;
		}
		var es = zAu.getAuRequests(dt);
		if (es.length == 0)
			return false;

		if (zk.mounting) {
			zk.afterMount(function(){zAu.sendNow(dt);});
			return true; 
		}

		if (ajaxReq || pendingReqInf) { 
			sendPending = true;
			return true;
		}

		
		var implicit, uri;
		for (var j = 0, el = es.length; j < el; ++j) {
			var aureq = es[j],
				opts = aureq.opts||{};
			if (opts.uri != uri) {
				if (j) break;
				uri = opts.uri;
			}

			
			if (!(implicit = opts.ignorable || opts.implicit || opts.defer))
				break;
		}

		
		try {
			zWatch.fire('onSend', null, implicit);
		} catch (e) {
			zAu.showError('FAILED_TO_SEND', null, null, e);
		}

		
		var ignorable = true;
		for (var j = 0, el = es.length; j < el; ++j) {
			var aureq = es[j],
				opts = aureq.opts||{};
			if ((opts.uri != uri)
			|| !(ignorable = ignorable && opts.ignorable)) 
				break;
		}
		
		var content = '', rtags = {},
			requri = uri || zk.ajaxURI(null, {desktop:dt,au:true});
		for (var j = 0, el = es.length; el; ++j, --el) {
			var aureq = es.shift();
			if ((aureq.opts||{}).uri != uri) {
				es.unshift(aureq);
				break;
			}

			requri = zAu.beforeSend(requri, aureq, dt);
			content += zAu.encode(j, aureq, dt);
			zk.copy(rtags, (aureq.opts||{}).rtags);
		}
		
		
		if(zk.portlet2Data && zk.portlet2Data[dt.id]) {
			requri = zk.portlet2Data[dt.id].resourceURL;
		}
		
		
			
		if (content)
			ajaxSendNow({
				sid: seqId, uri: requri, dt: dt, content: content,
				implicit: implicit, 
				ignorable: ignorable, tmout: 0, rtags: rtags
			});
		return true;
	},
	
	addAuRequest: function (dt, aureq) {
		dt._aureqs.push(aureq);
	},
	
	getAuRequests: function (dt) {
		return dt._aureqs;
	},
	
	ajaxSettings: zk.$default({
		global: false,
		
		contentType: 'application/x-www-form-urlencoded;charset=UTF-8'
	}, jq.ajaxSettings),

	
	
	_pfrecv: function (dt, pfIds) {
		pfAddIds(dt, '_pfRecvIds', pfIds);
	},
	
	
	_pfdone: function (dt, pfIds) {
		pfAddIds(dt, '_pfDoneIds', pfIds);
	},
	
	
	_pfsend: function (dt, req, completeOnly) {
		if (!completeOnly)
			req.setRequestHeader('ZK-Client-Start',
				dt.id + '-' + pfIndex++ + '=' + Math.round(jq.now()));

		var ids;
		if (ids = dt._pfRecvIds) {
			req.setRequestHeader('ZK-Client-Receive', ids);
			dt._pfRecvIds = null;
		}
		if (ids = dt._pfDoneIds) {
			req.setRequestHeader('ZK-Client-Complete', ids);
			dt._pfDoneIds = null;
		}
	},

	
	createWidgets: function (codes, fn, filter) {
		
		var wgts = [], len = codes.length;
		if (len > 0) {
			for (var j = 0; j < len; ++j)
				zkx_(codes[j], function (newwgt) {
					wgts.push(newwgt);
					if (wgts.length == len)
						fn(wgts);
				}, filter);
		} else
			fn(wgts);
	},

	
	wrongValue_: function(wgt, msg) {
		if (msg !== false)
			jq.alert(msg);
	}

	
	
	
	
};



    
    




zAu.cmd0 =  { 
	
	bookmark: function (bk, replace) {
		zk.bmk.bookmark(bk, replace);
	},
	
	obsolete: function (dtid, msg) {
		if (msg.startsWith('script:'))
			return $eval(msg.substring(7));

		
		if(zk._isReloadingInObsolete)
			return;
		
		var v = zk.Desktop.$(dtid);
		if (v && (v = v.requestPath))
			msg = msg.replace(dtid, v + ' (' + dtid + ')');

		zAu.disabledRequest = true;
		
		jq.alert(msg, {
			icon: 'ERROR',
			button: {
				Reload: function () {
					zk._isReloadingInObsolete = true;
					location.reload();
				},
				Cancel: true
			}
		});
	},
	
	alert: function (msg, title, icon, disabledAuRequest) {
		if (disabledAuRequest)
			zAu.disabledRequest = true;
		jq.alert(msg, {icon: icon||'ERROR', title: title});
	},
	
	redirect: function (url, target) {
		try {
			zUtl.go(url, {target: target});
		} catch (ex) {
			if (!zk.confirmClose) throw ex;
		}
	},
	
	title: function (title) {
		document.title = title;
	},
	
	log: zk.log,
	
	script: function (script) {
		jq.globalEval(script);
	},
	
	echo: function (dtid) {
		var dt = zk.Desktop.$(dtid),
			aureqs = zAu.getAuRequests(dt);
		
		for (var i = 0, j = aureqs.length; i < j; i++) {
	 		var aureq0 = aureqs[i];
	 		if ((!aureq0.target || aureq0.target.$instanceof(zk.Desktop)) && aureq0.name == 'dummy') {
	 			return; 
	 		}
	 	}
		zAu.send(new zk.Event(dt, 'dummy', null, {ignorable: true}));
	},
	
	

	
	clientInfo: function (dtid) {
		zAu._cInfoReg = true;
		var orient = '',
			dpr = 1;
		
		if (zk.mobile) {
			
			if ((_initLandscape && _initDefault) || (!_initLandscape && !_initDefault))
				_portrait = {'-90': true, '90': true};
			
			orient = _portrait[window.orientation] ? 'portrait' : 'landscape';
		} else {
			orient = jq.innerWidth() > jq.innerHeight() ? 'landscape' : 'portrait';
		}
		
		if (window.devicePixelRatio)
			dpr = window.devicePixelRatio;
		
		zAu.send(new zk.Event(zk.Desktop.$(dtid), 'onClientInfo', 
			[new Date().getTimezoneOffset(),
			screen.width, screen.height, screen.colorDepth,
			jq.innerWidth(), jq.innerHeight(), jq.innerX(), jq.innerY(), dpr.toFixed(1), orient],
			{implicit:true, rtags: {onClientInfo: 1}}));
	},
	visibilityChange: function (dtid) {
		var hidden = document.hidden || document[zk.vendor_ + 'Hidden'],
			visibilityState = document.visibilityState || document[zk.vendor_ + 'VisibilityState'];
		
		zAu.send(new zk.Event(zk.Desktop.$(dtid), 'onVisibilityChange',
			{hidden: hidden, visibilityState: visibilityState}, {implicit: true, ignorable: true}));
	},
	
	download: function (url) {
		if (url) {
			var ifr = jq('#zk_download')[0];
			if (ifr) {
				ifr.src = url; 
			} else {
				var html = '<iframe src="'+url
				+'" id="zk_download" name="zk_download" style="display:none;width:0;height:0;border:0" frameborder="0"></iframe>';
				jq(document.body).append(html);
			}
		}
	},
	
	print: function () {
		window.print();
	},
	
	scrollBy: function (x, y) {
		window.scrollBy(x, y);
	},
	
	scrollTo: function (x, y) {
		window.scrollTo(x, y);
	},
	
	resizeBy: function (x, y) {
		window.resizeBy(x, y);
	},
	
	resizeTo: function (x, y) {
		window.resizeTo(x, y);
	},
	
	moveBy: function (x, y) {
		window.moveBy(x, y);
	},
	
	moveTo: function (x, y) {
		window.moveTo(x, y);
	},
	
	cfmClose: function (msg) {
		zk.confirmClose = msg;
	},
	
	showNotification: function (msg, type, pid, ref, pos, off, dur, closable) {
		var notif = (zul && zul.wgt) ? zul.wgt.Notification : null; 
		if (notif) {
			notif.show(msg, pid, {ref:ref, pos:pos, off:off, dur:dur, type:type, closable:closable});
		} else {
			
			jq.alert(msg); 
		}
	},
	
	
	showBusy: function (uuid, msg) {
		if (arguments.length == 1) {
			msg = uuid;
			uuid = null;
		}

		zAu.cmd0.clearBusy(uuid);

		var w = uuid ? Widget.$(uuid): null;
		if (!uuid)
			zUtl.progressbox('zk_showBusy', msg || msgzk.PLEASE_WAIT, true, null, {busy:true});
		else if (w) {
			w.effects_.showBusy = new zk.eff.Mask( {
				id: w.uuid + '-shby',
				anchor: w.$n(),
				message: msg
			});
		}
	},
	
	
	clearBusy: function (uuid) {
		var w = uuid ? Widget.$(uuid): null,
			efs = w ? w.effects_: null;
		if (efs && efs.showBusy) {
			efs.showBusy.destroy();
			delete efs.showBusy;
		}

		if (!uuid)
			zUtl.destroyProgressbox('zk_showBusy', {busy:true}); 
	},
	
	clearWrongValue: function () {
		for (var i = arguments.length; i--;) {
			var wgt = Widget.$(arguments[i]);
			if (wgt)
				if (wgt.clearErrorMessage)
					wgt.clearErrorMessage();
				else
					zAu.wrongValue_(wgt, false);
		}
	},
	
	wrongValue: function () {
		var args = arguments,
			func = function () {
				for (var i = 0, len = args.length - 1; i < len; i += 2) {
					var uuid = args[i], msg = args[i + 1],
						wgt = Widget.$(uuid);
					if (wgt) {
						if (wgt.setErrorMessage) wgt.setErrorMessage(msg);
						else zAu.wrongValue_(wgt, msg);
					} else if (!uuid) 
						jq.alert(msg);
				}
			};
        
		if (this.__delay__) 
			setTimeout(func, 100);
		else
			func();
	},
	
	submit: function (id) {
		setTimeout(function (){
			var n = Widget.$(id);
			if (n && n.submit)
				n.submit();
			else
				zk(id).submit();
		}, 50);
	},
	
	scrollIntoView: function (id) {
		this.__delay__ = setTimeout(function () {
			var w = Widget.$(id);
			if (w) w.scrollIntoView();
			else zk(id).scrollIntoView();
			this.__delay__ = false;
		}, 50);
	}
};

zAu.cmd1 =  {
	
	setAttr: function (wgt, nm, val) {
		if (wgt) { 
			if (nm == 'z$al') { 
				zk.afterLoad(function () {
					for (nm in val)
						wgt.set(nm, val[nm](), true); 
				});
			} else {
				
				wgt.rerenderNow_(null);
				wgt.set(nm, val, true); 
			}
		}
	},
	
	outer: function (wgt, code) {
		zkx_(code, function (newwgt) {
			var act = _beforeAction(newwgt, 'invalidate');
			wgt.replaceWidget(newwgt);
			_afterAction(newwgt, act);
		}, function (wx) {
			for (var w = wx; w; w = w.parent)
				if (w == wgt)
					return null; 
			return wx;
		});
	},
	
	
	addAft: function (wgt) {
		for (var args = arguments, j = args.length; --j;)
			zkx_(args[j], function (child) {
				var p = wgt.parent,
					act = _beforeAction(child, 'show');
				if (p) {
					p.insertBefore(child, wgt.nextSibling);
					if (p.$instanceof(zk.Desktop))
						_asBodyChild(child);
				} else {
					var n = wgt.$n();
					if (n)
						jq(n).after(child, wgt.desktop);
					else
						_asBodyChild(child);
				}
				if (!_afterAction(child, act) && !child.z_rod)
					zUtl.fireSized(child);
			});
	},
	
	addBfr: function (wgt) {
		for (var args = arguments, j = 1; j < args.length; ++j)
			zkx_(args[j], function (child) {
				var act = _beforeAction(child, 'show');
				wgt.parent.insertBefore(child, wgt);
				if (!_afterAction(child, act) && !child.z_rod)
					zUtl.fireSized(child);
			});
	},
	
	addChd: function (wgt) {
		for (var args = arguments, j = 1; j < args.length; ++j)
			if (wgt)
				zkx_(args[j], function (child) {
					var act = _beforeAction(child, 'show');
					wgt.appendChild(child);
					if (!_afterAction(child, act) && !child.z_rod)
						zUtl.fireSized(child);
				});
			else 
				zkx_(args[j], _asBodyChild);
	},
	
	rm: function (wgt) {
		if (wgt) {
			wgt.detach();
			_detached.push(wgt); 
		}
	},
	
	uuid: function (wgt, newId) {
		if (wgt)
			zk._wgtutl.setUuid(wgt, newId); 
	},

	
	focus: function (wgt) {
		if (wgt) {
			
			
			setTimeout(function () {
				zk.afterAnimate(function () {
					if (zk.ie9_)
						wgt.focus(100);
					else
						wgt.focus(0); 
				}, -1)});
		}
	},
	
	select: function (wgt, s, e) {
		if (wgt.select) wgt.select(s, e);
	},
	
	invoke: function (wgt, func) {
		var args = [];
		for (var j = arguments.length; --j > 1;) 
			args.unshift(arguments[j]);
		if (wgt)
			wgt[func].apply(wgt, args);
		else {
			var fn = zk.$import(func);
			if (!fn) zk.error('not found: '+func);
			fn.apply(null, args);
		}
	},
	
	echo2: function (wgt, evtnm, data) {
		zAu.send(new zk.Event(wgt, 'echo',
			data != null ? [evtnm, data]: [evtnm], {ignorable: true}));
	},
	
	resizeWgt: function (wgt) {
		zUtl.fireSized(wgt, 1); 
	}
};
})();

function onIframeURLChange(uuid, url) { 
	if (!zk.unloading) {
		var wgt = zk.Widget.$(uuid);
		if (wgt) wgt.fire('onURIChange', url);
	}
};


(function () {
	function _getTextSize(zkc, zkp, zkpOffset) {
		var $zkc = zkc.jq,
			$prev = $zkc.prev(),
			pos = [0, 0],
			coldVal,
			poldVal,
			zs, ps;
		if ($prev.length) {
			ps = $prev[0].style;
			
			if (!zk($prev[0]).isRealVisible()) 
				return pos;
			else {
				zs = $zkc[0].style;
				
				coldVal = {};
				poldVal = {};
				for (var margins = ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'],
						len = margins.length; len-- > 0;) {
					coldVal[margins[len]] = zs[margins[len]];
					poldVal[margins[len]] = ps[margins[len]];

					
					zs[margins[len]] = ps[margins[len]] = '0px';
				}
				
				var offset = $prev.zk.revisedOffset();
				pos[0] = offset[0] + $prev.zk.offsetWidth();
				pos[1] = offset[1] + $prev.zk.offsetHeight();
			}
		} else {
			pos[0] = zkpOffset[0] + zkp.sumStyles('l', jq.paddings) + zkp.sumStyles('l', jq.borders);
			pos[1] = zkpOffset[1] + zkp.sumStyles('t', jq.paddings) + zkp.sumStyles('t', jq.borders);
		}
	
		
		var offset = zkc.revisedOffset();
		pos[0] = offset[0] - pos[0];
		pos[1] = offset[1] - pos[1];
		
		
		zk.copy(zs, coldVal);
		zk.copy(ps, poldVal);
			
		return [Math.max(0, pos[0]), Math.max(0, pos[1])]; 
	}
	
	
	
	function _isSameBaseline(ref, cur, vertical) {
		if (vertical) {
			var hgh = ref._hgh || (ref._hgh = ref.top + ref.height),
				wdh = ref._wdh || (ref._wdh = ref.left + ref.width);
			return !(zk.ie == 10) ? cur.top >= hgh || cur.left < wdh : 
				Math.round(cur.top) >= hgh || Math.round(cur.left) < wdh;
		} else {
			var hgh = ref._hgh || (ref._hgh = ref.top + ref.height),
				wdh = ref._wdh || (ref._wdh = ref.left + ref.width);
			return !(zk.ie == 10) ? cur.left >= wdh || cur.top < hgh : 
				Math.round(cur.left) >= wdh || Math.round(cur.top) < hgh;
		}
	}

	function _fixMinFlex(isVflex) {
		var flexsz, sizePos, flex, offsetPos, marginPos, maxFlexPos, sumFlexPos,
			index, contentPos;
		if (isVflex) {
			flexsz = '_vflexsz';
			sizePos = 'height';
			flex = '_vflex';
			offsetPos = 'offsetHeight';
			marginPos = 'marginHeight';
			maxFlexPos = '_maxFlexHeight';
			sumFlexPos = '_sumFlexHeight';
			index = 1;
			contentPos = 'getContentEdgeHeight_';
		} else {
			flexsz = '_hflexsz';
			sizePos = 'width';
			flex = '_hflex';
			offsetPos = 'offsetWidth';
			marginPos = 'marginWidth';
			maxFlexPos = '_maxFlexWidth';
			sumFlexPos = '_sumFlexWidth';
			index = 0;
			contentPos = 'getContentEdgeWidth_';
		}
		return function (wgt, wgtn, o, min) {
			if (wgt[flexsz] === undefined) { 
				var cwgt = wgt.firstChild, 
					n = wgtn,
					zkn = zk(n),
					max = 0;

				if (min != null)
					max = min;
				else {
					var map = {};
					map[sizePos] = 'auto';
					wgt.setFlexSize_(map, true);
					var totalsz = 0,
						vmax = 0;
					if (cwgt && cwgt.desktop){ 
						var first = cwgt,
							refDim;
						
						
						while (first && first.ignoreFlexSize_(o))
							first = first.nextSibling;
						
						for (; cwgt; cwgt = cwgt.nextSibling) { 
							if (!cwgt.ignoreFlexSize_(o)) {
								var c = cwgt.$n();
								if (c) { 
									
									var cpos = c.style.position;
									if (cpos == 'absolute' || cpos == 'fixed')
										continue;
									
									var zkc = zk(c),
										sz = 0;
									if (cwgt[flex] == 'min') {
										if (zkc.isVisible()) {
											sz += cwgt[flexsz] === undefined ? zFlex.fixMinFlex(cwgt, c, o) : cwgt[flexsz];
										}
									} else {
										cwgt.beforeParentMinFlex_(o);
										sz += wgt.getChildMinSize_(o, cwgt) 
												+ zkc[marginPos]();
									}
									
									
									if (cwgt[maxFlexPos] && sz > vmax) 
										vmax = sz;
									else if (cwgt[sumFlexPos]) 
										totalsz += sz;
									else if (!cwgt[maxFlexPos] && first != cwgt
											&& _isSameBaseline(refDim || (refDim = zk(first).dimension(true)), zkc.dimension(true), isVflex))
										max += sz;
									else if (sz > max)
										max = sz;
								}
							}
						}
					} else {
						var c = wgtn.firstChild;
						if (c) { 
							
							var isText = c.nodeType == 3,
								ignore = wgt.ignoreChildNodeOffset_(o),
								first = c,
								refDim;
							for(; c; c = c.nextSibling) {
								
								isText = c.nodeType == 3; 
								if (!isText) {
									var cpos = c.style.position;
									if (cpos == 'absolute' || cpos == 'fixed')
										continue;
								}
								
								var zkc = zk(c),
									sz = 0;
								if (ignore) {
									for(var el = c.firstChild; el; el = el.nextSibling) {
										var txt = el && el.nodeType == 3 ? el.nodeValue : null,
											zel;
										if (txt) {
											var dim = zkc.textSize(txt);
											if (dim[1] > sz)
												sz = dim[1];
										} else if ((zel = zk(el)).isVisible()) {
											var s = zel[offsetPos]() + zel[marginPos]();
											if (s > sz)
												sz = s;
										}
									}
								} else {
									if (isText)
										sz = c.nodeValue ? zkn.textSize(c.nodeValue)[index] : 0;
									else {
										sz = zkc[offsetPos]() + zkc[marginPos]();
									}
								}
								if (isText) {
									if (sz > max) 
										max = sz;
								} else  {
									var curDim = zkc.dimension(true);
									if (_isSameBaseline(refDim || (refDim = zk(first).dimension(true)),
											curDim, isVflex)) 
										max += sz;
									else if (sz > max) 
										max = sz;
								}
							}
						} else 
							max = zkn[offsetPos]();
					}
					if (vmax)
						totalsz += vmax;
					if (totalsz > max)
						max = totalsz;
				}

				
				
				var margin = wgt.getMarginSize_(o);
				if (zk.webkit && margin < 0) 
					margin = 0;

				
				
				var map = {},
					n = wgt.$n(), 
					hasChildren = zk.isLoaded('zul.wgt') && wgt.$instanceof(zul.wgt.Caption) && wgt.nChildren > 0,
					size = hasChildren ? zk(wgt.$n('cave'))[offsetPos]() : max;

				map[sizePos] = size + wgt[contentPos](size) + margin;
				var s = wgt.setFlexSize_(map, true);
				sz = {height: n.offsetHeight, width: (s && s.width) || n.offsetWidth};
				if (sz && sz[sizePos] >= 0)
					wgt[flexsz] = sz[sizePos] + margin;
				wgt.afterChildrenMinFlex_(o);
				
				
				
				if (wgt.parent && wgt.parent[flex] != 'min')
					wgt.parent.afterChildMinFlexChanged_(wgt, o);
			}
			return wgt[flexsz];
		}
	}
	var _fixMinVflex = _fixMinFlex(true),
		_fixMinHflex = _fixMinFlex();
	function _zero() {
		return 0;
	}

zFlex = { 
	beforeSize: function (ctl, opts, cleanup) {
		var wgt = this, p;
		if (cleanup)
			wgt.clearCachedSize_();
		
		
		if (!zk.mounting && wgt.isRealVisible()) {
			if (wgt._hflex && wgt._hflex != 'min') {
				wgt.resetSize_('w');
				
				delete wgt._flexFixed;
				if (p = wgt.parent)
					p.afterResetChildSize_('w');
			}
			if (wgt._vflex && wgt._vflex != 'min') {
				wgt.resetSize_('h');
				
				delete wgt._flexFixed;
				if (p = wgt.parent)
					p.afterResetChildSize_('h');
			}
		}
	},
	onSize: function () {
		zFlex.fixFlex(this);
	},
	fixFlex: function (wgt) {
		
		if (wgt._flexFixed || (!wgt._nvflex && !wgt._nhflex)) { 
			delete wgt._flexFixed;
			return;
		}
		
		
		if ((wgt._vflex === undefined || (wgt._vflexsz && wgt._vflex == 'min'))
			&& (wgt._hflex === undefined || (wgt._hflexsz && wgt._hflex == 'min'))) 
			return;

		
		if (!wgt.parent.beforeChildrenFlex_(wgt)) { 
			return;
		}
		wgt._flexFixed = true;
		
		var pretxt = false, 
			vflexs = [],
			vflexsz = 0,
			hflexs = [],
			hflexsz = 0,
			p = wgt.$n().parentNode,
			zkp = zk(p),
			psz = wgt.getParentSize_(p),
			hgh = psz.height,
			wdh = psz.width,
			c = p.firstChild,
			scrWdh;
		
		
		if(zkp.hasVScroll()) 
			wdh -= (scrWdh = jq.scrollbarWidth());
			
		
		if(zkp.hasHScroll()) 
			hgh -= scrWdh || jq.scrollbarWidth();
			
		for (; c; c = c.nextSibling)
			if (c.nodeType != 3) break; 

		for (var zkpOffset; c; c = c.nextSibling) {
			
			if (c.nodeType === 3) { 
				pretxt = true;
				continue;
			}
			
			var cpos = c.style.position;
			if (cpos == 'absolute' || cpos == 'fixed')
				continue;
			
			var zkc = zk(c);
			if (zkc.isVisible(true)) {
				var offhgh = zkc.offsetHeight(),
					offwdh = offhgh > 0 ? zkc.offsetWidth() : 0,
					cwgt = zk.Widget.$(c, {exact: 1});
				
				
				
				if (offwdh == 0 && cwgt && zk.isLoaded('zul.mesh')
						&& cwgt.$instanceof(zul.mesh.HeaderWidget)) {
					
					var hdfaker = cwgt.$n('hdfaker');
					offwdh = hdfaker ? zk.parseInt(hdfaker.style.width) || hdfaker.offsetWidth : 0; 
				}
				
				
				if (pretxt) {
					if (!zkpOffset)
						zkpOffset = zkp.revisedOffset();
					var size = _getTextSize(zkc, zkp, zkpOffset);
					if (!cwgt || !cwgt.isExcludedHflex_()) 
						wdh -= size[0];
					if (!cwgt || !cwgt.isExcludedVflex_()) 
						hgh -= size[1];
				}
				
				if (cwgt && cwgt._nhflex) {
					if (cwgt !== wgt)
						cwgt._flexFixed = true; 
					if (cwgt._hflex == 'min') {
						wdh -= zFlex.fixMinFlex(cwgt, c, 'w');
					} else {
						hflexs.push(cwgt);
						hflexsz += cwgt._nhflex;
					}
				} else if ((!cwgt &&
						
						(!zk.isLoaded('zul.wnd') || !wgt.$instanceof(zul.wnd.Panelchildren))) 
						|| (cwgt && !cwgt.isExcludedHflex_())) {
					wdh -= offwdh;
					wdh -= zkc.marginWidth();
    			}
				
				
				if (cwgt && cwgt._nvflex) {
					if (cwgt !== wgt)
						cwgt._flexFixed = true; 
					if (cwgt._vflex == 'min') {
						hgh -= zFlex.fixMinFlex(cwgt, c, 'h');
					} else {
						vflexs.push(cwgt);
						vflexsz += cwgt._nvflex;
					}
				} else if (!cwgt || !cwgt.isExcludedVflex_()) {
					hgh -= offhgh;
					hgh -= zkc.marginHeight();
				}
				
				pretxt = false;
			}
		}
		
		
		
		var lastsz = hgh = Math.max(hgh, 0);
		for (var j = vflexs.length - 1; j > 0; --j) {
			var cwgt = vflexs.shift(), 
				vsz = cwgt.isExcludedVflex_() ? hgh :
						(cwgt._nvflex * hgh / vflexsz) | 0; 
			cwgt.setFlexSize_({height:vsz});
			cwgt._vflexsz = vsz;
			if (!cwgt.isExcludedVflex_())
				lastsz -= vsz;
		}
		
		if (vflexs.length) {
			var cwgt = vflexs.shift();
			cwgt.setFlexSize_({height:lastsz});
			cwgt._vflexsz = lastsz;
		}
		
		
		var newpsz = wgt.getParentSize_(p);
		if (newpsz.width > psz.width) 
			wdh += (newpsz.width - psz.width); 
		
		
		
		lastsz = wdh = Math.max(wdh, 0);
		for (var j = hflexs.length - 1; j > 0; --j) {
			var cwgt = hflexs.shift(), 
				hsz = cwgt.isExcludedHflex_() ? wdh : (cwgt._nhflex * wdh / hflexsz) | 0; 
			cwgt.setFlexSize_({width:hsz});
			cwgt._hflexsz = hsz;
			if (!cwgt.isExcludedHflex_())
				lastsz -= hsz;
		}
		
		if (hflexs.length) {
			var cwgt = hflexs.shift();
			cwgt.setFlexSize_({width:lastsz});
			cwgt._hflexsz = lastsz;
		}
		
		
		wgt.parent.afterChildrenFlex_(wgt);
		wgt._flexFixed = false;
	},
	onFitSize: function () {
		var wgt = this,
			c = wgt.$n();
		if (c && zk(c).isVisible()) {
			if (wgt._hflex == 'min' && wgt._hflexsz === undefined)
				zFlex.fixMinFlex(wgt, c, 'w');
			if (wgt._vflex == 'min' && wgt._vflexsz === undefined)
				zFlex.fixMinFlex(wgt, c, 'h');
		}
	},
	fixMinFlex: function (wgt, wgtn, o) {
		
		return (o == 'h' ? _fixMinVflex: o == 'w' ? _fixMinHflex: _zero)
			(wgt, wgtn, o, wgt.beforeMinFlex_(o));
	}
};
})();












(function ($) {

    function f(n) {
        
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return this.valueOf() ? this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,

        meta = {    
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {






        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {



        var i,          
            k,          
            v,          
            length,
            mind = gap,
            partial,
            value = holder[key];



        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }




        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }



        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':



            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':





            return String(value);




        case 'object':




            if (!value) {
                return 'null';
            }




            partial = [];



            if (Object.prototype.toString.apply(value) === '[object Array]') {




                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }




                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }


                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }




            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }




        $.toJSON = function (value, replacer) {

            var i;
            gap = '';





            rep = replacer;





            return str('', {'': value});
        };

	$.evalJSON = function (s) {
		return (new Function('return (' + s +')'))(); 
		
	};
	$.j2d = function (s) { 
		
		if (s == null) return null;
		var s = s.split('.');
		return new Date(parseInt(s[0], 10), parseInt(s[1]) - 1, parseInt(s[2]),
			parseInt(s[3]), parseInt(s[4]), parseInt(s[5]), parseInt(s[6]));
	};
	$.d2j = function (d) { 
		return d ? [d.getFullYear(), d.getMonth() + 1, d.getDate(),
			d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()].join('.'): null;
	};

}(jq)); 



(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

if ($.event.fixHooks) {
    for ( var i=types.length; i; ) {
        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;
    }
}

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },
    
    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },
    
    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";
    
    
    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }
    
    
    deltaY = delta;
    
    
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }
    
    
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
	
	
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = (zk.safari_ ? 1 : -1) *orgEvent.wheelDeltaX/120; }
    
    
    args.unshift(event, delta, deltaX, deltaY);
    
    return ($.event.dispatch || $.event.handle).apply(this, args);
}

})(jq); 



(function($) {
  $.transit = {
    version: "0.9.9",

    
    
    propertyMap: {
      marginLeft    : 'margin',
      marginRight   : 'margin',
      marginBottom  : 'margin',
      marginTop     : 'margin',
      paddingLeft   : 'padding',
      paddingRight  : 'padding',
      paddingBottom : 'padding',
      paddingTop    : 'padding'
    },

    
    enabled: true,

    
    useTransitionEnd: false
  };

  var div = document.createElement('div');
  var support = {};

  
  
  function getVendorPropertyName(prop) {
    
    if (prop in div.style) return prop;

    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
    var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);

    if (prop in div.style) { return prop; }

    for (var i=0; i<prefixes.length; ++i) {
      var vendorProp = prefixes[i] + prop_;
      if (vendorProp in div.style) { return vendorProp; }
    }
  }

  
  
  function checkTransform3dSupport() {
    div.style[support.transform] = '';
    div.style[support.transform] = 'rotateY(90deg)';
    return div.style[support.transform] !== '';
  }

  var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

  
  support.transition      = getVendorPropertyName('transition');
  support.transitionDelay = getVendorPropertyName('transitionDelay');
  support.transform       = getVendorPropertyName('transform');
  support.transformOrigin = getVendorPropertyName('transformOrigin');
  support.transform3d     = checkTransform3dSupport();

  var eventNames = {
    'transition':       'transitionEnd',
    'MozTransition':    'transitionend',
    'OTransition':      'oTransitionEnd',
    'WebkitTransition': 'webkitTransitionEnd',
    'msTransition':     'MSTransitionEnd'
  };

  
  var transitionEnd = support.transitionEnd = eventNames[support.transition] || null;

  
  
  
  for (var key in support) {
    if (support.hasOwnProperty(key) && typeof $.support[key] === 'undefined') {
      $.support[key] = support[key];
    }
  }

  
  div = null;

  
  
  $.cssEase = {
    '_default':       'ease',
    'in':             'ease-in',
    'out':            'ease-out',
    'in-out':         'ease-in-out',
    'snap':           'cubic-bezier(0,1,.5,1)',
    
    'easeOutCubic':   'cubic-bezier(.215,.61,.355,1)',
    'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
    'easeInCirc':     'cubic-bezier(.6,.04,.98,.335)',
    'easeOutCirc':    'cubic-bezier(.075,.82,.165,1)',
    'easeInOutCirc':  'cubic-bezier(.785,.135,.15,.86)',
    'easeInExpo':     'cubic-bezier(.95,.05,.795,.035)',
    'easeOutExpo':    'cubic-bezier(.19,1,.22,1)',
    'easeInOutExpo':  'cubic-bezier(1,0,0,1)',
    'easeInQuad':     'cubic-bezier(.55,.085,.68,.53)',
    'easeOutQuad':    'cubic-bezier(.25,.46,.45,.94)',
    'easeInOutQuad':  'cubic-bezier(.455,.03,.515,.955)',
    'easeInQuart':    'cubic-bezier(.895,.03,.685,.22)',
    'easeOutQuart':   'cubic-bezier(.165,.84,.44,1)',
    'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
    'easeInQuint':    'cubic-bezier(.755,.05,.855,.06)',
    'easeOutQuint':   'cubic-bezier(.23,1,.32,1)',
    'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
    'easeInSine':     'cubic-bezier(.47,0,.745,.715)',
    'easeOutSine':    'cubic-bezier(.39,.575,.565,1)',
    'easeInOutSine':  'cubic-bezier(.445,.05,.55,.95)',
    'easeInBack':     'cubic-bezier(.6,-.28,.735,.045)',
    'easeOutBack':    'cubic-bezier(.175, .885,.32,1.275)',
    'easeInOutBack':  'cubic-bezier(.68,-.55,.265,1.55)'
  };

  
  
  
  
  
  
  
  
  $.cssHooks['transit:transform'] = {
    
    get: function(elem) {
      return $(elem).data('transform') || new Transform();
    },

    
    set: function(elem, v) {
      var value = v;

      if (!(value instanceof Transform)) {
        value = new Transform(value);
      }

      
      
      
      
      
      if (support.transform === 'WebkitTransform' && !isChrome) {
        elem.style[support.transform] = value.toString(true);
      } else {
        elem.style[support.transform] = value.toString();
      }

      $(elem).data('transform', value);
    }
  };

  
  
  
  $.cssHooks.transform = {
    set: $.cssHooks['transit:transform'].set
  };

  
  
  if ($.fn.jquery < "1.8") {
    
    
    
    
    
    
    $.cssHooks.transformOrigin = {
      get: function(elem) {
        return elem.style[support.transformOrigin];
      },
      set: function(elem, value) {
        elem.style[support.transformOrigin] = value;
      }
    };

    
    
    
    
    
    $.cssHooks.transition = {
      get: function(elem) {
        return elem.style[support.transition];
      },
      set: function(elem, value) {
        elem.style[support.transition] = value;
      }
    };
  }

  
  
  registerCssHook('scale');
  registerCssHook('translate');
  registerCssHook('rotate');
  registerCssHook('rotateX');
  registerCssHook('rotateY');
  registerCssHook('rotate3d');
  registerCssHook('perspective');
  registerCssHook('skewX');
  registerCssHook('skewY');
  registerCssHook('x', true);
  registerCssHook('y', true);

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  function Transform(str) {
    if (typeof str === 'string') { this.parse(str); }
    return this;
  }

  Transform.prototype = {
    
    
    
    
    
    
    setFromString: function(prop, val) {
      var args =
        (typeof val === 'string')  ? val.split(',') :
        (val.constructor === Array) ? val :
        [ val ];

      args.unshift(prop);

      Transform.prototype.set.apply(this, args);
    },

    
    
    
    
    
    set: function(prop) {
      var args = Array.prototype.slice.apply(arguments, [1]);
      if (this.setter[prop]) {
        this.setter[prop].apply(this, args);
      } else {
        this[prop] = args.join(',');
      }
    },

    get: function(prop) {
      if (this.getter[prop]) {
        return this.getter[prop].apply(this);
      } else {
        return this[prop] || 0;
      }
    },

    setter: {
      
      
      
      
      
      
      
      rotate: function(theta) {
        this.rotate = unit(theta, 'deg');
      },

      rotateX: function(theta) {
        this.rotateX = unit(theta, 'deg');
      },

      rotateY: function(theta) {
        this.rotateY = unit(theta, 'deg');
      },

      
      
      
      
      
      scale: function(x, y) {
        if (y === undefined) { y = x; }
        this.scale = x + "," + y;
      },

      
      skewX: function(x) {
        this.skewX = unit(x, 'deg');
      },

      skewY: function(y) {
        this.skewY = unit(y, 'deg');
      },

      
      perspective: function(dist) {
        this.perspective = unit(dist, 'px');
      },

      
      
      
      
      
      
      x: function(x) {
        this.set('translate', x, null);
      },

      y: function(y) {
        this.set('translate', null, y);
      },

      
      
      
      
      
      translate: function(x, y) {
        if (this._translateX === undefined) { this._translateX = 0; }
        if (this._translateY === undefined) { this._translateY = 0; }

        if (x !== null && x !== undefined) { this._translateX = unit(x, 'px'); }
        if (y !== null && y !== undefined) { this._translateY = unit(y, 'px'); }

        this.translate = this._translateX + "," + this._translateY;
      }
    },

    getter: {
      x: function() {
        return this._translateX || 0;
      },

      y: function() {
        return this._translateY || 0;
      },

      scale: function() {
        var s = (this.scale || "1,1").split(',');
        if (s[0]) { s[0] = parseFloat(s[0]); }
        if (s[1]) { s[1] = parseFloat(s[1]); }

        
        
        return (s[0] === s[1]) ? s[0] : s;
      },

      rotate3d: function() {
        var s = (this.rotate3d || "0,0,0,0deg").split(',');
        for (var i=0; i<=3; ++i) {
          if (s[i]) { s[i] = parseFloat(s[i]); }
        }
        if (s[3]) { s[3] = unit(s[3], 'deg'); }

        return s;
      }
    },

    
    
    parse: function(str) {
      var self = this;
      str.replace(/([a-zA-Z0-9]+)\((.*?)\)/g, function(x, prop, val) {
        self.setFromString(prop, val);
      });
    },

    
    
    
    toString: function(use3d) {
      var re = [];

      for (var i in this) {
        if (this.hasOwnProperty(i)) {
          
          if ((!support.transform3d) && (
            (i === 'rotateX') ||
            (i === 'rotateY') ||
            (i === 'perspective') ||
            (i === 'transformOrigin'))) { continue; }

          if (i[0] !== '_') {
            if (use3d && (i === 'scale')) {
              re.push(i + "3d(" + this[i] + ",1)");
            } else if (use3d && (i === 'translate')) {
              re.push(i + "3d(" + this[i] + ",0)");
            } else {
              re.push(i + "(" + this[i] + ")");
            }
          }
        }
      }

      return re.join(" ");
    }
  };

  function callOrQueue(self, queue, fn) {
    if (queue === true) {
      self.queue(fn);
    } else if (queue) {
      self.queue(queue, fn);
    } else {
      fn();
    }
  }

  
  
  
  function getProperties(props) {
    var re = [];

    $.each(props, function(key) {
      key = $.camelCase(key); 
      key = $.transit.propertyMap[key] || $.cssProps[key] || key;
      key = uncamel(key); 

      if ($.inArray(key, re) === -1) { re.push(key); }
    });

    return re;
  }

  
  
  
  
  
  
  
  
  function getTransition(properties, duration, easing, delay) {
    
    var props = getProperties(properties);

    
    if ($.cssEase[easing]) { easing = $.cssEase[easing]; }

    
    var attribs = '' + toMS(duration) + ' ' + easing;
    if (parseInt(delay, 10) > 0) { attribs += ' ' + toMS(delay); }

    
    
    var transitions = [];
    $.each(props, function(i, name) {
      transitions.push(name + ' ' + attribs);
    });

    return transitions.join(', ');
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  $.fn.transition = $.fn.transit = function(properties, duration, easing, callback) {
    var self  = this;
    var delay = 0;
    var queue = true;

    
    if (typeof duration === 'function') {
      callback = duration;
      duration = undefined;
    }

    
    if (typeof easing === 'function') {
      callback = easing;
      easing = undefined;
    }

    
    if (typeof properties.easing !== 'undefined') {
      easing = properties.easing;
      delete properties.easing;
    }

    if (typeof properties.duration !== 'undefined') {
      duration = properties.duration;
      delete properties.duration;
    }

    if (typeof properties.complete !== 'undefined') {
      callback = properties.complete;
      delete properties.complete;
    }

    if (typeof properties.queue !== 'undefined') {
      queue = properties.queue;
      delete properties.queue;
    }

    if (typeof properties.delay !== 'undefined') {
      delay = properties.delay;
      delete properties.delay;
    }

    
    if (typeof duration === 'undefined') { duration = $.fx.speeds._default; }
    if (typeof easing === 'undefined')   { easing = $.cssEase._default; }

    duration = toMS(duration);

    
    var transitionValue = getTransition(properties, duration, easing, delay);

    
    
    var work = $.transit.enabled && support.transition;
    var i = work ? (parseInt(duration, 10) + parseInt(delay, 10)) : 0;

    
    if (i === 0) {
      var fn = function(next) {
        self.css(properties);
        if (callback) { callback.apply(self); }
        if (next) { next(); }
      };

      callOrQueue(self, queue, fn);
      return self;
    }

    
    var oldTransitions = {};

    var run = function(nextCall) {
      var bound = false;

      
      var cb = function() {
        if (bound) { self.unbind(transitionEnd, cb); }

        if (i > 0) {
          self.each(function() {
            this.style[support.transition] = (oldTransitions[this] || null);
          });
        }

        if (typeof callback === 'function') { callback.apply(self); }
        if (typeof nextCall === 'function') { nextCall(); }
      };

      if ((i > 0) && (transitionEnd) && ($.transit.useTransitionEnd)) {
        
        bound = true;
        self.bind(transitionEnd, cb);
      } else {
        
        window.setTimeout(cb, i);
      }

      
      self.each(function() {
        if (i > 0) {
          this.style[support.transition] = transitionValue;
        }
        $(this).css(properties);
      });
    };

    
    
    var deferredRun = function(next) {
        this.offsetWidth; 
        run(next);
    };

    
    callOrQueue(self, queue, deferredRun);

    
    return this;
  };

  function registerCssHook(prop, isPixels) {
    
    if (!isPixels) { $.cssNumber[prop] = true; }

    $.transit.propertyMap[prop] = support.transform;

    $.cssHooks[prop] = {
      get: function(elem) {
        var t = $(elem).css('transit:transform');
        return t.get(prop);
      },

      set: function(elem, value) {
        var t = $(elem).css('transit:transform');
        t.setFromString(prop, value);

        $(elem).css({ 'transit:transform': t });
      }
    };

  }

  
  
  
  function uncamel(str) {
    return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });
  }

  
  
  
  
  
  
  
  function unit(i, units) {
    if ((typeof i === "string") && (!i.match(/^[\-0-9\.]+$/))) {
      return i;
    } else {
      return "" + i + units;
    }
  }

  
  
  
  
  
  
  function toMS(duration) {
    var i = duration;

    
    if ($.fx.speeds[i]) { i = $.fx.speeds[i]; }

    return unit(i, 'ms');
  }

  
  $.transit.getTransitionValue = getTransition;
})(jq); 


zkver('7.0.5.2','2015042817','/bin-java','/bin-java/zkau',{'charts':'2.0.1','zss':'3.9.0'},{ed:'p',pd:2000,ta:1,dj:1,eu:{},eup:{}});}zk.load('zul.lang',function(){if(zk._p=zkpi('zul'))try{

(function () {
	
	jq(function () {
		var zktheme = zk.themeName,
			tname = 'breeze'; 
		if (zktheme)
			tname = zktheme;
		jq(document.body).addClass(tname);
	});

	var $alert = jq.alert,
		icons = {QUESTION: 'z-messagebox-icon z-messagebox-question',
			EXCLAMATION: 'z-messagebox-icon z-messagebox-exclamation',
			INFORMATION: 'z-messagebox-icon z-messagebox-information',
			ERROR: 'z-messagebox-icon z-messagebox-error',
			NONE: 'z-messagebox z-messagebox-none'
		};

	function newButton(nm, f) {
		return new zul.wgt.Button({
			label: msgzul[nm.toUpperCase()]||nm,
			listeners: {
				onClick: function (evt) {
					if (typeof f == 'function')
						f.call(this, evt);
					
					
					var dt = this.desktop;
					this.$o().detach();
					
					
					if (zAu.disabledRequest) {
						zAu.disabledRequest = false;
						zAu.sendNow(dt);
					}
				}
			}
		});
	}
	function getButtons(opts) {
		var btns = [];
		for (var nm in opts) {
			var f = opts[nm];
			btns.push(newButton(nm, typeof f == 'function' ? f: null));
		}
		if (!btns.length)
			btns.push(newButton('OK'));
		return btns;
	}

	jq.alert = function (msg, opts) {
		if (opts && opts.mode == 'os')
			return $alert(msg);

		opts = opts || {};
		zk.load("zul.wnd,zul.wgt,zul.box", function () {
			var wnd = zk.Widget.$(jq('$aualert'));
			if (!wnd) {
				var wnd = new zul.wnd.Window({
					id: 'aualert',
					closable: true,
					width: '250pt',
					title: opts.title||zk.appName,
					border: 'normal',
					listeners: {onClose: function () {

						
						if (zAu.disabledRequest) {
							zAu.disabledRequest = false;
							zAu.sendNow(this.desktop);
						}
					}},
					children: [
						new zul.box.Box({
							mold: 'horizontal',
							children: [
								new zul.wgt.Div({sclass: icons[(opts.icon||'').toUpperCase()]||opts.icon||icons.INFORMATION}),
								new zul.wgt.Div({
									id: 'content',
									sclass: 'z-messagebox',
									width: '210pt',
									style: 'overflow:auto',
									children: [
										new zul.wgt.Label({
											id: 'msg',
											value: msg,
											multiline: true
										})
									]
								})
							]
						}),
						new zul.wgt.Separator({bar: true}),
						new zul.box.Box({
							mold: 'horizontal',
							style: 'margin-left:auto; margin-right:auto',
							children: getButtons(opts.button)
						})
					],
					mode: opts.mode||'modal'
				});
				var p = opts.desktop || zk.Desktop.$();
				if (p && (p = p.firstChild) && p.desktop)
					p.appendChild(wnd);
				else
					jq(document.body).append(wnd);
			} else {
				var label = wnd.$f('msg'),
					p = label.parent,
					pn = p.$n();
				label.setValue(label.getValue() + '\n' + msg);
				if (!pn.style.height && pn.offsetHeight >= jq.innerHeight() * 0.6) {
					pn.style.height = jq.px0(jq.innerHeight() * 0.6);
				}
			}
		});
  	};
	zAu.wrongValue_ = function(wgt, msg) {
		var efs = wgt.effects_;
		if (efs.errMesg) {
			efs.errMesg.destroy();
			delete efs.errMesg;
		}
		if (msg !== false) {
			efs.errMesg = {destroy: zk.$void};
			zk.load("zul.inp", function () {
				if (efs.errMesg) 
					(efs.errMesg = new zul.inp.Errorbox(wgt, msg)).show();
			});
		}
	};
})();





(function () {
	
	var _tt_inf, _tt_tmClosing, _tt_tip, _tt_ref;
	function _tt_beforeBegin(ref) {
		if (_tt_tip && !_tt_tip.isOpen()) { 
			_tt_clearOpening_();
			_tt_clearClosing_();
			_tt_tip = _tt_ref = null;
		}

		var overTip = _tt_tip && zUtl.isAncestor(_tt_tip, ref);
		if (overTip) _tt_clearClosing_(); 
		return !overTip;
	}
	function _tt_begin(tip, ref, params, event) {
		if (_tt_tip != tip || _tt_ref != ref) {
			_tt_close_();
			_tt_inf = {
				tip: tip, ref: ref, params: params,
				timer: setTimeout(function() {_tt_open_(event);}, params.delay !== undefined ? params.delay : zk.tipDelay)
			};
		} else
			_tt_clearClosing_();
	}
	function _tt_end(ref) {
		if (_tt_ref == ref || _tt_tip == ref) {
			_tt_clearClosing_(); 
			_tt_tmClosing = setTimeout(_tt_close_, 100);
			
		} else
			_tt_clearOpening_();
	}
	function _tt_clearOpening_() {
		var inf = _tt_inf;
		if (inf) {
			_tt_inf = null;
			clearTimeout(inf.timer);
		}
	}
	function _tt_clearClosing_() {
		var tmClosing = _tt_tmClosing;
		if (tmClosing) {
			_tt_tmClosing = null;
			clearTimeout(tmClosing);
		}
	}
	function _tt_open_(event) {
		var inf = _tt_inf;
		if (inf) {
			_tt_tip = inf.tip,
			_tt_ref = inf.ref;
			_tt_inf = null;

			var n = _tt_ref.$n();
			
			if (!n || !zk(n).isRealVisible()) 
				return _tt_tip = _tt_ref = null;

			var params = inf.params,
				x = params.x, y = params.y;
			if (x)
				params.x = _parseParamFunc(event, x);
			if (y)
				params.y = _parseParamFunc(event, y);
			
			var xy = params.x !== undefined ? [params.x, params.y] : zk.currentPointer;
			_tt_tip.open(_tt_ref, xy, params.position ? params.position : params.x === null ? "after_pointer" : null, {sendOnOpen:true});
		}
	}
	function _tt_close_() {
		_tt_clearOpening_();
		_tt_clearClosing_();

		var tip = _tt_tip;
		if (tip && tip.desktop) { 
			
			
			
			
			
			
			
			
	    	if (zk.ie == 10 || zk.ff) {
				var $tip = jq(tip.$n()),
					$tipOff = $tip.offset(),
					pointer = zk.currentPointer;
				if ((pointer[0] >= $tipOff.left && pointer[0] <= ($tipOff.left + $tip.width())) &&
					(pointer[1] >= $tipOff.top  && pointer[1] <= ($tipOff.top + $tip.height())))
					return;
			}
			_tt_tip = _tt_ref = null;
			tip.close({sendOnOpen:true});
		}
	}
	function _setCtrlKeysErr(msg) {
		zk.error("setCtrlKeys: " + msg);
	}
	function _parseParamFunc(event, funcBody) {
		if (funcBody.indexOf('(') != -1 && funcBody.indexOf(')') != -1) {
			var func = new Function('event', 'return ' + funcBody + ';');
			return func(event);
		} else {
			return zk.parseInt(funcBody);
		}
	}


zul.Widget = zk.$extends(zk.Widget, {
	
	getContext: function () {
		return this._context;
	},
	
	
	setContext: function (context) {
		if (zk.Widget.isInstance(context))
			context = 'uuid(' + context.uuid + ')';
		this._context = context;
		return this;
	},
	
	getPopup: function () {
		return this._popup;
	},
	
	
	setPopup: function (popup) {
		if (zk.Widget.isInstance(popup))
			popup = 'uuid(' + popup.uuid + ')';
		this._popup = popup;
		return this;
	},
	
	getTooltip: function () {
		return this._tooltip;
	},
	
	
	setTooltip: function (tooltip) {
		if (zk.Widget.isInstance(tooltip))
			tooltip = 'uuid(' + tooltip.uuid + ')';
		this._tooltip = tooltip;
		return this;
	},
	
	getCtrlKeys: function () {
		return this._ctrlKeys;
	},
	
	setCtrlKeys: function (keys) {
		if (this._ctrlKeys == keys) return;
		if (!keys) {
			this._ctrlKeys = this._parsedCtlKeys = null;
			return;
		}

		var parsed = [{}, {}, {}, {}, {}], 
			which = 0;
		for (var j = 0, len = keys.length; j < len; ++j) {
			var cc = keys.charAt(j); 
			switch (cc) {
			case '^':
			case '$':
			case '@':
				if (which)
					return _setCtrlKeysErr("Combination of Shift, Alt and Ctrl not supported: "+keys);
				which = cc == '^' ? 1: cc == '@' ? 2: 3;
				break;
			case '#':
				var k = j + 1;
				for (; k < len; ++k) {
					var c2 = keys.charAt(k);
					if ((c2 > 'Z' || c2 < 'A') 	&& (c2 > 'z' || c2 < 'a')
					&& (c2 > '9' || c2 < '0'))
						break;
				}
				if (k == j + 1)
					return _setCtrlKeysErr("Unexpected character "+cc+" in "+keys);

				var s = keys.substring(j+1, k).toLowerCase();
				if ("pgup" == s) cc = 33;
				else if ("pgdn" == s) cc = 34;
				else if ("end" == s) cc = 35;
				else if ("home" == s) cc = 36;
				else if ("left" == s) cc = 37;
				else if ("up" == s) cc = 38;
				else if ("right" == s) cc = 39;
				else if ("down" == s) cc = 40;
				else if ("ins" == s) cc = 45;
				else if ("del" == s) cc = 46;
				else if ("bak" == s) cc = 8;
				else if (s.length > 1 && s.charAt(0) == 'f') {
					var v = zk.parseInt(s.substring(1));
					if (v == 0 || v > 12)
						return _setCtrlKeysErr("Unsupported function key: #f" + v);
					cc = 112 + v - 1;
				} else
					return _setCtrlKeysErr("Unknown #"+s+" in "+keys);

				parsed[which][cc] = true;
				which = 0;
				j = k - 1;
				break;
			default:
				if (!which || ((cc > 'Z' || cc < 'A') 
				&& (cc > 'z' || cc < 'a') && (cc > '9' || cc < '0')))
					return _setCtrlKeysErr("Unexpected character "+cc+" in "+keys);
				if (which == 3)
					return _setCtrlKeysErr("$a - $z not supported (found in "+keys+"). Allowed: $#f1, $#home and so on.");

				if (cc <= 'z' && cc >= 'a')
					cc = cc.toUpperCase();
				parsed[which][cc.charCodeAt(0)] = true;
				which = 0;
				break;
			}
		}

		this._parsedCtlKeys = parsed;
		this._ctrlKeys = keys;
		return this;
	},

	_parsePopParams: function (txt, event) {
		var params = {},
			index = txt.indexOf(','),
			start = txt.indexOf('='),
			t = txt;
		if (start != -1)
			t = txt.substring(0, txt.substring(0, start).lastIndexOf(','));
		
		if (index != -1) {
			params.id = t.substring(0, index).trim();
			var t2 = t.substring(index + 1, t.length);
			if (t2)
				params.position = t2.trim();
			
			zk.copy(params, zUtl.parseMap(txt.substring(t.length, txt.length)));
		} else
			params.id = txt.trim();
		
		if (this._popup || this._context) { 
			var x = params.x, y = params.y;
			if (x)
				params.x = _parseParamFunc(event, x);
			if (y)
				params.y = _parseParamFunc(event, y);
		}
		if (params.delay)
			params.delay = zk.parseInt(params.delay);
		return params;
	},
	
	doClick_: function (evt, popupOnly) {
		if (!this.shallIgnoreClick_(evt) && !evt.contextSelected) {
			var params = this._popup ? this._parsePopParams(this._popup, evt) : {},
				popup = this._smartFellow(params.id);
			if (popup) {
				evt.contextSelected = true;
				
				
				var self = this,
					xy = params.x !== undefined ? [params.x, params.y]
							: [evt.pageX, evt.pageY];
				
				if (params.type && params.type == 'toggle' && popup.isOpen()) {
					popup.close({sendOnOpen:true});
				} else {
					setTimeout(function() { 
						popup.open(self, xy, params.position ? params.position : null, {sendOnOpen:true, type:params.type, which:1});
					}, 0);
				}
				evt.stop({dom:true});
			}
		}
		if (popupOnly !== true)
			this.$supers('doClick_', arguments);
	},
	doRightClick_: function (evt) {
		if (!this.shallIgnoreClick_(evt) && !evt.contextSelected) {
			var params = this._context ? this._parsePopParams(this._context, evt) : {},
				ctx = this._smartFellow(params.id);
			if (ctx) {
				evt.contextSelected = true;
				
				
				var self = this,
					xy = params.x !== undefined ? [params.x, params.y]
							: [evt.pageX, evt.pageY];
				
				if (params.type && params.type == 'toggle' && ctx.isOpen()) {
					ctx.close({sendOnOpen:true});
				} else {
					setTimeout(function() { 
						ctx.open(self, xy, params.position ? params.position : null, {sendOnOpen:true, type:params.type, which:3}); 
					}, 0);
				}
				evt.stop({dom:true}); 
			}
		}
		this.$supers('doRightClick_', arguments);
	},
	doTooltipOver_: function (evt) {
		if (!evt.tooltipped && _tt_beforeBegin(this)) {
			var params = this._tooltip ? this._parsePopParams(this._tooltip) : {},
				tip = this._smartFellow(params.id);
			if (tip) {
				evt.tooltipped = true;
					
				_tt_begin(tip, this, params, evt);
			}
		}
		this.$supers('doTooltipOver_', arguments);
	},
	doTooltipOut_: function (evt) {
		_tt_end(this);
		this.$supers('doTooltipOut_', arguments);
	},
	_smartFellow: function (id) {
		return id ? id.startsWith('uuid(') && id.endsWith(')') ?
			zk.Widget.$(id.substring(5, id.length - 1)):
			this.$f(id, true): null;
	},
	
	doKeyDown_ : function(evt) {
		if (this.getCtrlKeys() || this.isListen('onOK') || this.isListen('onCancel')) {
			
			if(!this.afterKeyDown_(evt))
				this.$supers('doKeyDown_', arguments);
		} else
			this.$supers('doKeyDown_', arguments);
	},
	
	afterKeyDown_: function (evt) {
		var keyCode = evt.keyCode, evtnm = "onCtrlKey", okcancel;
		switch (keyCode) {
		case 13: 
			var target = evt.domTarget, tn = jq.nodeName(target);
			if (tn == "textarea" || (tn == "button"
			
			&& (!target.id || !target.id.endsWith('-a')))
			|| (tn == "input" && target.type.toLowerCase() == "button"))
				return; 
			okcancel = evtnm = "onOK";
			break;
		case 27: 
			okcancel = evtnm = "onCancel";
			break;
		case 16: 
		case 17: 
		case 18: 
			return;
		case 45: 
		case 46: 
		case 8: 
			break;
		default:
			if ((keyCode >= 33 && keyCode <= 40) 
			|| (keyCode >= 112 && keyCode <= 123) 
			|| evt.ctrlKey || evt.altKey)
				break;
			return;
		}

		var target = evt.target, wgt = target;
		for (;; wgt = wgt.parent) {
			if (!wgt) return;
			if (!wgt.isListen(evtnm, {any:true})) continue;

			if (okcancel)
				break;

			var parsed = wgt._parsedCtlKeys;
			if (parsed
			&& parsed[evt.ctrlKey ? 1: evt.altKey ? 2: evt.shiftKey ? 3: 0][keyCode])
				break; 
		}

		
		
		setTimeout(function () {
			for (var w = target;; w = w.parent) {
				if (w.beforeCtrlKeys_ && w.beforeCtrlKeys_(evt))
					return;
				if (w == wgt) break;
			}
			wgt.fire(evtnm, zk.copy({reference: target}, evt.data));
		}, 0);

		evt.stop();
		if (jq.nodeName(evt.domTarget, "select"))
			evt.stop({dom:true, revoke: true}); 

		
		if (zk.ie < 11 && keyCode == 112) {
			zk._oldOnHelp = window.onhelp;
			window.onhelp = function () {return false;}
			setTimeout(function () {window.onhelp = zk._oldOnHelp; zk._oldOnHelp = null;}, 200);
		}
		return true; 
	},
	
	beforeCtrlKeys_: function (evt) {
	}
},{
	
	getOpenTooltip: function () {
		return _tt_tip && _tt_tip.isOpen() ? _tt_tip: null;
	}
});

})();


zul.LabelImageWidget = zk.$extends(zul.Widget, {
	_label: '',

	$define: {
		
		
		label: _zkf = function () {
			if (this.desktop)
				this.updateDomContent_();
		},
		
		
		iconSclass: _zkf,
		
		
		image: function (v) {
			if (v && this._preloadImage) zUtl.loadImage(v);
			var n = this.getImageNode();
			if (n) {
				var img = v || '';
				if (jq.nodeName(n, 'img')) 
					n.src = img;
				else
					jq(n).css('background-image', 'url('+img+')');
			} else if (this.desktop) 
				this.updateDomContent_();
		},
		
		
		hoverImage: null
	},
	
	updateDomContent_: function () {
		this.rerender();
	},
	
	domImage_: function () {
		var img = this._image;
		return img ? '<img src="' + img + '" align="absmiddle" />': '';
	},
	
	domIcon_: function () {
		var icon = this.getIconSclass(); 
		return icon ? '<i class="' + icon + '"></i>': '';
	},
	
	domLabel_: function () {
		return zUtl.encodeXML(this.getLabel());
	},
	
	domContent_: function () {
		var label = this.domLabel_(),
			icon = this.domIcon_(),
			img = this.domImage_();
		
		if (img) {
			if (icon) {
				return img + ' ' + icon + (label ? ' ' + label : ''); 
			} else {
				return label ? img + ' ' + label: img;
			}
		} else {
			return icon ? label ? icon + ' ' + label : icon : label;
		}
	},
	doMouseOver_: function () {
		this._updateHoverImage(true);
		this.$supers('doMouseOver_', arguments);
	},
	doMouseOut_: function () {
		this._updateHoverImage();
		this.$supers('doMouseOut_', arguments);
	},
	
	getImageNode: function () {
		if (!this._eimg && this._image) {
			var n = this.$n();
			if (n) this._eimg = jq(n).find('img:first')[0];
		}
		return this._eimg;
	},
	_updateHoverImage: function (inHover) {
		var n = this.getImageNode(),
			img = inHover ? this._hoverImage : this._image;
		if (n && this._hoverImage) {
			if (jq.nodeName(n, 'img'))
				n.src = img;
			else
				jq(n).css('background-image', 'url('+img+')');
		}
	},
	
	clearCache: function () {
		this._eimg = null;
		this.$supers('clearCache', arguments);
	}
});






zul.ContainerWidget = zk.$extends(zul.Widget, {
	bind_ : function() {
		this.$supers(zul.ContainerWidget, 'bind_', arguments);

		
		
		if (jq(this).data('scrollable')) {
			this.domListen_(this.getCaveNode(), 'onScroll');
		}
	},

	_doScroll : function() {
		if (jq(this).data('scrollable'))
			zWatch.fireDown('onScroll', this);
	},

	unbind_ : function() {
		if (jq(this).data('scrollable')) {
			this.domUnlisten_(this.getCaveNode(), 'onScroll');
		}
		this.$supers(zul.ContainerWidget, 'unbind_', arguments);
	}
});


(function () {

	function _cancel(o, sid, finish) {
		var key = o.getKey(sid),
			uplder = o.uploaders[key];
		if (uplder)
			uplder.destroy(finish);
		delete o.uploaders[key];
	}
	function _initUploader(o, form, val) {
		var key = o.getKey(o.sid),
			uplder = new zul.Uploader(o, key, form, val);
		zul.Upload.start(uplder);
		o.uploaders[key] = uplder;
	}
	function _start(o, form, val) { 
		
		
		_initUploader(o, form, val);
		o.sid++;
		o.initContent();
	}
	function _onchange(evt) {
		var n = this,
			upload = n._ctrl,
			wgt = upload._wgt,
			dt = wgt.desktop,

			action = zk.ajaxURI('/upload' + '?uuid=' + wgt.uuid + '&dtid=' + dt.id + '&sid=' + upload.sid
					+ (upload.maxsize !== '' ? '&maxsize=' + upload.maxsize : '')
					+ (upload.isNative ? '&native=true' : ''), {desktop:dt,au:true}),
			form = n.form;
		form.action = action;
		
		
		var p = form.parentNode;
		p.parentNode.removeChild(p);
		upload._formDetached = true;
		var fileName = !n.files || n.files.length == 1 ? n.value : (function(files){
			var fns = [];
			for (var len = files.length; len--;)
				fns.unshift(files[len].name);
			return fns.join(",");
		})(n.files); 
		_start(n._ctrl, form, fileName);
	}

	if (zk.opera) { 
		var _syncQue = [], _syncId;
		function _syncNow() {
			for (var j = _syncQue.length; j--;)
				_syncQue[j].sync();
		}
		function _addSyncQue(upld) {
			if (!_syncQue.length)
				_syncId = setInterval(_syncNow, 1500);

			_syncQue.push(upld);
		}
		function _rmSyncQue(upld) {
			_syncQue.$remove(upld);
			if (_syncId && !_syncQue.length) {
				clearInterval(_syncId);
				_syncId = null;
			}
		}
	}


zul.Upload = zk.$extends(zk.Object, {
	sid: 0,
	
	$init: function(wgt, parent, clsnm) {
		this.uploaders = {};

		var cls;
		for (var attrs = clsnm.split(','), i = 0, len = attrs.length; i < len; i++) {
			var attr = attrs[i].trim(); 
			if (attr.startsWith('maxsize='))
				this.maxsize = attr.match(new RegExp(/maxsize=([^,]*)/))[1];
			else if (attr.startsWith('multiple='))
				this.multiple = attr.match(new RegExp(/multiple=([^,]*)/))[1];
			else if (attr.startsWith('accept='))
				this.accept = attr.match(new RegExp(/accept=([^,]*)/))[1];
			else if (attr == 'native')
				this.isNative = true;
			else if (attr != 'true')
				cls = attr;
		}
		
		this._clsnm = cls || '';
		
		this._wgt = wgt;
		
		
		this._parent = (zk.isLoaded('zul.menu') && wgt.$instanceof(zul.menu.Menuitem) && parent.tagName == 'LI')
						? parent.firstChild : parent;
		if (wgt._tooltiptext) 
			this._tooltiptext = wgt._tooltiptext;
		
		this.initContent();
	},
	
	sync: function () {
		if (!this._formDetached) {
			var wgt = this._wgt,
				ref = wgt.$n(),
				parent = this._parent,
				outer = parent ? parent.lastChild : ref.nextSibling,
				inp = outer.firstChild.firstChild,
				refof = zk(ref).revisedOffset(),
				outerof = jq(outer).css({top: '0', left: '0'}).zk.revisedOffset(),
				diff = inp.offsetWidth - ref.offsetWidth,
				st = outer.style;
			st.top = (refof[1] - outerof[1]) + "px";
			st.left = refof[0] - outerof[0] - diff + "px";

			inp.style.height = ref.offsetHeight + 'px';
			inp.style.clip = 'rect(auto,auto,auto,' + diff + 'px)';
		}
	},
	initContent: function () {
		var wgt = this._wgt,
			parent = this._parent,
			ref = wgt.$n(), dt = wgt.desktop,
			html = '<span class="z-upload"'
				 + (this._tooltiptext? ' title="'+ this._tooltiptext+'"' : '') 
				 +'><form enctype="multipart/form-data" method="POST">'
				 + '<input name="file" type="file"'
				
				 + (this.multiple == 'true' ? ' multiple="" multiple' : '')
				 + (this.accept ? ' accept="' + this.accept.replace('|', ',') + '"' : '')
				 + ' hidefocus="true" style="height:'
				 + ref.offsetHeight + 'px"/></form></span>';
		
		if (parent) 
			jq(parent).append(html);
		else 
			jq(wgt).after(html);
		delete this._formDetached;

		
		if (!wgt._autodisable_self) {
			var self = this;
			
			setTimeout(function () {
				self.sync();
			}, 50);
		}

		var outer = this._outer = parent ? parent.lastChild : ref.nextSibling,
			inp = outer.firstChild.firstChild;
		
		this._inp = inp;

		if (zk.opera) { 
			outer.style.position = 'absolute';
			_addSyncQue(this);
		}

		inp.z$proxy = ref;
		inp._ctrl = this;
		
		jq(inp).change(_onchange);
		
		
		if (zk.ie <= 10) {
			jq(inp).hover(function() {
		        jq(wgt).addClass('z-upload-hover');
		    }, function() {
		        jq(wgt).removeClass('z-upload-hover');
		    });
		}
	},
	
	openFileDialog: function() {
		jq(this._inp).click();
	},
	
	destroy: function () {
		if (zk.opera)
			_rmSyncQue(this);

		jq(this._outer).remove();
		this._inp = null;
		this._wgt = this._parent = null;	
		for (var v in this.uploaders) {
			var uplder = this.uploaders[v];
			if (uplder) {
				delete this.uploaders[v];
				uplder.destroy();
			}
		}
	},
	
	getKey: function (sid) {
		return (this._wgt ? this._wgt.uuid : '' )+ '_uplder_' + sid; 
	},
	
	cancel: function (sid) { 
		_cancel(this, sid);
	},
	
	finish: function (sid) {
		_cancel(this, sid, true);
	}
},{
	
	error: function (msg, uuid, sid) {
		var wgt = zk.Widget.$(uuid);
		if (wgt) {
			jq.alert(msg, {desktop: wgt.desktop, icon: 'ERROR'});
			zul.Upload.close(uuid, sid);
		}
	},
	
	close: function (uuid, sid) {
		var wgt = zk.Widget.$(uuid);
		if (!wgt || !wgt._uplder) return;
		wgt._uplder.cancel(sid);
	},
	
	sendResult: function (uuid, contentId, sid) {
		var wgt = zk.Widget.$(uuid);
		if (!wgt || !wgt._uplder) return;
		wgt._uplder.finish(sid);
		zAu.send(new zk.Event(wgt.desktop, "updateResult", {
			contentId: contentId,
			wid: wgt.uuid,
			sid: sid
		}));
	},
	
	isFinish: function (wgt) {
		for (var key = (typeof wgt == 'string' ? wgt : wgt.uuid) + '_uplder_',
				f = zul.Upload.files, i = f.length; i--;)
			if (f[0].id.startsWith(key))
				return false;
		return true;
	},
	
	start: function (uplder) {
		var files = zul.Upload.files;
		if (uplder)
			files.push(uplder);
		if (files[0] && !files[0].isStart) {
			files[0].isStart = true;
			files[0].start();
		}
	},
	
	destroy: function (uplder) {
		for (var files = zul.Upload.files, i = files.length; i--;) 
			if (files[i].id == uplder.id) {
				files.splice(i, 1);
				break;
			}
		zul.Upload.start();
	},
	files: []
});

zul.Uploader = zk.$extends(zk.Object, {
	
	$init: function (upload, id, form, flnm) {
		this.id = id;
		this.flnm = flnm;
		this._upload = upload;
		this._form = form;
		this._parent = form.parentNode;
		this._sid = upload.sid;
		this._wgt = upload._wgt;
		
		var viewer, self = this;
		if (!upload._clsnm) viewer = new zul.UploadViewer(this, flnm);
		else
			zk.$import(upload._clsnm, function (cls) {
				viewer = new cls(self, flnm);
			});
		this.viewer = viewer;
	},
	
	getWidget: function () {
		return this._wgt;
	},
	
	destroy: function (finish) {
		this.end(finish);
		if (this._form) {
			jq(this._form.parentNode).remove();
			jq('#' + this.id + '_ifm').remove();
		}
		this._form = this._upload = this._wgt = null;
	},
	
	start: function () {
		var wgt = this._wgt,
			frameId = this.id + '_ifm';

		document.body.appendChild(this._parent);
		if (!jq('#' + frameId).length) 
			jq.newFrame(frameId);
		this._form.target = frameId;
		this._form.submit();
		this._form.style.display = "none";
		
		var self = this,
			data = 'cmd=uploadInfo&dtid=' + wgt.desktop.id
				+ '&wid=' + wgt.uuid + '&sid=' + this._sid;
		
		if (zul.Uploader._tmupload)
			clearInterval(zul.Uploader._tmupload);
		
		function t() {
			jq.ajax({
				type: 'POST',
				url: zk.ajaxURI('/upload', {desktop: wgt.desktop, au: true}),
				data: data,
				dataType: 'text',
				success: function(data) {
					var d = data.split(',');
					if (data.startsWith('error:')) {
						self._echo = true; 
						zul.Uploader.clearInterval(self.id);
						if (wgt) {
							self.cancel();
							zul.Upload.error(data.substring(6, data.length), wgt.uuid, self._sid);
						}
					} else if (!self.update(zk.parseInt(d[0]), zk.parseInt(d[1])))
						zul.Uploader.clearInterval(self.id);
				},
				complete: function(req, status) {
					var v;
					if ((v = req.getResponseHeader("ZK-Error")) == "404"
					|| v == "410" || status == 'error'
					|| status == 404 || status == 405 || status == 410) {
						zul.Uploader.clearInterval(self.id);
						var wgt = self.getWidget();
						if (wgt) {
							self.cancel();
							zul.Upload.error(msgzk.FAILED_TO_RESPONSE, wgt.uuid, self._sid);
						}
						return;
					}
				}
			});
		}
		t.id = this.id;
		
		zul.Uploader.clearInterval = function (id) {
			if (t.id == id) {
				clearInterval(zul.Uploader._tmupload);
				zul.Uploader._tmupload = undefined;
			}
		};
		zul.Uploader._tmupload = setInterval(t, 1000);
		
		zul.wgt.ADBS.autodisable(wgt);
	},
	
	cancel: function () {
		zul.Uploader.clearInterval(this.id);
		if (this._upload)
			this._upload.cancel(this._sid);
	},
	
	update: function (sent, total) {
		var wgt = this.getWidget();
		if (!wgt || total <= 0)
			if (this._echo)
				this.end();
			else
				return true; 
		else if (zul.Uploader._tmupload) {
			this._echo = true;
			if (sent >= 0 && sent <= 100)
				this.viewer.update(sent, total);
			return sent >= 0 && sent < 100;
		}
		return false;
	},
	
	end: function (finish) {
		this.viewer.destroy(finish);
		zul.Upload.destroy(this);
		this._echo = true;
		
		
		var wgt, upload, aded, parent;
		if ((wgt = this._wgt) && (upload = this._upload) && 
			(aded = upload._aded)) {
			wgt._uplder = null; 
			aded.onResponse();
			upload._aded = null;
			
			
			wgt._uplder.destroy();
			if ((parent = upload._parent) && !jq(parent).parents('html').length) {
				upload._parent = wgt._getUploadRef();
				upload.initContent();
			}
			wgt._uplder = upload;
			wgt._uplder.sync();
			delete wgt._autodisable_self;
		}
	}
});


	function _addUM(uplder, flnm) {
		var flman = zul.UploadViewer.flman;
		if (!flman || !flman.desktop) {
			if (flman) flman.detach();
			zul.UploadViewer.flman = flman = new zul.UploadManager();
			uplder.getWidget().getPage().appendChild(flman);
		}
		flman.removeFile(uplder);
		flman.addFile(uplder);
	}
	function _initUM(uplder, flnm) {
		if (zul.UploadManager)
			return _addUM(uplder, flnm);

		zk.load('zul.wgt,zul.box', function() {
			
			zul.UploadManager = zk.$extends(zul.wgt.Popup, {
				$init: function () {
					this.$supers('$init', arguments);
					this._files = {};
					this.setSclass('z-fileupload-manager');
				},
				onFloatUp: function(ctl) {
					var wgt = ctl.origin;
					if (!this.isVisible()) 
						return;
					this.setTopmost();
				},
				
				getFileItem: function(id) {
					return this._files[id] || zk.Widget.$(id);
				},
				
				addFile: function(uplder) {
					var id = uplder.id,
						flnm = uplder.flnm,
						prog = this.getFileItem(id);
					if (!prog) {
						prog = new zul.wgt.Div({
							uuid: id,
							children: [new zul.wgt.Label({
								value: flnm + ':'
							}), new zul.box.Box({
								mold: 'horizontal',
								children: [new zul.wgt.Progressmeter({
									id: id,
									sclass: 'z-fileupload-progress'
								})
								, new zul.wgt.Div({
									sclass: 'z-fileupload-remove z-icon-times',
									listeners: {
										onClick: function () {
											var uuid = id.substring(0, id.indexOf('_uplder_'));
											zul.Uploader.clearInterval(id);
											var wgt = zk.Widget.$(uuid);
											if (wgt) wgt._uplder.cancel(id.substring(id.lastIndexOf('_')+1, id.length));
										}
									}
								})]
							}), new zul.wgt.Label({id: id + '_total'}), new zul.wgt.Separator()]
						});
						
						try {
							this.appendChild(prog);
						} catch (e) {}
						this._files[id] = prog;
					}
					return prog;
				},
				
				updateFile: function(uplder, val, total) {
					var id = uplder.id,
						prog = this.getFileItem(id);
					if (!prog) return;
					prog.$f(id).setValue(val);
					prog.$f(id + '_total').setValue(total);
				},
				
				removeFile: function(uplder) {
					var id = uplder.id,
						prog = this.getFileItem(id);
					if (prog) 
						prog.detach();
					delete this._files[id];
					var close = true;
					for (var p in this._files) 
						if (!(close = false)) 
							break;
					
					if (close) 
						this.close();
				},
				
				open: function(wgt, position) {
					this.$super('open', wgt, null, position || 'after_start', {
						sendOnOpen: false,
						disableMask: true
					});
				}
			});
			_addUM(uplder, flnm);
		});
	}

zul.UploadViewer = zk.$extends(zk.Object, {
	
	$init: function (uplder,  flnm) {
		this._uplder = uplder;
		_initUM(uplder, flnm);
	},
	
	update: function (sent, total) {
		var flman = zul.UploadViewer.flman;
		if (flman) {
			if (!flman.isOpen())
					flman.open(this._uplder.getWidget());
			flman.updateFile(this._uplder, sent, msgzk.FILE_SIZE+Math.round(total/1024)+msgzk.KBYTES);
		}
	},
	
	destroy: function () {
		var flman = zul.UploadViewer.flman;
		if (flman)
			flman.removeFile(this._uplder);
	}
});

})();


(function (zk) {
	function easing(x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b; 
	}	
	function snap(dg, pointer) {
		var ctrl = dg.control,
			x = pointer[0],
			y = pointer[1];
		if (dg._isVer) {
			var move = pointer[1],
				down = move >= dg._lastPos;
			
			if (move - dg._start < 0) {
				move = pointer[1] = dg._start;
			} else if (move > dg._end) {
				move = pointer[1] = dg._end;
			}

			if (dg._lastPos) { 
				if (Math.abs(dg._lastPos - move) < 3)
					return pointer;
			}
			
			dg._lastPos = move;
		} else {
			var move = pointer[0],
				right = move >= dg._lastPos;
			
			if (move - dg._start < 0) {
				move = pointer[0] = dg._start;
			} else if (move > dg._end) {
				move = pointer[0] = dg._end;
			}

			if (dg._lastPos) { 
				if (Math.abs(dg._lastPos - move) < 3)
					return pointer;
			}
			
			dg._lastPos = move;
		}
		return pointer;
	};

	function starteffect(dg) {
		var ctrl = dg.control,
			opts = ctrl.opts;

		dg._steps = opts.startStep;
		dg._endStep = opts.endStep - opts.viewport; 
		dg._scale = ctrl._scale;
		dg._epos = ctrl.epos;
		dg._lastP = dg._start;
		if (ctrl._isVer) {
			dg._isVer = true;
			dg._start = opts.startPosition;
			if (zk(ctrl.eend).isVisible()) {
				dg._end = ctrl.eend.offsetTop + Math.ceil(dg.handle.offsetHeight/2);
				if (dg._end > opts.viewportSize + dg._start)
					dg._end = opts.viewportSize + dg._start;
			} else {
				dg._end = opts.viewportSize + dg._start;
			}
			dg._end -= dg.node.offsetHeight - ctrl._gap;
		} else {
			dg._isVer = false;
			dg._start = opts.startPosition;
			if (zk(ctrl.eend).isVisible()) {
				dg._end = ctrl.eend.offsetLeft + Math.ceil(dg.handle.offsetWidth/2);
				if (dg._end > opts.viewportSize + dg._start)
					dg._end = opts.viewportSize + dg._start;
			} else {
				dg._end = opts.viewportSize + dg._start;
			}
			dg._end -= dg.node.offsetWidth - ctrl._gap;
		}
		jq(dg._epos).show().delay(200).fadeIn(500);
		
		if (dg._timer) {
			clearTimeout(dg._timer);
		}
		var lastP, lastS = [],
			timeout = 30,
			duration = timeout*20,
			t = 10,
			running = function (orient) {
				var norient = zk.parseFloat(dg.node.style[orient]),
					diff = norient - zk.parseFloat(dg._epos.style[orient]);
				if (lastP == norient) {
					lastS.push(dg._lastSteps);
					if (lastS.length > 4 && lastS.shift() == dg._lastSteps) {
						lastS[0] = dg._lastSteps;
						clearTimeout(dg._timer);
						dg._timer = setTimeout(function(){running(orient);}, 100);
						return;
					}
				} else t = 10; 
				
				lastP = norient;
				
				var down = diff > 0,
					total = down ? Math.max(0, diff/dg._scale) : Math.min(0, diff/dg._scale),
					step = Math.round(ctrl.$class.easing(t/duration, t, 0, total, duration));

				if (down) {
					if (total > 1)
						step = Math.max(1, step);
				} else {
					if (-total > 1)
						step = Math.min(-1, step);
				}

				if (diff == 0 && step == 0) {
					if (norient == dg._start)
						step = -dg._steps;
					else if (norient == dg._end)
						step = dg._endStep - dg._steps;
				}

				dg._steps += step;
				if (down) {
					if (dg._steps > dg._endStep)
						dg._steps = dg._endStep;
				} else {
					if (dg._steps < 0)
						dg._steps = 0;
				}
				dg._epos.style[orient] = dg._start + (dg._scale * dg._steps) + 'px';
				t += timeout;			
				if (dg._lastSteps != dg._steps) {
					dg._lastSteps = dg._steps;
					var func = orient == 'top' ? ctrl.opts.onScrollY : ctrl.opts.onScrollX;
					if (typeof func == 'function') {
						func.call(dg.control.widget, dg._steps + ctrl.opts.offset);
					}
				}
				clearTimeout(dg._timer);
				dg._timer = setTimeout(function(){running(orient);}, timeout);
			};
		dg._timer = setTimeout(function(){running((dg._isVer ? 'top' : 'left'));}, 50);
	};
	function endeffect(dg, evt) {
		var ctrl = dg.control,
			target = evt.domTarget;
		if (dg._timer) {
			clearTimeout(dg._timer);
		}
		var move;
		if (dg._isVer) {
			move = zk.parseInt(dg._epos.style.top),
				end = dg._end;
			if (move > end)
				move = end;
			jq(dg.node).animate({top: move + 'px'}, 400, 'swing');
			
		} else {
			move = zk.parseInt(dg._epos.style.left),
				end = dg._end;
			if (move > end)
				move = end;
			jq(dg.node).animate({left: move + 'px'}, 400, 'swing');
			
		}
		ctrl.opts.startStep = dg._steps;
		var $jq = jq(dg._epos),
			old = $jq.css('opacity'); 
		jq(dg._epos).delay(300).fadeOut(500).css('opacity', old);
	};
	function ignoredrag(dg, p, evt) {
		return dg.node != evt.domTarget;
	}


zul.WScroll = zk.$extends(zk.Object, {
	
	
	
	
	
	
	_gap: 0, 
	$init: function (control, opts) {
		this.control = control;
		this.opts = zk.$default(opts, {
			orient : 'horizontal',
			startPosition : 0,
			startStep: 0,
			offset: 0
		});
		this.anchor = this.opts.anchor || control.parentNode;
		this.widget = zk.Widget.$(control);
		this.uid = this.widget.uuid;
		this.zcls = this.widget.getZclass();
		this._isVer = opts.orient == 'vertical';
		
		if (!opts.viewportSize && opts.viewportSize != 0)
			throw "Handle required for a viewport size: {viewportSize: size}";
		this.redraw(this.anchor);
		this._initDragdrop();
		this._listenMouseEvent();
		if (this.opts.syncSize !== false)
			this.syncSize();
	},
	
	syncSize: function (opts) {
		if (opts) {
			this.opts = zk.copy(this.opts, opts);
		}
		this.edrag.style.display = '';
		if (this._isVer) {
			var opts = this.opts,
				top = opts.startPosition,
				start = opts.startStep,
				view = opts.viewport,
				end = opts.endStep,
				vsize = opts.viewportSize,
				rest = end - view,
				edragHeight = this.edrag.offsetHeight - this._gap;
			if (rest <= 0) {
				this.eend.style.display = this.edrag.style.display = 'none';
				if (typeof this.opts.onScrollY == 'function')
					this.opts.onScrollY.call(this.widget, opts.offset); 
				return;
			}
			vsize -= edragHeight;
			if (vsize > rest) {
				this.epos.style.height = edragHeight + 'px';
				this._scale = 1;
				var es = this.eend.style;
				es.display = '';
				es.top = top + edragHeight + rest + 'px';
			} else {
				var rate = vsize/rest,
					height = Math.max(edragHeight * rate, 5);
				this.epos.style.height = height + 'px';
				this._scale = rate;
				this.eend.style.display = 'none'; 
				if (vsize < 10)
					this.edrag.style.display = 'none';
			}
			var top1 = top + (this._scale * start),
				top2 = top + vsize;
			if (top1 > top2)
				top1 = top2;
			this.epos.style.top = this.edrag.style.top = top1 + 'px';
		} else {
			var opts = this.opts,
				left = opts.startPosition,
				start = opts.startStep,
				view = opts.viewport,
				end = opts.endStep,
				vsize = opts.viewportSize,
				rest = end - view,
				edragWidth = this.edrag.offsetWidth - this._gap;
			if (rest <= 0) {
				this.eend.style.display = this.edrag.style.display = 'none';
				if (typeof this.opts.onScrollX == 'function')
					this.opts.onScrollX.call(this.widget, opts.offset); 
				return;
			}
			vsize -= edragWidth;
			if (vsize > rest) {
				this.epos.style.width = edragWidth + 'px';
				this._scale = 1;
				var es = this.eend.style;
				es.display = '';
				es.left = left + edragWidth + rest + 'px';
			} else {
				var rate = vsize/rest,
					width = Math.max(edragWidth * rate, 5);
				this.epos.style.width = width + 'px';
				this._scale = rate;
				this.eend.style.display = 'none'; 
				if (vsize < 10)
					this.edrag.style.display = 'none';
			}

			var left1 = left + (this._scale * start),
				left2 = left + vsize;
			if (left1 > left2)
				left1 = left2;
			this.epos.style.left = this.edrag.style.left = left1 + 'px';
		}
	},
	_listenMouseEvent: function () {
		var self = this;
		if (self._isVer) {
			jq(self.control).mousewheel(self.proxy(self._mousewheelY));
		} else if (!(zk.ie < 11) || !zk.opera) { 
			jq(self.control).mousewheel(self.proxy(self._mousewheelX));
		}

		var $drag = jq(self.edrag);
		$drag.children('div')
			.mouseover(self.proxy(self._mouseOver))
			.mouseout(self.proxy(self._mouseOut))
			.bind('mouseup', self.proxy(self._mouseUp))
			.bind('mousedown', self.proxy(self._mouseDown));
		$drag.click(zk.$void);
	},
	_unlistenMouseEvent: function () {
		var self = this;
		if (self._isVer)
			jq(self.control).unmousewheel(self.proxy(self._mousewheelY));
		else if (!(zk.ie < 11) || !zk.opera) 
			jq(self.control).unmousewheel(self.proxy(self._mousewheelX));
		
		var $drag = jq(self.edrag);
		$drag.children('div')
			.unbind('mouseover', self.proxy(self._mouseOver))
			.unbind('mouseout', self.proxy(self._mouseOut))
			.unbind('mouseup', self.proxy(self._mouseUp))
			.unbind('mousedown', self.proxy(self._mouseDown));
		$drag.unbind('click', zk.$void);
	},
	_mouseOver: function (evt) {
		var cls = evt.target.className,
			index = cls.lastIndexOf('-'),
			key = cls.substring(index+1),
			$drag = jq(this.edrag);
		if ($drag.hasClass(cls + '-clk')){
			$drag.removeClass(cls + '-clk');
		}
		switch (key) {
		case 'home':
		case 'up':
			if (this.opts.startStep > 0)
				$drag.addClass(cls + '-over');
			break;
		case 'down':
		case 'end':
			var opts = this.opts;
			if (opts.startStep < opts.endStep - opts.viewport) {
				$drag.addClass(cls + '-over');
			}
			break;
		}
	},
	_mouseOut: function (evt) {
		var cls = evt.target.className,
			$drag = jq(this.edrag);
		$drag.removeClass(cls + '-over');
		if ($drag.hasClass(cls + '-clk')){
			$drag.removeClass(cls + '-clk');
		}
	},
	_mouseUp: function (evt) {
		jq(this.edrag).removeClass(evt.target.className + '-clk');
	},
	_mouseDown: function (evt) {
		var cls = evt.target.className,
			index = cls.lastIndexOf('-'),
			key = cls.substring(index+1),
			$drag = jq(this.edrag);
		if (!$drag.hasClass(cls + '-over') && !zk.mobile) 
			return;
		
		$drag.addClass(cls + '-clk');

		var opts = this.opts;
		switch (key) {
		case 'home':
			if (opts.startStep > 0) {
				opts.startStep = 0;
				if (this._isVer) {
					var moving = opts.startPosition + 'px';
					this.epos.style.top = moving;
					$drag.animate({top: moving}, 500);
					if (typeof this.opts.onScrollY == 'function')
						this.opts.onScrollY.call(this.widget, opts.startStep + opts.offset);
				} else {
					var moving = opts.startPosition + 'px';
					this.epos.style.left = moving;
					$drag.animate({left: moving}, 500);
					if (typeof this.opts.onScrollX == 'function')
						this.opts.onScrollX.call(this.widget, opts.startStep + opts.offset);
				}
				$drag.removeClass(cls + '-over');
			}
			break;
		case 'up':
			if (opts.startStep > 0) {				
				opts.startStep -= 1;
				var move = opts.startPosition + (opts.startStep * this._scale);
				if (this._isVer) {
					var end;
					if (zk(this.eend).isVisible()) {
						end = this.eend.offsetTop;
					} else {
						end = opts.viewportSize + opts.startPosition;
					}
					end -= this.edrag.offsetHeight - this._gap;
					
					this.epos.style.top = move + 'px';
					if (end < move) {
						this.edrag.style.top = end + 'px';
					} else {
						this.edrag.style.top = move + 'px';
					}	
					if (typeof this.opts.onScrollY == 'function')
						this.opts.onScrollY.call(this.widget, opts.startStep + opts.offset);
				} else {
					var end;
					if (zk(this.eend).isVisible()) {
						end = this.eend.offsetLeft;
					} else {
						end = opts.viewportSize + opts.startPosition;
					}
					end -= this.edrag.offsetWidth - this._gap;
					
					this.epos.style.left = move + 'px';
					if (end < move) {
						this.edrag.style.left = end + 'px';
					} else {
						this.edrag.style.left = move + 'px';
					}
					
					if (typeof this.opts.onScrollX == 'function')
						this.opts.onScrollX.call(this.widget, opts.startStep + opts.offset);
				}
				
				if (opts.startStep == 0)
					$drag.removeClass(cls + '-over');
			}
			break;
		case 'down':
			if (opts.startStep < opts.endStep - opts.viewport) {
				opts.startStep += 1;
				var move = opts.startPosition + (opts.startStep * this._scale);
				if (this._isVer) {
					var end;
					if (zk(this.eend).isVisible()) {
						end = this.eend.offsetTop;
					} else {
						end = opts.viewportSize + opts.startPosition;
					}
					end -= this.edrag.offsetHeight - this._gap;
					
					this.epos.style.top = move + 'px';
					if (end < move) {
						this.edrag.style.top = end + 'px';
					} else {
						this.edrag.style.top = move + 'px';
					}
					if (typeof this.opts.onScrollY == 'function')
						this.opts.onScrollY.call(this.widget, opts.startStep + opts.offset);
				} else {
					var end;
					if (zk(this.eend).isVisible()) {
						end = this.eend.offsetLeft;
					} else {
						end = opts.viewportSize + opts.startPosition;
					}
					end -= this.edrag.offsetWidth - this._gap;
					
					this.epos.style.left = move + 'px';
					if (end < move) {
						this.edrag.style.left = end + 'px';
					} else {
						this.edrag.style.left = move + 'px';
					}
					
					if (typeof this.opts.onScrollX == 'function')
						this.opts.onScrollX.call(this.widget, opts.startStep + opts.offset);
				}
				if (opts.startStep == opts.endStep - opts.viewport)
					$drag.removeClass(cls + '-over');
			}
			break;
		case 'end':
			if (opts.startStep < opts.endStep - opts.viewport) {
				opts.startStep = opts.endStep - opts.viewport;
				if (this._isVer) {
					var moving;
					if (zk(this.eend).isVisible()) {
						moving = this.eend.offsetTop - (this.edrag.offsetHeight - this._gap);
					} else {
						moving = opts.startPosition + opts.viewportSize - (this.edrag.offsetHeight - this._gap);
					}
					this.epos.style.top = moving;
					$drag.animate({top: moving}, 500);
					if (typeof this.opts.onScrollY == 'function')
						this.opts.onScrollY.call(this.widget, opts.startStep + opts.offset);
				} else {
					var moving;
					if (zk(this.eend).isVisible()) {
						moving = this.eend.offsetLeft - (this.edrag.offsetWidth - this._gap);
					} else {
						moving = opts.startPosition + opts.viewportSize - (this.edrag.offsetWidth - this._gap);
					}
					this.epos.style.left = moving;
					$drag.animate({left: moving}, 500);
					if (typeof this.opts.onScrollX == 'function')
						this.opts.onScrollX.call(this.widget, opts.startStep + opts.offset);
				}
				$drag.removeClass(cls + '-over');
			}
			break;
		}
	},
	_mousewheelY: function (evt, delta, deltaX, deltaY) {
		deltaY = deltaY;
		if (deltaY) {
			evt.stop();
			var opts = this.opts,
				steps = opts.startStep,
				endStep = opts.endStep - opts.viewport,
				scale = this._scale,
				wgt = this.widget;
			if (deltaY > 0) { 
				opts.startStep -= Math.max(Math.round(wgt._cols/5), 1);
				if (opts.startStep < 0)
					opts.startStep = 0;
			} else { 
				opts.startStep += Math.max(Math.round(wgt._cols/5), 1);
				if (opts.startStep > endStep)
					opts.startStep = endStep;
			}
			if (steps == opts.startStep)
				return;
			
			var moving = opts.startPosition + (opts.startStep  * scale),
				end = zk(this.eend).isVisible() ? this.eend.offsetTop - (this.edrag.offsetHeight - this._gap)
							: opts.startPosition + opts.viewportSize - (this.edrag.offsetHeight - this._gap);
			this.epos.style.top = moving + 'px';
			
			if (moving > end)
				moving = end;
				
			this.edrag.style.top = moving + 'px';
			if (typeof this.opts.onScrollY == 'function')
			this.opts.onScrollY.call(this.widget, opts.startStep + opts.offset);
		}
	},
	_mousewheelX: function (evt, delta, deltaX, deltaY) {
		deltaX = deltaX;
		if (deltaX) {
			evt.stop();
			var opts = this.opts,
				steps = opts.startStep,
				endStep = opts.endStep - opts.viewport,
				scale = this._scale,
				wgt = this.widget;
			if (deltaX < 0) { 
				opts.startStep -= Math.max(Math.round(wgt._cols/5), 1);
				if (opts.startStep < 0)
					opts.startStep = 0;
			} else { 
				opts.startStep += Math.max(Math.round(wgt._cols/5), 1);
				if (opts.startStep > endStep)
					opts.startStep = endStep;
			}
			if (steps == opts.startStep)
				return;
			
			var moving = opts.startPosition + (opts.startStep  * scale),
				end = zk(this.eend).isVisible() ? this.eend.offsetLeft - (this.edrag.offsetWidth - this._gap)
							: opts.startPosition + opts.viewportSize - (this.edrag.offsetWidth - this._gap);
			this.epos.style.left = moving + 'px';
			
			if (moving > end)
				moving = end;
				
			this.edrag.style.left = moving + 'px';
			if (typeof this.opts.onScrollX == 'function')
				this.opts.onScrollX.call(this.widget, opts.startStep + opts.offset);	
		}
	},
	_initDragdrop: function () {
		var orient = this._isVer ? 'v' : 'h',
			uuid = this.uid + '-' + orient + 'bar';
		this.node = jq(uuid, zk)[0];
		this.edrag = this.node.firstChild;
		this.epos = this.edrag.nextSibling;
		this.eend = this.node.lastChild;
		
		
		var s = this.epos.style,
			old = s.display;
		s.display = 'block';
		this._gap = this._isVer ? this.edrag.offsetHeight - this.epos.offsetHeight
					: this.edrag.offsetWidth - this.epos.offsetWidth;
		s.display = old;
		
		this.drag = new zk.Draggable(this, this.edrag, {
			constraint: this._isVer ? 'vertical': 'horizontal',
			snap: snap,
			starteffect: starteffect,
			zIndex: 12000,
			ignoredrag: ignoredrag,
			endeffect: endeffect
		});
		jq(this.epos).hide();
	},
	destroy: function () {
		this.drag.destroy();
		this._unlistenMouseEvent();
		jq(this.node).remove();
		this.node = this.edrag = this.epos = this.drag = null; 
	},
	redraw: function (p) {
		var orient = this._isVer ? 'v' : 'h',
			ocls = this._isVer ? 'vertical' : 'horizontal',
			uuid = this.uid + '-' + orient + 'bar',
			zcls = this.widget.$s('wscroll');
		jq(p).append(['<div id="', uuid, '" class="', zcls, '-', ocls ,'">',
				'<div class="', zcls, '-drag">',
					'<div class="', zcls, '-home" title="', msgzul.WS_HOME, '"></div>',
					'<div class="', zcls, '-up" title="', msgzul.WS_PREV, '"></div>',
					'<div class="', zcls, '-down" title="', msgzul.WS_NEXT, '"></div>',
					'<div class="', zcls, '-end" title="', msgzul.WS_END, '"></div>',
				'</div>',
				'<div class="', zcls, '-pos"></div>',
				'<div class="', zcls, '-endbar"></div>',
			'</div>'].join(''));
	}
}, {
	
	easing: easing
});
})(zk);

(function (zk) {
	function _showScrollbar(wgt, orient, opacity) {
		var isHide = opacity == 0,
			bar = wgt.$n(orient),
			embed = wgt.$n(orient + '-embed'),
			style;
		if (bar) {
			style = bar.style;
			style.display = isHide ? 'none' : 'block';
			style.opacity = opacity;
			if (zk.ie < 9)
				style.filter = 'alpha(opacity=' + 100 * opacity + ')';
		}
		if (embed) { 
			style = embed.style;
			style.display = 'block';
			style.opacity = isHide ? 0.2 : 0;
			if (zk.ie < 9)
				style.filter = isHide ? 'alpha(opacity=20)' : 'alpha(opacity=0)';
		}
	};
	function _setScrollPos(position, min, max) {
		if (min > max)
			return position;
		if (position < min)
			position = min;
		if (position > max)
			position = max;
		return position;
	};

zul.Scrollbar = zk.$extends(zk.Object, {
	
	
	
	
	
	
	_pos: null,
	_barPos: null,
	_pressTimer: null,
	_frozenScroll: 0,
	_frozenLimit: false,
	$n: function (id) {
		return jq(this.uid + '-' + id, zk)[0];
	},
	$init: function (cave, scroller, opts) {
		if (!cave || !scroller)
			throw 'Both wrapper and scroller dom element are required to generate scrollbar';
		
		this.cave = cave;
		var cs = cave.style;
		cs.position = 'relative';
		cs.overflow = 'hidden';
		
		this.scroller = scroller;
		
		this.opts = zk.$default(opts, {
			embed: false,
			step: 20, 
			wheelAmountStep: 3, 
			startPositionX: 0, 
			startPositionY: 0 
		});
		this.widget = zk.Widget.$(cave);
		this.uid = this.widget.uuid;
		
		this._pos = [0, 0];
		this._barPos = [0, 0];
		this.currentPos = {x: this._pos[0], y: this._pos[1]};
		
		jq(cave)
			
			.bind('scroll', this.proxy(this._fixScroll))
			
			.bind('mouseenter', this.proxy(this._mouseEnter))
			.bind('mouseleave', this.proxy(this._mouseLeave));
	},
	destroy: function () {
		var cave = this.cave;
		jq(cave)
			
			.unbind('scroll', this.proxy(this._fixScroll))
			
			.unbind('mouseenter', this.proxy(this._mouseEnter))
			.unbind('mouseleave', this.proxy(this._mouseLeave));
		this._unbindMouseEvent('hor');
		this._unbindMouseEvent('ver');
		var hbar = this.$n('hor'),
			vbar = this.$n('ver');
		if (hbar)
			jq(hbar).remove();
		
		if (vbar)
			jq(vbar).remove();
		if (this.opts.embed) {
			var hembed = this.$n('hor-embed'),
				vembed = this.$n('ver-embed');
			if (hembed)
				jq(hembed).remove();
			if (vembed)
				jq(vembed).remove();
		}
		this._pos = this._barPos = this.currentPos = null;
	},
	hasVScroll: function () {
		return this.needV;
	},
	hasHScroll: function () {
		return this.needH;
	},
	syncSize: function (showScrollbar) {
		this._checkBarRequired();
		
		var wgt = this.widget,
			frozen = wgt.frozen, froenScrollWidth = 0,
			tpad = wgt.$n('tpad'), bpad = wgt.$n('bpad'),
			cave = this.cave, scroller = this.scroller,
			hbar = this.$n('hor'), vbar = this.$n('ver'),
			needH = this.needH, needV = this.needV,
			opts = this.opts,
			scrollHeight = scroller.scrollHeight;
		
		if (tpad && bpad) 
			scrollHeight += tpad.offsetHeight + bpad.offsetHeight;
		if (frozen) 
			froenScrollWidth = 50 * (frozen._scrollScale || 0);
		
		if (needH) {
			var old = hbar.style.display;
			hbar.style.display = 'block'; 
			var embed = this.$n('hor-embed'),
				left = this.$n('hor-left'),
				right = this.$n('hor-right'),
				wrapper = this.$n('hor-wrapper'),
				ws = wrapper.style,
				startX = opts.startPositionX,
				wdh = cave.offsetWidth - startX,
				swdh = hbar.offsetHeight + scroller.scrollWidth - startX + froenScrollWidth,
				lwdh = left.offsetWidth,
				rwdh = right.offsetWidth,
				hwdh = wdh - lwdh - rwdh;
			
			if (swdh < wdh) 
				swdh = wdh + froenScrollWidth;
			
			if (startX) {
				left.style.left = jq.px(startX);
				ws.left = jq.px(startX + lwdh);
				if (embed)
					embed.style.left = jq.px(startX);
			}
			
			if (needV) {
				ws.width = jq.px(hwdh - rwdh);
				right.style.right = jq.px(rwdh);
			} else {
				ws.width = jq.px(hwdh);
			}
			
			var indicator = this.$n('hor-indicator'),
				wwdh = wrapper.offsetWidth,
				iwdh = Math.round(wwdh * wdh / swdh),
				iwdh = iwdh > 15 ? iwdh : 15;
			
			indicator.style.width = iwdh + 'px';
			if (embed)
				embed.style.width = (iwdh + lwdh + rwdh) + 'px';
			
			this.hLimit = swdh - wdh;
			
			var limit = wwdh - iwdh;
			if (limit <= 0) {
				this.hBarLimit = 0;
				indicator.style.display = 'none';
			} else {
				this.hBarLimit = limit;
			}
			
			this.hRatio = Math.abs(this.hLimit / this.hBarLimit);
			
			this.needH = indicator.offsetHeight; 
			hbar.style.display = old; 
		}
		if (needV) {
			var old = vbar.style.display;
			vbar.style.display = 'block'; 
			var embed = this.$n('ver-embed'),
				up = this.$n('ver-up'),
				down = this.$n('ver-down'),
				wrapper = this.$n('ver-wrapper'),
				ws = wrapper.style,
				startY = opts.startPositionY,
				hgh = cave.offsetHeight - startY,
				shgh = vbar.offsetWidth + scrollHeight - startY,
				uhgh = up.offsetHeight
				dhgh = down.offsetHeight,
				vhgh = hgh - uhgh - dhgh;
			
			if (startY) {
				vbar.style.top = jq.px(cave.offsetTop + startY);
				down.style.bottom = jq.px(startY);
				if (embed)
					embed.style.top = vbar.style.top;
			}
			if (needH) {
				ws.height = jq.px0(vhgh - dhgh);
				down.style.bottom = jq.px(startY + dhgh);
			} else {
				ws.height = jq.px(vhgh);
			}
			
			var indicator = this.$n('ver-indicator'),
				whgh = wrapper.offsetHeight,
				ihgh = Math.round(whgh * hgh / shgh),
				ihgh = ihgh > 15 ? ihgh : 15;
			
			indicator.style.height = ihgh + 'px';
			if (embed)
				embed.style.height = (ihgh + uhgh + dhgh) + 'px';
			
			this.vLimit = shgh - hgh;
			
			var limit = whgh - ihgh;
			if (limit <= 0) {
				this.vBarLimit = 0;
				indicator.style.display = 'none';
			} else {
				this.vBarLimit = limit;
			}
			
			this.vRatio = Math.abs(this.vLimit / this.vBarLimit);

			this.needV = indicator.offsetWidth; 
			vbar.style.display = old; 
		}
		
		this.scrollTo(this._pos[0], this._pos[1]); 
		if (showScrollbar) {
			_showScrollbar(this, 'hor', 1);
			_showScrollbar(this, 'ver', 1);
		}
	},
	scrollTo: function (x, y) {
		if (this.needH) {
			x = _setScrollPos(x, 0, this.hLimit);
			var barPos = x / this.hRatio;
			this._syncPosition('hor', x);
			this._syncBarPosition('hor', barPos);
			this._syncEmbedBarPosition('hor', x + barPos);
		}
		if (this.needV) {
			y = _setScrollPos(y, 0, this.vLimit);
			var barPos = y / this.vRatio;
			this._syncPosition('ver', y);
			this._syncBarPosition('ver', barPos);
			this._syncEmbedBarPosition('ver', y + barPos);
		}
		
		this._onScrollEnd();
	},
	scrollToElement: function (dom) {
		var cave = this.cave,
			domTop = jq(dom).offset().top,
			domBottom = domTop + dom.offsetHeight,
			domLeft = jq(dom).offset().left,
			domRight = domLeft + dom.offsetWidth,
			viewTop = jq(cave).offset().top,
			viewBottom = viewTop + cave.offsetHeight,
			viewLeft = jq(cave).offset().left,
			viewRight = viewLeft + cave.offsetWidth
			scrollUp = true,
			
			scrollLeft = dom.offsetWidth == cave.offsetWidth;
		
		
		if (((domRight >= viewLeft && domRight <= viewRight) ||  
			(domLeft >= viewLeft && domLeft <= viewRight) || 
			(domLeft <= viewLeft && domRight >= viewRight)) &&
			((domTop >= viewTop && domTop <= viewBottom) ||
			(domBottom >= viewTop && domBottom <= viewBottom) ||
			(domTop <= viewTop && domBottom >= viewBottom))) {
			return; 
		}
		
		if (domTop < viewTop)
			scrollUp = false;
		if (domLeft < viewLeft)
			scrollLeft = false;
		
		
		var movementY = scrollUp ? domBottom - viewBottom : viewTop - domTop,
			posY = this._pos[1] + (scrollUp ? movementY : -movementY),
			movementX = scrollLeft ? domRight - viewRight : viewLeft - domLeft,
			posX = this._pos[0] + (scrollLeft ? movementX : -movementX),
			barPos;
		
		if (this.needV) {
			
			posY = _setScrollPos(posY, 0, this.vLimit);
			barPos = posY / this.vRatio;
			
			this._syncPosition('ver', posY);
			this._syncBarPosition('ver', barPos);
			this._syncEmbedBarPosition('ver', posY + barPos);
		}
		if (this.needH) {
			
			posX = _setScrollPos(posX, 0, this.hLimit);
			barPos = posX / this.hRatio;
			
			this._syncPosition('hor', posX);
			this._syncBarPosition('hor', barPos);
			this._syncEmbedBarPosition('hor', posX + barPos);
		}
		
		this._onScrollEnd();

		
		
		zk(dom).scrollIntoView();
	},
	isScrollIntoView: function (dom) {
		var cave = this.cave,
			domTop = jq(dom).offset().top,
			domBottom = domTop + dom.offsetHeight,
			domLeft = jq(dom).offset().left,
			domRight = domLeft + dom.offsetWidth,
			viewTop = jq(cave).offset().top,
			viewBottom = viewTop + cave.offsetHeight,
			viewLeft = jq(cave).offset().left,
			viewRight = viewLeft + cave.offsetWidth;
		
		if ((this.needV && domBottom <= viewBottom && domTop >= viewTop) ||
			(this.needH && domRight <= viewRight && domLeft >= viewLeft))
			return true;
		else
			return false;
	},
	getCurrentPosition: function () {
		return this.currentPos;
	},
	setBarPosition: function (start) { 
		var frozen = this.widget.frozen;
		if (frozen && this.needH) {
			var step = this.hBarLimit / frozen._scrollScale,
				barPos = start * step;
			this._syncBarPosition('hor', barPos);
			this._syncEmbedBarPosition('hor', barPos);
		}
	},
	_checkBarRequired: function () {
		var cave = this.cave,
			scroller = this.scroller,
			frozen = this.widget.frozen;
		
		this.needH = frozen ? true : (cave.offsetWidth < scroller.scrollWidth);
		var hbar = this.$n('hor');
		if (!this.needH) {
			if (hbar) {
				this._unbindMouseEvent('hor');
				this._syncPosition('hor', 0);
				jq(hbar).remove();
				if (this.opts.embed) {
					var hembed = this.$n('hor-embed');
					if (hembed)
						jq(hembed).remove();
				}
			}
		} else {
			if (!this.$n('hor')) {
				this.redraw(cave, 'hor');
				this._bindMouseEvent('hor');
			}
		}
		
		this.needV = cave.offsetHeight < scroller.offsetHeight;
		var vbar = this.$n('ver');
		if (!this.needV) {
			if (vbar) {
				this._unbindMouseEvent('ver');
				this._syncPosition('ver', 0);
				jq(vbar).remove();
				if (this.opts.embed) {
					var vembed = this.$n('ver-embed');
					if (vembed)
						jq(vembed).remove();
				}
			}
		} else {
			if (!vbar) {
				this.redraw(cave, 'ver');
				this._bindMouseEvent('ver');
			}
		}
	},
	_bindMouseEvent: function (orient) {
		var self = this,
			cave = self.cave,
			isH = orient == 'hor',
			bar = self.$n(orient),
			ind = self.$n(orient + '-indicator'),
			rail = self.$n(orient + '-rail'),
			arrow1 = self.$n(orient + (isH ? '-left' : '-up')),
			arrow2 = self.$n(orient + (isH ? '-right' : '-down'));
		
		if (isH && (!(zk.ie < 11) || !zk.opera)) 
			jq(cave).mousewheel(self.proxy(self._mousewheelX));
		else
			jq(cave).mousewheel(self.proxy(self._mousewheelY));
		
		jq(bar).click(zk.$void);
		jq(ind).bind('mousedown', self.proxy(self._dragStart));
		jq(rail)
			.bind('mousedown', self.proxy(self._mouseDown))
			.bind('mouseup', self.proxy(self._mouseUp));
		jq(arrow1)
			.bind('mousedown', self.proxy(self._mouseDown))
			.bind('mouseup', self.proxy(self._mouseUp));
		jq(arrow2)
			.bind('mousedown', self.proxy(self._mouseDown))
			.bind('mouseup', self.proxy(self._mouseUp));
	},
	_unbindMouseEvent: function (orient) {
		var self = this,
			cave = self.cave,
			isH = orient == 'hor',
			bar = self.$n(orient),
			ind = self.$n(orient + '-indicator'),
			rail = self.$n(orient + '-rail'),
			arrow1 = self.$n(orient + (isH ? '-left' : '-up')),
			arrow2 = self.$n(orient + (isH ? '-right' : '-down'));
		
		if (isH && (!(zk.ie < 11) || !zk.opera)) 
			jq(cave).unmousewheel(self.proxy(self._mousewheelX));
		else
			jq(cave).unmousewheel(self.proxy(self._mousewheelY));
		
		jq(bar).unbind('click', zk.$void);
		jq(ind).unbind('mousedown', self.proxy(self._dragStart));
		jq(rail)
			.unbind('mousedown', self.proxy(self._mouseDown))
			.unbind('mouseup', self.proxy(self._mouseUp));
		jq(arrow1)
			.unbind('mousedown', self.proxy(self._mouseDown))
			.unbind('mouseup', self.proxy(self._mouseUp));
		jq(arrow2)
			.unbind('mousedown', self.proxy(self._mouseDown))
			.unbind('mouseup', self.proxy(self._mouseUp));
	},
	_fixScroll: function (evt) {
		var cave = this.cave;
		if (!this.dragging)
			this.scrollTo(cave.scrollLeft, cave.scrollTop);
	},
	_mouseEnter: function (evt) {
		_showScrollbar(this, 'hor', 1);
		_showScrollbar(this, 'ver', 1);
	},
	_mouseLeave: function (evt) {
		if (this.dragging)
			return;
		
		_showScrollbar(this, 'hor', 0);
		_showScrollbar(this, 'ver', 0);
	},
	_dragStart: function (evt) {
		if (this._pressTimer) { 
			clearInterval(this._pressTimer);
			this._pressTimer = null;
		}
		evt.preventDefault();
		var self = this,
			orient = self.$n('hor-indicator') == evt.currentTarget ? 'hor' : 'ver',
			isHor = orient == 'hor',
			point = isHor ? evt.pageX : evt.pageY,
			pos = isHor ? self._barPos[0] : self._barPos[1],
			data = {
				orient: orient,
				point: point,
				pos: pos
			};
		
		jq(document)
			.bind('mousemove', data, self.proxy(self._dragMove))
			.bind('mouseup', self.proxy(self._dragEnd));
	},
	_dragEnd: function (evt) {
		var self = this,
			x = evt.pageX,
			y = evt.pageY,
			cave = self.cave,
			left = jq(cave).offset().left,
			top = jq(cave).offset().top;
		
		jq(document)
			.unbind('mousemove', self.proxy(self._dragMove))
			.unbind('mouseup', self.proxy(self._dragEnd));
		
		self.dragging = false;
		
		if ((x < left || x > left + cave.offsetWidth) ||
			(y < top || y > top + cave.offsetHeight)) {
			_showScrollbar(self, 'hor', 0);
			_showScrollbar(self, 'ver', 0);
		}
	},
	_dragMove: function (evt) {
		var data = evt.data,
			orient = data.orient,
			point = data.point,
			pos = data.pos,
			isHor = orient == 'hor',
			disp = (isHor ? evt.pageX : evt.pageY) - point,
			barPos = pos + disp,
			limit = isHor ? this.hBarLimit : this.vBarLimit,
			ratio = isHor ? this.hRatio : this.vRatio,
			frozen = this.widget.frozen;
		
		this.dragging = true;
		
		barPos = _setScrollPos(barPos, 0, limit);
		
		this._syncBarPosition(orient, barPos);
		if (frozen && isHor) {
			var step = limit / frozen._scrollScale;
			frozen._doScroll(barPos / step);
			this._syncEmbedBarPosition('hor', barPos);
		} else {
			var pos = barPos * ratio;
			this._syncPosition(orient, pos);
			this._syncEmbedBarPosition(orient, pos + barPos);
			
			this._onScrollEnd();
		}
	},
	_mousewheelX: function (evt, delta, deltaX, deltaY) {
		var opts = this.opts,
			step = opts.step * opts.wheelAmountStep,
			pos = this._pos[0];
		
		if (deltaX) {
			evt.stop();
			
			pos += (deltaX > 0 ? -step : step);
			
			pos = _setScrollPos(pos + step, 0, this.hLimit);
			
			var frozen = this.widget.frozen,
				barPos = pos / this.hRatio;
			if (frozen) {
				step = this.hBarLimit / frozen._scrollScale;
				barPos = barPos / step;
				frozen._doScroll(barPos);
				this._syncEmbedBarPosition('hor', barPos);
			} else {
				this._syncPosition('hor', pos);
				this._syncEmbedBarPosition('hor', pos + barPos);
			}
			this._syncBarPosition('hor', barPos);
			
			this._onScrollEnd();
		}
	},
	_mousewheelY: function (evt, delta, deltaX, deltaY) {
		var opts = this.opts,
			step = opts.step * opts.wheelAmountStep,
			pos = this._pos[1],
			barPos;
		
		if (deltaY) {
			var scrollUp = deltaY > 0;
			if (scrollUp && pos == 0)
				return;
			if (!scrollUp && pos == this.vLimit)
				return;
			
			evt.stop();
			
			pos += (scrollUp ? -step : step);
			
			pos = _setScrollPos(pos, 0, this.vLimit);
			barPos = pos / this.vRatio;
			
			this._syncPosition('ver', pos);
			this._syncBarPosition('ver', barPos);
			this._syncEmbedBarPosition('ver', pos + barPos);
			
			this._onScrollEnd();
		}
	},
	_mouseUp: function (evt) {
		clearInterval(this._pressTimer);
		this._pressTimer = null;
	},
	_mouseDown: function (evt) {
		if (this._pressTimer) {
			clearInterval(this._pressTimer);
			this._pressTimer = null;
		}
		var target = evt.currentTarget,
			hRail = this.$n('hor-rail'),
			vRail = this.$n('ver-rail'),
			up = this.$n('ver-up'),
			down = this.$n('ver-down'),
			left = this.$n('hor-left'),
			right = this.$n('hor-right'),
			frozen = this.widget.frozen,
			hBarLimit = this.hBarLimit,
			step = frozen ? hBarLimit / frozen._scrollScale : this.opts.step;
		
		
		if (target == hRail || target == vRail) {
			var isHor = target == hRail,
				orient = isHor ? 'hor' : 'ver',
				offset = jq(target).offset(),
				offset = isHor ? offset.left : offset.top,
				ind = this.$n(orient + '-indicator'),
				indsz = isHor ? ind.offsetWidth : ind.offsetHeight,
				point = (isHor ? evt.pageX : evt.pageY) - offset  - indsz/2,
				limit = isHor ? this.hLimit : this.vLimit,
				ratio = isHor ? this.hRatio : this.vRatio,
				pos = isHor ? this._pos[0] : this._pos[1],
				barPos = isHor ? this._barPos[0] : this._barPos[1],
				pointlimit = point * ratio,
				rstep = step * 10;
				self = this;
			
			if (frozen) {
				point = _setScrollPos(point, 0, hBarLimit);
				self._syncBarPosition('hor', point);
				self._syncEmbedBarPosition('hor', point);
				frozen._doScroll(point / step);
			} else {
				
				self._pressTimer = setInterval(function () {
					var isLeftDown = point > barPos,
						min, max, bPos;
					
					min = isLeftDown ? pos : pointlimit;
					min = min < 0 ? 0 : min;
					max = isLeftDown ? pointlimit : pos;
					max = max > limit ? limit : max;
					
					pos += (isLeftDown ? rstep : -rstep);
					
					pos = _setScrollPos(pos, min, max);
					bPos = pos/ratio;
					if (pos == pointlimit || pos <= min || pos >= max) {
						clearInterval(self._pressTimer);
						self._pressTimer = null;
					}
					
					self._syncPosition(orient, pos);
					self._syncBarPosition(orient, bPos);
					self._syncEmbedBarPosition(orient, pos + bPos);
					
					self._onScrollEnd();
				}, 50);
			}
		}
		
		if (target == left || target == right || target == up || target == down) {
			var self = this,
				isHor = target == left || target == right,
				orient = isHor ? 'hor' : 'ver',
				limit = isHor ? self.hLimit : self.vLimit,
				ratio = isHor ? self.hRatio : self.vRatio,
				pos = isHor ? self._pos[0] : self._pos[1],
				barPos = self._barPos[0];
			
			
			self._pressTimer = setInterval(function () {
				if (frozen && isHor) { 
					barPos += (target == left ? -step : step);
					barPos = _setScrollPos(barPos, 0, hBarLimit);
					self._syncBarPosition(orient, barPos);
					self._syncEmbedBarPosition(orient, barPos);
					frozen._doScroll(barPos / step);
				} else {
					var bpos;
					
					if (isHor) 
						pos += (target == left ? -step : step);
					else 
						pos += (target == up ? -step : step);
					
					pos = _setScrollPos(pos, 0, limit);
					barPos = pos / ratio;
					
					self._syncPosition(orient, pos);
					self._syncBarPosition(orient, barPos);
					self._syncEmbedBarPosition(orient, pos + barPos);
					
					self._onScrollEnd();
				}
			}, 50);
		}
	},
	_syncPosition: function (orient, pos) {
		if (!this._pos)
			return;
		
		var isH = orient == 'hor',
			cave = this.cave,
			bar = this.$n(orient),
			embed = this.opts.embed;
		
		if (bar) {
			pos = Math.round(pos);
			this._pos[isH ? 0 : 1] = pos;
			
			bar.style[isH ? 'left' : 'top'] = pos + 'px';
			if (isH && this.needV) {
				this.$n('ver').style.right = -pos + 'px';
				if (embed)
					this.$n('ver-embed').style.right = -pos + 'px';
			}
			if (!isH && this.needH) {
				this.$n('hor').style.bottom = -pos + 'px';
				if (embed)
					this.$n('hor-embed').style.bottom = -pos + 'px';
			}
			cave[isH ? 'scrollLeft' : 'scrollTop'] = pos;
			
			
			var onSyncPosition = this.opts.onSyncPosition;
			if (onSyncPosition) {
				this.currentPos = {x: this._pos[0], y: this._pos[1]};
				onSyncPosition.call(this);
			}
		}
	},
	_syncBarPosition: function (orient, pos) {
		var isH = orient == 'hor',
			indicator = this.$n(orient + '-indicator');
		
		this._barPos[isH ? 0 : 1] = pos;
		indicator.style[isH ? 'left' : 'top'] = pos + 'px';
	},
	_syncEmbedBarPosition: function (orient, pos) {
		if (this.opts.embed) {
			var isH = orient == 'hor',
				embed = this.$n(orient + '-embed'),
				opts = this.opts,
				start = isH ? opts.startPositionX : opts.startPositionY;
			embed.style[isH ? 'left' : 'top'] = (pos + start) + 'px';
		}
	},
	_onScrollEnd: function () {
		var onScrollEnd = this.opts.onScrollEnd;
		if (onScrollEnd) {
			this.currentPos = {x: this._pos[0], y: this._pos[1]};
			onScrollEnd.call(this);
		}
	},
	redraw: function (cave, orient) {
		var isH = orient == 'hor',
			uid = this.uid + '-' + orient,
			hv = isH ? 'horizontal' : 'vertical',
			lu = isH ? 'left' : 'up',
			rd = isH ? 'right' : 'down',
			out = [];
		
		if (this.opts.embed) {
			out.push('<div id="', uid, '-embed" class="z-scrollbar-', hv,
					'-embed"></div>');
		}
		out.push(
		'<div id="', uid, '" class="z-scrollbar z-scrollbar-', hv, '">',
			'<div id="', uid, '-', lu, '" class="z-scrollbar-', lu, '">',
				'<i class="z-icon-caret-', lu, '"></i>',
			'</div>',
			'<div id="', uid,'-wrapper" class="z-scrollbar-wrapper">',
				'<div id="', uid,'-indicator" class="z-scrollbar-indicator">',
					'<i class="z-scrollbar-icon z-icon-reorder"></i></div>',
				'<div id="', uid,'-rail" class="z-scrollbar-rail"></div>',
			'</div>',
			'<div id="', uid, '-', rd, '" class="z-scrollbar-', rd, '">',
				'<i class="z-icon-caret-', rd, '"></i>',
			'</div>',
		'</div>');
		jq(cave).append(out.join(''));
		out = null;
	}
});
})(zk);

}finally{zk.setLoaded(zk._p.n);}});zk.setLoaded('zul',1);zk.load('zul',function(){if(zk._p=zkpi('zul.wgt'))try{





zul.wgt.A = zk.$extends(zul.LabelImageWidget, {
	_dir: 'normal',
	

	$define: {
		
		
		disabled:  [
		    
		    
		    
		    function (v, opts) {
		    	if (opts && opts.adbs)
		    		
		    		this._adbs = true;	
		    	else if (!opts || opts.adbs === undefined)
		    		
		    		this._adbs = false;	
		    	if (!v) {
		    		if (this._adbs) {
		    			
		    			this._adbs = false;
		    		} else if (opts && opts.adbs === false)
		    			
		    			return this._disabled;
		    	}
		    	return v;
		    }, 
		    function (v) {
		    	var self = this,
		    		doDisable = function() { 
			    		if (self.desktop) {
			    			jq(self.$n()).attr('disabled', v); 
			    		}
			    	};
		    	doDisable();
		    }
		],
		
		
		dir: _zkf = function () {
			var n = this.$n();
			if (n) n.innerHTML = this.domContent_();
		},
		
		
		href: function (v) {
			var n = this.$n();
			if (n) n.href = v || '';
		},
		
		
		target: function (v) {
			var n = this.$n();
			if (n) n.target = v || '';
		},
		
		
		tabindex: function (v) {
			var n = this.$n();
			if (n) n.tabIndex = v||'';
		},
		
		
		autodisable: null
	},

	
	bind_: function(){
		this.$supers(zul.wgt.A, 'bind_', arguments);
		if (!this._disabled) {
			var n = this.$n();
			this.domListen_(n, 'onFocus', 'doFocus_')
				.domListen_(n, 'onBlur', 'doBlur_');
		}
	},
	unbind_: function(){
		var n = this.$n();
		this.domUnlisten_(n, 'onFocus', 'doFocus_')
			.domUnlisten_(n, 'onBlur', 'doBlur_');

		this.$supers(zul.wgt.A, 'unbind_', arguments);
	},
	domContent_: function(){
		var label = zUtl.encodeXML(this.getLabel()), 
			img = this.getImage(),
			iconSclass = this.domIcon_();
		if (!img && !iconSclass) 
			return label;
		
		if (!img) {
			img = iconSclass;
		} else
			img = '<img src="' + img + '" align="absmiddle" />'
				+ (iconSclass ? ' ' + iconSclass : '');
		return this.getDir() == 'reverse' ? label + img : img + label;
	},
	domAttrs_: function(no){
		var attr = this.$supers('domAttrs_', arguments),
			v;
		if (v = this.getTarget())
			attr += ' target="' + v + '"';
		if (v = this.getTabindex()) 
			attr += ' tabIndex="' + v + '"';
		if (v = this.getHref()) 
			attr += ' href="' + v + '"';
		else 
			attr += ' href="javascript:;"';
		if(this._disabled)
			attr += ' disabled="disabled"';
		return attr;
	},
	doClick_: function(evt) {
		var href = this.getHref();
		
		if (href && href.toLowerCase().startsWith('mailto:')) {
			var ifrm = jq.newFrame('mailtoFrame', href, null);
			jq(ifrm).remove();
			evt.stop();
		}
		
		if (zk.ie < 11 && !href) {
			evt.stop({dom:true});
		}
		if (this._disabled)
			evt.stop(); 
		else {
			zul.wgt.ADBS.autodisable(this);
			
			this.fireX(evt);
			if (!evt.stopped)
				this.$super('doClick_', evt, true);
		}
			
	}
});


zkreg('zul.wgt.A',true);zk._m={};
zk._m['default']=
function (out) {
	out.push('<a ', this.domAttrs_(), '>', this.domContent_());

	for (var w = this.firstChild; w; w = w.nextSibling)
		w.redraw(out);

	out.push('</a>');
}

;zkmld(zk._p.p.A,zk._m);

zul.wgt.Cell = zk.$extends(zul.Widget, {
	_colspan: 1,
	_rowspan: 1,
	_rowType: 0,
	_boxType: 1,
	
	$define: {
		
		
		colspan: function (v) {
			var n = this.$n();
			if (n)
				n.colSpan = v;
		},
		
		
		rowspan: function (v) {
			var n = this.$n();
			if (n)
				n.rowSpan = v;
		},
		
		
		align: function (v) {
			var n = this.$n();
			if (n)
				n.align = v;
		},
		
		
		valign: function (v) {
			var n = this.$n();
			if (n)
				n.valign = v;
		}
	},
	_getParentType: function () {
		var isRow = zk.isLoaded('zul.grid') && this.parent.$instanceof(zul.grid.Row);
		if (!isRow) {
			return zk.isLoaded('zul.box') && this.parent.$instanceof(zul.box.Box) ?
					this._boxType : null;
		}
		return this._rowType;
	},
	_getRowAttrs: function () {
		return this.parent._childAttrs(this, this.getChildIndex());
	},
	_getBoxAttrs: function () {
		return this.parent._childInnerAttrs(this);
	},
	_colHtmlPre: function () {
		var s = '',
			p = this.parent;
		if(zk.isLoaded('zkex.grid') && p.$instanceof(zkex.grid.Group) && this == p.firstChild)
			s += p.domContent_();
		return s;
	},
	domStyle_: function (no) {
		var style = this.$supers('domStyle_', arguments);
		if (this._align)
			style += ' text-align:' + this._align + ';';
		if (this._valign)
			style += ' vertical-align:' + this._valign + ';';
		return style;
	},
	
	domAttrs_: function (no) {
		var s = this.$supers('domAttrs_', arguments), v;	
		if ((v = this._colspan) != 1)
			s += ' colspan="' + v + '"';
		if ((v = this._rowspan) != 1)
			s += ' rowspan="' + v + '"';
			
		var m1, m2 = zUtl.parseMap(s, ' ', '"');		
		switch (this._getParentType()) {
		case this._rowType:
			m1 = zUtl.parseMap(this._getRowAttrs(), ' ', '"');
			break;
		case this._boxType:
			m1 = zUtl.parseMap(this._getBoxAttrs(), ' ', '"');
			break;
		}
		if (m1) {
			
			var s1 = m1.style,
				s2 = m2.style,
				style;
			if (s1 && s2) {
				s1 = zUtl.parseMap(s1.replace(/"/g, '').replace(/:/g, '='), ';');
				s2 = zUtl.parseMap(s2.replace(/"/g, '').replace(/:/g, '='), ';');
				zk.copy(s1, s2);
				style = zUtl.mapToString(s1, ':', ';');
			}
			zk.copy(m1, m2);
			if (style)
				m1.style = '"' + style + '"';
		}
		return ' ' + zUtl.mapToString(m1);
	},
	setVisible: function(visible) {
		this.$supers('setVisible', arguments);
		
		if (zk.ie10_ && visible)
			zk(this.$n()).redoCSS();
			
	},
	deferRedrawHTML_: function (out) {
		out.push('<td', this.domAttrs_({domClass:1}), ' class="z-renderdefer"></td>');
	}
});
zkreg('zul.wgt.Cell');zk._m={};
zk._m['default']=
function (out) {
	out.push('<td', this.domAttrs_(), '>', this._colHtmlPre());
	for (var j = 0, w = this.firstChild; w; w = w.nextSibling, j++)
		w.redraw(out);
	out.push('</td>');
}

;zkmld(zk._p.p.Cell,zk._m);

zul.wgt.Div = zk.$extends(zul.Widget, {
	$define: {
		
		
		align: function (v) {
			var n = this.$n();
			if (n)
				n.align = v;
		}
	},
	
	domAttrs_: function(no) {
		var align = this._align,
			attr = this.$supers('domAttrs_', arguments);
		return align != null ? attr + ' align="' + align + '"' : attr;
	}
});

zkreg('zul.wgt.Div',true);zk._m={};
zk._m['default']=
zk.Page.$redraw
;zkmld(zk._p.p.Div,zk._m);

zul.wgt.Span = zk.$extends(zul.Widget, {
});

zkreg('zul.wgt.Span',true);zk._m={};
zk._m['default']=
function (out) {
	out.push('<span', this.domAttrs_(), '>');
	for (var w = this.firstChild; w; w = w.nextSibling)
		w.redraw(out);
	out.push('</span>');
}
;zkmld(zk._p.p.Span,zk._m);

zul.wgt.Idspace = zk.$extends(zul.wgt.Div, {
	$init: function () {
		this._fellows = {};
		this.$supers('$init', arguments);
	}
});

zkreg('zul.wgt.Idspace',true);zk._m={};
zk._m['default']=
zk.Page.$redraw
;zkmld(zk._p.p.Idspace,zk._m);

zul.wgt.Include = zk.$extends(zul.Widget, {
	
	_enclosingTag: 'div',
	$init: function () {
		this._fellows = {};
		this.$supers('$init', arguments);
	},

	$define: {
		
		
		comment: null
	},
	
	getEnclosingTag: function() {
		return this._enclosingTag;
	},
	
	setEnclosingTag: function(tag) {
		this._enclosingTag = tag;
	},

	
	domStyle_: function (no) {
		var style = this.$supers('domStyle_', arguments);
		if (!this.previousSibling && !this.nextSibling) {
		
			if ((!no || !no.width) && !this.getWidth())
				style += 'width:100%;';
			if ((!no || !no.height) && !this.getHeight())
				style += 'height:100%;';
		}
		return style;
	},
	bind_: function () {
		this.$supers(zul.wgt.Include, 'bind_', arguments);
		var ctn;
		if (ctn = this._childjs) {
			ctn();
			this._childjs = this._xcnt = null;
				
		}

		if (jq.isArray(ctn = this._xcnt)) 
			for (var n = this.$n(), j = 0; j < ctn.length; ++j)
				n.appendChild(ctn[j]);
	},
	unbind_: function () {
		if (jq.isArray(this._xcnt)) 
			for (var n = this.$n(); n.firstChild;)
				n.removeChild(n.firstChild);
		this.$supers(zul.wgt.Include, 'unbind_', arguments);
	}
});

zkreg('zul.wgt.Include');zk._m={};
zk._m['default']=
function (out) {
	out.push('<', this._enclosingTag, this.domAttrs_(), '>');
	for (var w = this.firstChild; w; w = w.nextSibling)
		w.redraw(out);
	if (this._comment)
		out.push('<!--\n');
	if ((w=this._xcnt) && !jq.isArray(w)) 
		out.push(w); 
	if (this._comment)
		out.push('\n-->');
	out.push('</', this._enclosingTag, '>');
}

;zkmld(zk._p.p.Include,zk._m);

zul.wgt.Label = zk.$extends(zul.Widget, {
	_value: '',
	_maxlength: 0,

	$define: {
		
		
		value: _zkf = function () {
			var n = this.$n();
			if (n) n.innerHTML = this.getEncodedText();
		},
		
		
		multiline: _zkf,
		
		
		pre: _zkf,
		
		
		maxlength: _zkf
	},
	
	getEncodedText: function () {
		return zUtl.encodeXML(this._value, {multiline:this._multiline,pre:this._pre, maxlength: this._maxlength});
	},
	
	getMarginSize_: function (attr) { 
		var o = this.$supers('getMarginSize_', arguments);
		if (attr == 'h') {
			var n = this.$n(),
				oh = zk(n).offsetHeight();
			return o + oh - n.offsetHeight;
		}
		return o;
	}
});

zkreg('zul.wgt.Label');zk._m={};
zk._m['default']=
function (out) {
	out.push('<span', this.domAttrs_(), '>', this.getEncodedText(), '</span>');
}
;zkmld(zk._p.p.Label,zk._m);
(function () {
	function _initUpld(wgt) {
		var v;
		if (v = wgt._upload)
			wgt._uplder = new zul.Upload(wgt, null, v);
	}
	
	function _cleanUpld(wgt) {
		var v;
		if (v = wgt._uplder) {
			wgt._uplder = null;
			v.destroy();
		}
	} 
	
var Button = 

zul.wgt.Button = zk.$extends(zul.LabelImageWidget, {
	_orient: 'horizontal',
	_dir: 'normal',
	_type: 'button',

	$define: {
		
		
		href: null,
		
		
		target: null,
		
		
		dir: _zkf = function () {
			this.updateDomContent_();
		},
		
		
		orient: _zkf,
		
		
		type: _zkf,
		
		
		disabled: [
		    
		    
		    function (v, opts) {
		    	if (opts && opts.adbs)
		    		
		    		this._adbs = true;	
		    	else if (!opts || opts.adbs === undefined)
		    		
		    		this._adbs = false;	
		    	if (!v) {
		    		if (this._adbs) {
		    			
		    			this._adbs = false;
		    		} else if (opts && opts.adbs === false)
		    			
		    			return this._disabled;
		    	}
		    	return v;
		    }, 
		    function (v) {
		    	var self = this,
		    		doDisable = function() { 
			    		if (self.desktop) {
			    			jq(self.$n()).attr('disabled', v); 
			    			
			    			if (self._upload)
			    				v ? _cleanUpld(self) : _initUpld(self);
			    		}
			    	};
		    	
		    	
		    	if (this._type == 'submit')
		    		setTimeout(doDisable, 50);
		    	else
		    		doDisable();
		    }
		],
		
		
		
		tabindex: function (v) {
			var n = this.$n();
			if (n) n.tabIndex = v||'';
		},
		
		
		autodisable: null,
		
		
		upload: function (v) {
			var n = this.$n();
			if (n && !this._disabled) {
				_cleanUpld(this);
				if (v && v != 'false') _initUpld(this);
			}
		}
	},

	
	focus_: function (timeout) {
		
		var wgt = this,
			btn = this.$n();
		if (btn.disabled && !wgt._delayFocus) {
			wgt._delayFocus = true;
			setTimeout(function() {
				wgt.focus_(timeout);
				wgt._delayFocus = null;				
			}, 0);
		}		
		
		if (!zk.focusBackFix || !this._upload)
			zk(btn).focus(timeout);
		return true;
	},
	
	domContent_: function () {
		var label = zUtl.encodeXML(this.getLabel()),
			img = this.getImage(),
			iconSclass = this.domIcon_();
		if (!img && !iconSclass) return label;

		if (!img) img = iconSclass;
		else
			img = '<img class="' + this.$s('image') + '" src="' + img + '" />'
				+ (iconSclass ? ' ' + iconSclass : '');
		var space = "vertical" == this.getOrient() ? '<br/>': ' ';
		return this.getDir() == 'reverse' ?
			label + space + img: img + space + label;
	},
	onShow: function() {
		
		if (this.$n() && !this._disabled && this._uplder) {
			this._uplder.sync();
		}
	},
	bind_: function () {
		this.$supers(Button, 'bind_', arguments);

		var n = this.$n();
		this.domListen_(n, 'onFocus', 'doFocus_')
			.domListen_(n, 'onBlur', 'doBlur_');
		zWatch.listen({onShow: this});

		if (!this._disabled && this._upload) _initUpld(this);
	},
	unbind_: function () {
		_cleanUpld(this);

		var n = this.$n();
		this.domUnlisten_(n, 'onFocus', 'doFocus_')
			.domUnlisten_(n, 'onBlur', 'doBlur_');
		zWatch.unlisten({onShow: this});

		this.$supers(Button, 'unbind_', arguments);
	},
	doClick_: function (evt) {
		if (!evt.domEvent) 
			return;
		
		if (!this._disabled) {
			if (!this._upload)
				zul.wgt.ADBS.autodisable(this);
			else if (!zk.ie || zk.ie > 10) 
				this._uplder.openFileDialog();
			
			this.fireX(evt);

			if (!evt.stopped) {
				var href = this._href,
					isMailTo = href ? href.toLowerCase().startsWith('mailto:') : false;
				
				if (href) {
					
					if (isMailTo) {
						var ifrm = jq.newFrame('mailtoFrame', href, null);
						jq(ifrm).remove();
					} else {
						zUtl.go(href, {target: this._target || (evt.data.ctrlKey ? '_blank' : '')});
					}
				}
				
				this.$super('doClick_', evt, true);
			}
		}
		
		
	},
	setFlexSize_: function(sz) { 
		var n = this.$n();
		if (sz.height !== undefined) {
			if (sz.height == 'auto')
				n.style.height = '';
			else if (sz.height != '')
				n.style.height = jq.px0(sz.height);
			else
				n.style.height = this._height ? this._height : '';
		}
		if (sz.width !== undefined) {
			if (sz.width == 'auto')
				n.style.width = '';
			else if (sz.width != '')
				n.style.width = jq.px0(sz.width);
			else
				n.style.width = this._width ? this._width : '';
		}
	}
});

zul.wgt.ADBS = zk.$extends(zk.Object, {
	$init: function (ads) {
		this._ads = ads;
	},
	onResponse: function () {
		for (var ads = this._ads, ad; ad = ads.shift();)
			
			ad.setDisabled(false, {adbs: false, skip: true});
		zWatch.unlisten({onResponse: this});
	}
},{ 
	
	autodisable: function(wgt) {
		var ads = wgt._autodisable, aded, uplder;
		if (ads) {
			ads = ads.split(',');
			for (var j = ads.length; j--;) {
				var ad = ads[j].trim();
				if (ad) {
					var perm;
					if (perm = ad.charAt(0) == '+')
						ad = ad.substring(1);
					ad = 'self' == ad ? wgt: wgt.$f(ad);
					
					if (ad == wgt) { 
						uplder = wgt._uplder;
						wgt._uplder = null;
						wgt._autodisable_self = true;
					}
					if (ad && !ad._disabled) {
						
						ad.setDisabled(true, {adbs: true, skip: true});
						if (wgt.inServer)
							if (perm)
								ad.smartUpdate('disabled', true);
							else if (!aded) aded = [ad];
							else aded.push(ad);
					}
				}
			}
		}
		if (aded) {
			aded = new zul.wgt.ADBS(aded);
			if (uplder) {
				uplder._aded = aded;
				wgt._uplder = uplder;
			} else if (wgt.isListen('onClick', {asapOnly:true}))
				zWatch.listen({onResponse: aded});
			else
				setTimeout(function () {aded.onResponse();}, 800);
		}
	}
});

})();

zkreg('zul.wgt.Button');zk._m={};
zk._m['os']=
function (out) {
	var tabi = this._tabindex;
	
	out.push('<button type="', this._type, '"', this.domAttrs_());
	if (this._disabled) out.push(' disabled="disabled"');
	if (tabi) out.push(' tabindex="', tabi, '"');
	out.push('>', this.domContent_(), '</button>');
}
;zk._m['trendy']=[zk._p.p.Button,'os'];zk._m['default']=[zk._p.p.Button,'os'];zkmld(zk._p.p.Button,zk._m);
(function () {

	var _shallFixPercent = zk.gecko ? function (wgt) {
			var s;
			return (s = wgt._spacing) && s.endsWith('%');
		}: zk.$void;


zul.wgt.Separator = zk.$extends(zul.Widget, {
	_orient: 'horizontal',

	$define: { 
		
		
		orient: function () {
			this.updateDomClass_();
		},
		
		
		bar: function () {
			this.updateDomClass_();
		},
		
		
		spacing: function () {
			this.updateDomStyle_();		
		}
	},

	
	isVertical: function () {
		return this._orient == 'vertical';
	},

	
	bind_: function () {
		this.$supers(zul.wgt.Separator, 'bind_', arguments);
	},
	getZclass: function () {
		return 'z-separator';
	},
	domClass_: function (no) {
		var sc = this.$supers('domClass_', arguments),
			bar = this.isBar();
		if (!no || !no.zclass) {
			sc += ' ' + this.$s((this.isVertical() ? 'vertical' + (bar ? '-bar' : '') :
				'horizontal' + (bar ? '-bar' : '')));
		}
		return sc;
	},
	domStyle_: function () {
		var s = this.$supers('domStyle_', arguments);
		if (!_shallFixPercent(this))
			return s;

		
		var space = this._spacing,
			v = zk.parseInt(space.substring(0, space.length - 1).trim());
		if (v <= 0) return s;
		v = v >= 2 ? (v / 2) + '%' : '1%';

		return 'margin:' + (this.isVertical() ? '0 ' + v : v + ' 0')
			+ ';' + s;
	},
	getWidth: function () {
		var wd = this.$supers('getWidth', arguments);
		return !this.isVertical() || (wd != null && wd.length > 0)
			|| _shallFixPercent(this) ? wd : this._spacing;
		
	},
	getHeight: function () {
		var hgh = this.$supers('getHeight', arguments);
		return this.isVertical() || (hgh != null && hgh.length > 0)
			|| _shallFixPercent(this) ? hgh : this._spacing;
	}
});

})();
zkreg('zul.wgt.Separator');zk._m={};
zk._m['default']=
function (out) {
	out.push('<div', this.domAttrs_(), '>&nbsp;</div>');
}
;zkmld(zk._p.p.Separator,zk._m);

zul.wgt.Space = zk.$extends(zul.wgt.Separator, {
	_orient: 'vertical'
});
zkreg('zul.wgt.Space');zk._m={};
zk._m['default']=
zul.wgt.Separator.molds['default']
;zkmld(zk._p.p.Space,zk._m);

zul.wgt.Caption = zk.$extends(zul.LabelImageWidget, {
	
	domDependent_: true, 
	rerender: function () {
		var p = this.parent;
		if (p)
			p.clearCache(); 
		this.$supers('rerender', arguments);
	},
	domContent_: function () {
		var label = this.getLabel(),
			img = this.getImage(),
			title = this.parent ? this.parent._title: '',
			iconSclass = this.domIcon_();
		if (title) label = label ? title + ' - ' + label: title;
		label = zUtl.encodeXML(label);
		if (!img && !iconSclass) return label;

		if (!img) img = iconSclass;
		else img = '<img id="' + this.uuid + '-img" src="' + img + '" class="' + this.$s('image') + '" />' + (iconSclass ? ' ' + iconSclass : '');
		return label ? img + ' ' + label: img;
	},
	updateDomContent_: function () {
		var cnt = this.domContent_(),
			dn = this.$n('cave'),
			size = this.nChildren,
			
			total = jq(dn).contents().filter(function () {
				return !(this.nodeType == 3 && !this.nodeValue.trim().length);
			}).length,
			index = 0;
		
		 
		if (dn) {
			
			jq(dn).contents().filter(function(){
			    return (size + index++) < total;
			}).remove();
			this.clearCache(); 
			jq(dn).prepend(cnt ? cnt : '&nbsp;');
		} 
	},
	domClass_: function (no) {
		var sc = this.$supers('domClass_', arguments),
			parent = this.parent;
			
		if (!parent.$instanceof(zul.wgt.Groupbox))
			return sc;
			
		return sc + (parent._closable ? '': ' ' + this.$s('readonly'));
	},
	doClick_: function () {
		if (this.parent.$instanceof(zul.wgt.Groupbox))
			this.parent.setOpen(!this.parent.isOpen());
		this.$supers('doClick_', arguments);
	},
	
	_getBlank: function () {
		return '&nbsp;';
	},
	
	_isCollapsibleVisible: function () {
		var parent = this.parent;
		return parent.isCollapsible && parent.isCollapsible();
	},
	
	_isCloseVisible: function () {
		var parent = this.parent;
		return parent.isClosable && parent.isClosable()
			&& !parent.$instanceof(zul.wgt.Groupbox);
	},
	
	_isMinimizeVisible: function () {
		var parent = this.parent;
		return parent.isMinimizable && parent.isMinimizable();
	},
	
	_isMaximizeVisible: function () {
		var parent = this.parent;
		return parent.isMaximizable && parent.isMaximizable();
	},
	beforeMinFlex_: function (o) { 
		if (o == 'w')
			this.$n().width = '';
	},
	
	setFlexSizeW_: function(n, zkn, width, isFlexMin) {
		if (isFlexMin) {
			if (this._isCloseVisible()) {
				var close = this.parent.$n('close');
				width += close.offsetWidth + zk(close).marginWidth();
			}
			if (this._isMaximizeVisible()) {
				var max = this.parent.$n('max');
				width += max.offsetWidth + zk(max).marginWidth();
			}
			if (this._isMinimizeVisible()) {
				var min = this.parent.$n('min');
				width += min.offsetWidth + zk(min).marginWidth();
			}
			if (this._isCollapsibleVisible()) {
				var exp = this.parent.$n('exp');
				width += exp.offsetWidth + zk(exp).marginWidth();		
			}
		}
		this.$supers('setFlexSizeW_', arguments);
	},
	
	
	getImageNode: function () {
		if (!this._eimg && this._image) {
			var n = this.$n('img');
			if (n) this._eimg = n;
		}
		return this._eimg;
	}
});
zkreg('zul.wgt.Caption',true);zk._m={};
zk._m['default']=
function (out) {
	var p = this.parent,
		cnt = this.domContent_();
	
	
	out.push('<div', this.domAttrs_(), '>',
		'<div id="', this.uuid, '-cave" class="', this.$s('content'), 
		'">', (cnt ? cnt : this.firstChild ? '' : this._getBlank())); 
	for (var w = this.firstChild; w; w = w.nextSibling)
		w.redraw(out);
	out.push('</div>');
	
	if (p._isDefault && p._isDefault()) {
		out.push('</div>');
		return; 
	}
	
	var puuid = p.uuid,
		picon = p.$s('icon');
	if (this._isCloseVisible()) {
		out.push('<div id="', puuid , '-close" class="', picon, ' ',
			p.$s('close'), '"><i class="', p.getClosableIconClass_(), '"></i></div>');
	}
	if (this._isMaximizeVisible()) {
		var maxd = this._maximized;
		out.push('<div id="', puuid, '-max" class="', picon, ' ', p.$s('maximize'));
		if (maxd)
			out.push(' ', p.$s('maximized'));
		var maxIcon = maxd ? p.getMaximizedIconClass_() : p.getMaximizableIconClass_();
		out.push('"><i class="', maxIcon, '"></i></div>');
	}
	if (this._isMinimizeVisible()) {
		out.push('<div id="', puuid , '-min" class="', picon, ' ',
				p.$s('minimize'), '" ><i class="',
				p.getMinimizableIconClass_(), '"></i></div>');
	}
	if (this._isCollapsibleVisible()) {
		var openIcon = p._open ? p.getCollapseOpenIconClass_() : p.getCollapseCloseIconClass_();
		out.push('<div id="', puuid , '-exp" class="', picon, ' ',
			p.$s('expand'), '"><i class="', openIcon, '"></i></div>');
	}
	
	out.push('</div>');
}
;zkmld(zk._p.p.Caption,zk._m);
(function () {
	
	function _shallIgnore(evt) {
		var v = evt.domEvent;
		return v && jq.nodeName(v.target, 'label');
	}

var Checkbox =

zul.wgt.Checkbox = zk.$extends(zul.LabelImageWidget, {
	
	_checked: false,

	$define: {
		
		
		disabled: function (v) {
			var n = this.$n('real');
			if (n) n.disabled = v;
		},
		
		
		checked: function (v) {
			var n = this.$n('real');
			if (n) {
				
				jq(n).prop('checked', v);
			}
		},
		
		
		name: function (v) {
			var n = this.$n('real');
			if (n) n.name = v || '';
		},
		
		
		tabindex: function (v) {
			var n = this.$n('real');
			if (n) n.tabIndex = v || '';
		},
		
		
		value: function (v) {
			var n = this.$n('real');
			if (n) n.value = v || '';
		},
		
		
		autodisable: null
	},

	
	focus_: function (timeout) {
		zk(this.$n('real') || this.$n()).focus(timeout);
		return true;
	},
	contentAttrs_: function () {
		var html = '', 
			v; 
		if (v = this.getName())
			html += ' name="' + v + '"';
		if (this._disabled)
			html += ' disabled="disabled"';
		if (this._checked)
			html += ' checked="checked"';
		if (v = this._tabindex)
			html += ' tabindex="' + v + '"';
		if (v = this.getValue())
			html += ' value="' + v + '"';
		return html;
	},
	bind_: function (desktop) {
		this.$supers(Checkbox, 'bind_', arguments);

		var n = this.$n('real');
		
		
		if (n.checked != n.defaultChecked)
			n.checked = n.defaultChecked;

		this.domListen_(n, 'onFocus', 'doFocus_')
			.domListen_(n, 'onBlur', 'doBlur_');
	},
	unbind_: function () {
		var n = this.$n('real');
		
		this.domUnlisten_(n, 'onFocus', 'doFocus_')
			.domUnlisten_(n, 'onBlur', 'doBlur_');

		this.$supers(Checkbox, 'unbind_', arguments);
	},
	doSelect_: function (evt) {
		if (!_shallIgnore(evt))
			this.$supers('doSelect_', arguments);
	},
	doClick_: function (evt) {
		if (!_shallIgnore(evt)) {
			
			
			zul.wgt.ADBS.autodisable(this);
			var real = this.$n('real'),
				checked = real.checked;
			if (checked != this._checked) { 
				this.setChecked(checked); 
				this.fireOnCheck_(checked);
			}
			if (zk.webkit && !zk.mobile) 
				zk(real).focus();

			
			
			if (!(this.$instanceof(zul.wgt.Radio) && this.getRadiogroup()))
				evt.stop({propagation: true});

			return this.$supers('doClick_', arguments);
		}
	},
	fireOnCheck_: function (checked) {
		this.fire('onCheck', checked);
	},
	beforeSendAU_: function (wgt, evt) {
		if (evt.name != 'onClick') 
			this.$supers('beforeSendAU_', arguments);
	},
	getTextNode: function () {
		return this.$n('cnt');
	}
});

})();
zkreg('zul.wgt.Checkbox');zk._m={};
zk._m['default']=
function (out) {
	var uuid = this.uuid, content = this.domContent_();
	out.push('<span', this.domAttrs_(), '><input type="checkbox" id="', uuid,
			'-real"', this.contentAttrs_(), '/><label for="', uuid,
			'-real" id="', uuid, '-cnt"', this.domTextStyleAttr_(), 
			' class="', this.$s('content') ,'">', this.domContent_(),
			'</label></span>');
}
;zkmld(zk._p.p.Checkbox,zk._m);

zul.wgt.Groupbox = zk.$extends(zul.ContainerWidget, {
	_open: true,
	_closable: true,

	$define: { 
		
		
		open: function (open, fromServer) {
			var node = this.$n();
			if (node && this._closable) {
				if (open) {
					jq(node).removeClass(this.$s('collapsed'));
					zk(this).redoCSS(-1, {'fixFontIcon': true});
				}
				zk(this.getCaveNode())[open ? 'slideDown' : 'slideUp'](this);			
				
				if (!fromServer) this.fire('onOpen', {open:open});
			}			
		},
		
		
		closable: _zkf = function () {
			this._updDomOuter();
		},
		
		
		contentStyle: _zkf,
		
		
		contentSclass: _zkf,
		
		
		title: _zkf
	},
	_isDefault: function () {
		return this._mold == 'default';
	},
	_updDomOuter: function () {
		this.rerender(zk.Skipper.nonCaptionSkipper);
	},
	_contentAttrs: function () {
		var html = ' class="', s = this._contentSclass;
		if (s)
			html += s + ' ';
		html += this.$s('content') + '"';

		s = this._contentStyle;
		if (this.caption || this.getTitle()) 
			s = 'border-top:0;' + (s||'');
		if (!this._open)
			s = 'display:none;' + (s||'');
		if (s)
			html += ' style="' + s + '"';
		return html;
	},
	_redrawCave: function (out, skipper) { 
		out.push('<div id="', this.uuid, '-cave"', this._contentAttrs(), '>');

		if (!skipper)
			for (var w = this.firstChild, cap = this.caption; w; w = w.nextSibling)
				if (w != cap)
					w.redraw(out);

		out.push('</div>');
	},

	setHeight: function () {
		this.$supers('setHeight', arguments);
		if (this.desktop) this._fixHgh();
	},
	_fixHgh: function () {
		var hgh = this.$n().style.height;
		if (hgh && hgh != 'auto' && this.isOpen()) {
			var n;
			if (n = this.$n('cave')) {
				var $n = zk(n);
				
				n.style.height = ($n.revisedHeight($n.vflexHeight(), true) - 
								 (this._isDefault() ? parseInt(jq(this).css('padding-top')) : 0)) + 'px';
					
					
					
			}
		}
		if (this._isDefault()) {
			var title = this.$n('title'),
				cap = this.caption;
			if (cap)
				cap.$n().style.top = jq.px(zk(cap.$n('cave')).offsetHeight() / 2 * -1);
			if (title)
				title.style.top = jq.px(zk(this.$n('title-cnt')).offsetHeight() / 2 * -1);
		}
	},
	
	setFlexSizeH_: function(n, zkn, height, isFlexMin) {
		if (isFlexMin && (this.caption || this._title)) {
			
			var node = this.$n(),
				c;
			height = this._isDefault() ? jq(this.$n('header')).outerHeight() : 0;
			for (c = n.firstChild; c; c = c.nextSibling)
				height += jq(c).outerHeight();
		}

		this.$supers('setFlexSizeH_', arguments);
	},
	
	onSize: function () {
		this._fixHgh();
		
		
		
	},
	updateDomStyle_: function () {
		this.$supers('updateDomStyle_', arguments);
		if (this.desktop) this.onSize();
	},

	
	focus_: function (timeout) {
		var cap = this.caption;
		for (var w = this.firstChild; w; w = w.nextSibling)
			if (w != cap && w.focus_(timeout))
				return true;
		return cap && cap.focus_(timeout);
	},
	bind_: function () {
		this.$supers(zul.wgt.Groupbox, 'bind_', arguments);
		zWatch.listen({onSize: this});
		var tt;
		if (this.getTitle() && (tt = this.$n('title')))
			this.domListen_(tt, 'onClick', '_doTitleClick');
		if(zk.ie == 8) 
			zk(this).redoCSS();
		
	},
	unbind_: function () {
		zWatch.unlisten({onSize: this});
		var tt;
		if (tt = this.$n('title'))
			this.domUnlisten_(tt, 'onClick', '_doTitleClick');
		this.$supers(zul.wgt.Groupbox, 'unbind_', arguments);
	},
	
	_doTitleClick: function () {
		this.setOpen(!this.isOpen());
		this.$supers('doClick_', arguments);
	},
	onChildAdded_: function (child) {
		this.$supers('onChildAdded_', arguments);
		if (child.$instanceof(zul.wgt.Caption)) {
			this.caption = child;
			this.rerender();
		}
	},
	onChildRemoved_: function (child) {
		this.$supers('onChildRemoved_', arguments);
		if (child == this.caption) {
			this.caption = null;
			this.rerender();
		}
	},
	
	getChildMinSize_: function (attr, wgt) {
		if (!wgt.$instanceof(zul.wgt.Caption))
			return this.$supers('getChildMinSize_', arguments);
	},

	domClass_: function () {
		var cls = this.$supers('domClass_', arguments);
		if (!this._isDefault()) {
			if (cls) cls += ' ';
			cls += this.$s('3d');
		}
		
		if (!this.caption && !this.getTitle()) {
			if (cls) cls += ' ';
			cls += ' '+ this.$s('notitle');
		}
			
		if (!this._open && this._isDefault()) {
			if (cls) cls += ' ';
			cls += this.$s('collapsed');
		}
		return cls;
	},
	afterAnima_: function (visible) {
		if (!visible && this._isDefault())
			jq(this.$n()).addClass(this.$s('collapsed'));		
				
		this.$supers('afterAnima_', arguments);
		
		
		var p = this.parent;
		for (var c = p.firstChild; c; c = c.nextSibling) {
			if (c == this)
				continue;
			var vflex = c.getVflex();
			if (vflex && vflex != 'min') {
				zUtl.fireSized(p);
				break;
			}
		}
	}
});

zkreg('zul.wgt.Groupbox',true);zk._m={};
zk._m['3d']=
function (out, skipper) {	
	var	uuid = this.uuid,
		cap = this.caption,
		title = this.getTitle();
		title = title && !cap ? zUtl.encodeXML(title) :  null;
	
	out.push('<div ', this.domAttrs_(), '>');
	
	if (title || cap) {
		out.push('<div id="', uuid, '-header" class="', this.$s('header'),
				(this._closable? '': ' ' +  this.$s('readonly')),'">');
		if (cap)
			cap.redraw(out);
		else
			out.push('<div id="', uuid,'-title" class="', this.$s('title'), 
					'"><div id="', uuid,'-title-cnt" class="',
					this.$s('title-content'), '">', title, '</div></div>');
		out.push('</div>');
	}
	
	this._redrawCave(out, skipper);
	
	out.push('</div>');
}
;zk._m['default']=[zk._p.p.Groupbox,'3d'];zkmld(zk._p.p.Groupbox,zk._m);

zul.wgt.Html = zk.$extends(zul.Widget, {
	_content: '',
	$define: {
		
		
		content: function (v) {
			var n = this.$n();
			if (n) n.innerHTML = v || '';
		}
	},
	bind_: function () {
		this.$supers(zul.wgt.Html, 'bind_', arguments);
		if (jq.isArray(this._content)) 
			for (var ctn = this._content, n = this.$n(), j = 0; j < ctn.length; ++j)
				n.appendChild(ctn[j]);
	},
	unbind_: function () {
		if (jq.isArray(this._content)) 
			for (var n = this.$n(); n.firstChild;)
				n.removeChild(n.firstChild);
		this.$supers(zul.wgt.Html, 'unbind_', arguments);
	}
});

zkreg('zul.wgt.Html');zk._m={};
zk._m['default']=
function (out) {
	out.push('<span', this.domAttrs_(), '>',
		(jq.isArray(this._content) ? ''  : this._content), '</span>');
}
;zkmld(zk._p.p.Html,zk._m);

zul.wgt.Popup = zk.$extends(zul.Widget, {
	_visible: false,
	
	isOpen: function () {
		return this.isVisible();
	},
	
	
	open: function (ref, offset, position, opts) {
		var posInfo = this._posInfo(ref, offset, position),
			node = this.$n(),
			top = node.style.top,
			$n = jq(node);
		
		
		
		
		
		
		this._openInfo = arguments;
		
		
		this._shallToggle = opts && opts.type == 'toggle';

		$n.css({position: 'absolute'}).zk.makeVParent();
		
		
		zWatch.fire('onVParent', this);

		if (posInfo)
			$n.zk.position(posInfo.dim, posInfo.pos, opts);
		
		this.setFloating_(true); 
		this.setTopmost();
		this.openAnima_(ref, offset, position, opts);
	},
	
	openAnima_: function (ref, offset, position, opts) {
		this.afterOpenAnima_(ref, offset, position, opts);
	},
	
	afterOpenAnima_: function (ref, offset, position, opts) {
		var node = this.$n();
		this.setVisible(true);
		if ((!opts || !opts.disableMask) && this.isListen('onOpen', {asapOnly:true})) {
			
			if (this.mask) this.mask.destroy(); 
			
			
			this.mask = new zk.eff.Mask({
				id: this.uuid + '-mask',
				anchor: node
			});
			
			
			
			zWatch.listen({onResponse: this});		
		}
		
		
		if (this.shallStackup_() && node) {
			if (!this._stackup)
				this._stackup = jq.newStackup(node, node.id + '-stk');
			else {
				var dst, src;
				(dst = this._stackup.style).top = (src = node.style).top;
				dst.left = src.left;
				dst.zIndex = src.zIndex;
				dst.display = 'block';
			}
		}
		ref = zk.Widget.$(ref); 
		if (opts && opts.sendOnOpen) this.fire('onOpen', {open: true, reference: ref});
		
		jq(node).addClass(this.$s('open'));
		
		
		var openInfo = this._openInfo;
		if (openInfo) {
			this.position.apply(this, openInfo);
		}
	},
	
	shallStackup_: function () {
		return zk.eff.shallStackup();
	},
	
	position: function (ref, offset, position, opts) {
		var posInfo = this._posInfo(ref, offset, position);
		if (posInfo)
			zk(this.$n()).position(posInfo.dim, posInfo.pos, opts);
	},
	_posInfo: function (ref, offset, position, opts) {
		var pos, dim;
		
		if (position) {
			if (ref) {
				if (typeof ref == 'string')
					ref = zk.Widget.$(ref);
					
				if (ref) {
					var refn = zul.Widget.isInstance(ref) ? ref.$n() : ref;
					
					if (refn) {
						pos = position;
						dim = zk(refn).dimension(true);
					} else 
						return {pos: position};
				}
			} else
				return {pos: position};
		} else if (jq.isArray(offset)) {
			dim = {
				left: zk.parseInt(offset[0]), top: zk.parseInt(offset[1]),
				width: 0, height: 0
			}
		}
		if (dim) {
			
			var $n = zk(this.$n());
			dim.top += $n.sumStyles('t', jq.margins);
			dim.left += $n.sumStyles('l', jq.margins);
			return {pos: pos, dim: dim};
		}
	},
	onResponse: function () {
		if (this.mask) this.mask.destroy();
		
		var openInfo = this._openInfo;
		if (openInfo) {
			this.position.apply(this, openInfo);
			this._openInfo = null;
		}
		zWatch.unlisten({onResponse: this});
		this.mask = null;
	},
	
	close: function (opts) {
		if (this._stackup)
			this._stackup.style.display = 'none';
		
		this._shallToggle = false;
		this.closeAnima_(opts);  
	},
	
	closeAnima_: function (opts) {
		this.afterCloseAnima_(opts);
	},
	
	afterCloseAnima_: function (opts) {
		this.setVisible(false);
		
		var node = this.$n();
		zk(node).undoVParent();
		zWatch.fireDown('onVParent', this);

		this.setFloating_(false);
		if (opts && opts.sendOnOpen)
			this.fire('onOpen', {open:false});
		
		if (zk.ie < 11) { 
			var that = this;
			setTimeout(function() {
				that.replaceHTML(node); 
			}, 50);
		}
		
		jq(node).removeClass(this.$s('open'));
	},
	onFloatUp: function(ctl, opts){
		if (!this.isVisible()) 
			return;
		var openInfo = this._openInfo,
			length = ctl.args.length;
		
		
		if (this._shallToggle && openInfo && opts && (
				opts.triggerByClick === undefined || (
				openInfo[3].which == opts.triggerByClick && zUtl.isAncestor(this._openInfo[0], ctl.origin)))) {
				return;
		}
		this._doFloatUp(ctl);
	},
	_doFloatUp: function (ctl) {
		if (!this.isVisible()) 
			return;
		var wgt = ctl.origin;
		for (var floatFound; wgt; wgt = wgt.parent) {
			if (wgt == this) {
				if (!floatFound) 
					this.setTopmost();
				return;
			}
			if (wgt == this.parent && wgt.ignoreDescendantFloatUp_(this))
				return;
			floatFound = floatFound || wgt.isFloating_();
		}
		this.close({sendOnOpen:true});
	},
	onVParent: function (ctl) {
		
		if (this._shallToggle)
			this._doFloatUp(ctl);
	},
	bind_: function () {
		this.$supers(zul.wgt.Popup, 'bind_', arguments);
		zWatch.listen({onFloatUp: this, onShow: this, onVParent: this});
		this.setFloating_(true);
	},
	unbind_: function () {
		zk(this.$n()).undoVParent(); 
		if (this._stackup) {
			jq(this._stackup).remove();
			this._stackup = null;
		}
		if (this._openInfo)
			this._openInfo = null;
		this._shallToggle = null;
		zWatch.unlisten({onFloatUp: this, onShow: this, onVParent: this});
		this.setFloating_(false);
		this.$supers(zul.wgt.Popup, 'unbind_', arguments);
	},
	onShow: function (ctl) {
		
		ctl.fire(this.firstChild);
		var openInfo = this._openInfo;
		if (openInfo) {
			this.position.apply(this, openInfo);
			
			
		}
		zk(this).redoCSS(-1, {'fixFontIcon': true});
	},
	setHeight: function (height) {
		this.$supers('setHeight', arguments);
		if (this.desktop)
			zUtl.fireShown(this);
	},
	setWidth: function (width) {
		this.$supers('setWidth', arguments);
		if (this.desktop)
			zWatch.fireDown('onShow', this);
	},
	prologHTML_: function (out) {
	},
	epilogHTML_: function (out) {
	}
});

zkreg('zul.wgt.Popup',true);zk._m={};
zk._m['default']=
function (out) {
	var uuid = this.uuid;
		
	out.push('<div', this.domAttrs_(), '>');
	
	if(this._fixarrow)	
		out.push('<div id=', uuid, '-p class="z-pointer"></div>');
			
	out.push('<div id="', uuid, '-cave" class="', this.$s('content'), '">');
	this.prologHTML_(out);
	for (var w = this.firstChild; w; w = w.nextSibling)
		w.redraw(out);
	this.epilogHTML_(out);
	out.push('</div></div>');
}
;zkmld(zk._p.p.Popup,zk._m);

zul.wgt.Radio = zk.$extends(zul.wgt.Checkbox, {
	_attachExternal: null,
	
	getRadiogroup: function (parent) {
		if (!parent && this._group)
			return this._group;
		var wgt = parent || this.parent;
		for (; wgt; wgt = wgt.parent)
			if (wgt.$instanceof(zul.wgt.Radiogroup)) return wgt;
		return null;
	},
	
	setRadiogroup: function (group) {
		var old = this._group;
		if (old !== group) {
			if (old && this._attachExternal) old._rmExtern(this);
			this._group = group;
			if (group && this.desktop) {
				group._addExtern(this);
				this._attachExternal = true;
			}
			this._fixName();
		}
	},
	bind_: function(){
		this.$supers(zul.wgt.Radio, 'bind_', arguments);
		if(this._group && this.desktop && !this._attachExternal){
			this._group._addExtern(this);
			this._attachExternal = true;
		}
	},
	unbind_: function(){
		this.$supers(zul.wgt.Radio, 'unbind_', arguments);
		if(this._group && this._attachExternal){
			this._group._rmExtern(this);
			this._attachExternal = false;
		}
	},	
	
	setChecked: _zkf = function (checked) {
		if (checked != this._checked) {
			this._checked = checked;
			var n = this.$n('real');
			if (n) {
				n.checked = checked || false;
				checked ? jq(n).attr('checked','checked') : jq(n).removeAttr('checked');
				
				if (!n.checked)
					jq(n).removeAttr('checked');
				
				var group = this.getRadiogroup();
				if (group) {
					
					if (checked) {
						for (var items = group.getItems(), i = items.length; i--;) {
							if (items[i] != this) {
								var item = items[i].$n('real');
								if (item) {
									item.checked = false;
									jq(item).removeAttr('checked');
								}
								items[i]._checked = false;
							}
						}
					}
					group._fixSelectedIndex();
				}
			}
		}
		return this;
	},
	
	setSelected: _zkf,
	
	isSelected: function () {
		return this.isChecked();
	},
	
	getName: function () {
		var group = this.getRadiogroup();
		return group != null ? group.getName(): this.uuid;
	},
	_fixName: function () {
		var n = this.$n('real');
		if (n)
			n.name = this.getName();
	},
	beforeParentChanged_: function (newParent) {
		var oldParent = this.parentNode,
			oldGroup = this.getRadiogroup(),
			newGroup = newParent ? this.getRadiogroup(newParent) : null;
		if (oldGroup != newGroup || !newParent) {
			if (oldGroup && oldGroup.$instanceof(zul.wgt.Radiogroup)){
				oldGroup._fixOnRemove(this);
				if (this._attachExternal) {
					oldGroup._rmExtern(this);
					this._attachExternal = false;
				}
			}
			if (newGroup && newGroup.$instanceof(zul.wgt.Radiogroup)) {
				if (!this._attachExternal && newGroup == this._group ) {
					newGroup._addExtern(this);
					this._attachExternal = true;
				}
				newGroup._fixOnAdd(this); 
			}
		}
		this.$supers('beforeParentChanged_', arguments);
	},
	fireOnCheck_: function (checked) {
		
		var group = this.getRadiogroup();
		this.fire('onCheck', checked, {toServer: group && group.isListen('onCheck')} );
	}
});

zkreg('zul.wgt.Radio');zk._m={};
zk._m['default']=
function (out) {
	var uuid = this.uuid,
		rg = this.getRadiogroup();
	out.push('<span', this.domAttrs_(), '><input type="radio" id="', uuid,
			'-real"', this.contentAttrs_(), '/><label for="', uuid, '-real"', 
			' id="', uuid, '-cnt"', this.domTextStyleAttr_(),
			' class="', this.$s('content') ,'">', this.domContent_(),'</label>',
			(rg && rg._orient == 'vertical' ? '<br/>' :''), '</span>');
}
;zkmld(zk._p.p.Radio,zk._m);
(function () {

	function _concatItem(group) {
		var sum = _concatItem0(group);
		sum.$addAll(group._externs);
		return sum;
	}
	function _concatItem0(cmp) {
		var sum = [];
		for (var wgt = cmp.firstChild; wgt; wgt = wgt.nextSibling) {			
			if (wgt.$instanceof(zul.wgt.Radio)) 
				sum.push(wgt);
			else if (!wgt.$instanceof(zul.wgt.Radiogroup)) 
				sum = sum.concat(_concatItem0(wgt));
		}
		return sum;
	}

	function _getAt(group, cur, index) {
		var r = _getAt0(group, cur, index);
		if (!r)
			for (var extns = group._externs, j = 0, l = extns.length; j < l; ++j)
				if (!_redudant(group, extns[j]) && cur.value++ == index)
					return extns[j];
		return r;
	}
	function _getAt0(cmp, cur, index) {
		for (var wgt = cmp.firstChild; wgt; wgt = wgt.nextSibling) {
			if (wgt.$instanceof(zul.wgt.Radio)) {
				if (cur.value++ == index) return wgt;
			} else if (!wgt.$instanceof(zul.wgt.Radiogroup)) {
				var r = _getAt0(wgt, cur, index);
				if (r != null) return r;
			}				
		}
	}

	function _fixSelIndex(group, cur) {
		var jsel = _fixSelIndex0(group, cur);
		if (jsel < 0)
			for (var extns = group._externs, j = 0, l = extns.length, radio; j < l; ++j)
				if (!_redudant(group, radio = extns[j])) {
					if (radio.isSelected())
						return cur.value;
					++cur.value;
				}
		return jsel;
	}
	function _fixSelIndex0(cmp, cur) {
		for (var wgt = cmp.firstChild; wgt; wgt = wgt.nextSibling) {
			if (wgt.$instanceof(zul.wgt.Radio)) {
				if (wgt.isSelected())
					return cur.value;
				++cur.value;
			} else if (!wgt.$instanceof(zul.wgt.Radiogroup)) {
				var jsel = _fixSelIndex0(wgt, cur);
				if (jsel >= 0) return jsel;
			}
		}
		return -1;
	}

	function _redudant(group, radio) {
		for (var p = radio.parent; p != null; p = p.parent)
			if (p.$instanceof(zul.wgt.Radiogroup))
				return p == group;
	}


zul.wgt.Radiogroup = zk.$extends(zul.Widget, {
	_orient: 'horizontal',
	_jsel: -1,

	$init: function () {
		this.$supers('$init', arguments);
		this._externs = [];
	},
	$define: { 
		
		
		orient: function () {
			this.rerender();
		},
		
		
		name: function (v) {
			for (var items = this.getItems(), i = items.length; i--;)
				items[i].setName(v);
		}
	},
	
	getItemAtIndex: function (index) {
		return index >= 0 ? _getAt(this, {value: 0}, index): null;
	},
	
	getItemCount: function () {
		return this.getItems().length;
	},
	
	getItems: function () {
		return _concatItem(this);
	},
	
	getSelectedIndex: function () {
		return this._jsel;
	},
	
	setSelectedIndex: function (jsel) {
		if (jsel < 0) jsel = -1;
		if (this._jsel != jsel) {
			if (jsel < 0) {
				getSelectedItem().setSelected(false);
			} else {
				getItemAtIndex(jsel).setSelected(true);
			}
		}
	},
	
	getSelectedItem: function () {
		return this._jsel >= 0 ? this.getItemAtIndex(this._jsel): null;
	},
	
	setSelectedItem: function (item) {
		if (item == null)
			this.setSelectedIndex(-1);
		else if (item.$instanceof(zul.wgt.Radio))
			item.setSelected(true);
	},
	appendItem: function (label, value) {
		var item = new zul.wgt.Radio();
		item.setLabel(label);
		item.setValue(value);
		this.appendChild(item);
		return item;
	},
	
	removeItemAt: function (index) {
		var item = this.getItemAtIndex(index);
		if (item && !this._rmExtern(item)) {
			var p = item.parent;
			if (p) p.removeChild(item);
		}
		return item;
	},

	
	_fixSelectedIndex: function () {
		this._jsel = _fixSelIndex(this, {value: 0});
	},
	_fixOnAdd: function (child) {
		if (this._jsel >= 0 && child.isSelected()) {
			child.setSelected(false); 
		} else {
			this._fixSelectedIndex();
		}
	},
	_fixOnRemove: function (child) {
		if (child.isSelected()) {
			this._jsel = -1;
		} else if (this._jsel > 0) { 
			this._fixSelectedIndex();
		}
	},

	_addExtern: function (radio) {
		this._externs.push(radio);
		if (!_redudant(this, radio))
			this._fixOnAdd(radio);
	},
	_rmExtern: function (radio) {
		if (this._externs.$remove(radio)) {
			if (!_redudant(this, radio))
				this._fixOnRemove(radio);
			return true;
		}
	}
});
})();
zkreg('zul.wgt.Radiogroup');zk._m={};
zk._m['default']=
function (out) {
	out.push('<span', this.domAttrs_(), '>');
	for (var w = this.firstChild; w; w = w.nextSibling)
		w.redraw(out);
	out.push('</span>');
}
;zkmld(zk._p.p.Radiogroup,zk._m);

zul.wgt.Toolbar = zk.$extends(zul.Widget, {
	_orient: 'horizontal',
	_align: 'start',

	$define: {
		
		
		align: _zkf = function () {
			this.rerender();
		},
		
		
		orient: _zkf
	},
	
	domClass_: function (no) {
		var sc = this.$supers('domClass_', arguments);
		if (!no || !no.zclass) {
			var tabs = this.parent && zk.isLoaded('zul.tab') && this.parent.$instanceof(zul.tab.Tabbox) ? this.$s('tabs') : '';
				
			if (tabs)
				sc += ' ' + tabs;
			if (this.inPanelMold())
				sc += ' ' + this.$s('panel');
		}
		return sc;
	},
	
	
	setFlexSizeW_: function(n, zkn, width, isFlexMin) {
		this.$supers('setFlexSizeW_', arguments);
		if (!isFlexMin && this.getAlign() == 'start') {
			var cave = this.$n('cave');
			if (cave)
				cave.style.width = jq.px0(zk(this.$n()).contentWidth());
		}
	},
	
	inPanelMold: function(){
		return this._mold == 'panel';
	},
	
	onChildAdded_: function(){
		this.$supers('onChildAdded_', arguments);
		if (this.inPanelMold()) 
			this.rerender();
	},
	onChildRemoved_: function(){
		this.$supers('onChildRemoved_', arguments);
		if (!this.childReplacing_ && this.inPanelMold())
			this.rerender();
	}	
});

zkreg('zul.wgt.Toolbar',true);zk._m={};
zk._m['panel']=
function (out) {
	out.push('<div ', this.domAttrs_(), '><table id="', this.uuid,
			'-cave" class="', this.$s('content'), ' ', this.$s(this.getAlign()),
			'"', zUtl.cellps0, '><tbody>');
	if ('horizontal' == this.getOrient()) {
		out.push("<tr>");
		for (var w = this.firstChild; w; w = w.nextSibling) {
			out.push('<td class="', this.$s('horizontal'), '">');
			w.redraw(out);
			out.push("</td>");
		}
		out.push("</tr>");
	} else {
		for (var w = this.firstChild; w; w = w.nextSibling) {
			out.push('<tr><td class="', this.$s('vertical'), '">');
			w.redraw(out);
			out.push('</td></tr>');
		}
	}
	out.push('</tbody></table><div class="z-clear"></div></div>');
}

;zk._m['default']=
function (out) {
	
	var space = 'vertical' != this.getOrient() ? (zk.ie9 ? '<span></span>' : '') : '<br/>';
		
	out.push('<div ', this.domAttrs_(), '><div id="', this.uuid, '-cave"',
			' class="', this.$s('content'), ' ', this.$s(this.getAlign()), '" >');
	
	for (var w = this.firstChild; w; w = w.nextSibling) {
		out.push(space);
		w.redraw(out);
	}
	out.push('</div><div class="z-clear"></div></div>');
}
;zkmld(zk._p.p.Toolbar,zk._m);
(function () {
	
	function _initUpld(wgt) {
		zWatch.listen({onSize: wgt});
		var v;
		if (v = wgt._upload)
			wgt._uplder = new zul.Upload(wgt, null, v);
	}
	
	function _cleanUpld(wgt) {
		var v;
		if (v = wgt._uplder) {
			zWatch.unlisten({onSize: wgt});
			wgt._uplder = null;
			v.destroy();
		}
	}
	

zul.wgt.Toolbarbutton = zk.$extends(zul.LabelImageWidget, {
	_orient: 'horizontal',
	_dir: 'normal',
	_mode:'default',
	_checked: false,
	

	$define: {
		
		
		mode: function(mode) {
			this.rerender();
		},
		
		
		checked: function(val) {
			if (this.desktop && this._mode == 'toggle')
				jq(this.$n())[val ? 'addClass' : 'removeClass'](this.$s('checked'));
		},
		
		
		disabled: [
			
			
			function (v, opts) {
		    	if (opts && opts.adbs)
		    		
		    		this._adbs = true;	
		    	else if (!opts || opts.adbs === undefined)
		    		
		    		this._adbs = false;	
		    	if (!v) {
		    		if (this._adbs)
		    			
		    			this._adbs = false;
		    		else if (opts && opts.adbs === false)
		    			
		    			return this._disabled;
		    	}
		    	return v;
			}, 
			function (v, opts) {
				this.rerender(opts && opts.skip ? -1 : 0); 
			}
		],
		
		
		href: null,
		
		
		target: null,
		
		
		dir: _zkf = function () {
			this.updateDomContent_();
		},
		
		
		orient: _zkf,
		
		
		tabindex: function (v) {
			var n = this.$n();
			if (n) n.tabIndex = v||'';
		},
		
		
		autodisable: null,
		
		
		upload: function (v) {
			var n = this.$n();
			if (n) {
				_cleanUpld(this);
				if (v && v != 'false' && !this._disabled)
					_initUpld(this);
			}
		}
	},

	
	getTextNode: function () {
		return this.$n('cnt');
	},
	bind_: function(){
		this.$supers(zul.wgt.Toolbarbutton, 'bind_', arguments);
		if (!this._disabled) {
			var n = this.$n();
			this.domListen_(n, 'onFocus', 'doFocus_')
				.domListen_(n, 'onBlur', 'doBlur_');
		}
		if (!this._disabled && this._upload) _initUpld(this);
	},
	unbind_: function(){
		_cleanUpld(this);
		var n = this.$n();
		this.domUnlisten_(n, 'onFocus', 'doFocus_')
			.domUnlisten_(n, 'onBlur', 'doBlur_');

		this.$supers(zul.wgt.Toolbarbutton, 'unbind_', arguments);
	},
	domContent_: function(){
		var label = zUtl.encodeXML(this.getLabel()), img = this.getImage(),
			iconSclass = this.domIcon_();
		if (!img && !iconSclass)
			return label;
		
		if (!img) img = iconSclass;
		else img = '<img src="' + img + '" align="absmiddle" />'
					+ (iconSclass ? ' ' + iconSclass : '');
		
		var space = label? 'vertical' == this.getOrient() ? '<br/>' : '&nbsp;' : '';
		return this.getDir() == 'reverse' ? label + space + img : img + space + label;
	},
	domClass_: function(no){
		var scls = [this.$supers('domClass_', arguments)], 
			zcls = this.getZclass(),
			nozcls = (!no || !no.zclass);
		
		if(this._mode == 'toggle' && this._checked && nozcls && zcls ) {
			scls.push(' ', this.$s('checked'));
		}
		
		return scls.join('');
	},
	domAttrs_: function(no){
		var attr = this.$supers('domAttrs_', arguments),
			v = this.getTabindex();
		if (this._disabled)
			attr += ' disabled="disabled"';
		if (v)
			attr += ' tabIndex="' + v + '"';
		return attr;
	},
	onSize: function () {
		if (this._uplder)
			this._uplder.sync();
	},
	doClick_: function(evt){
		if (!this._disabled) {
			if (!this._upload)
				zul.wgt.ADBS.autodisable(this);
			else if (!zk.ie || zk.ie > 10) 
				this._uplder.openFileDialog();
			
			this.fireX(evt);
			
			if (!evt.stopped) {
				var href = this._href,
					isMailTo = href ? href.toLowerCase().startsWith('mailto:') : false;
					
				if (href) {
					
					if (isMailTo) {
						var ifrm = jq.newFrame('mailtoFrame', href, null);
						jq(ifrm).remove();
					} else {
						zUtl.go(href, {target: this._target || (evt.data.ctrlKey ? '_blank' : '')});
					}
				}
				
				this.$super('doClick_', evt, true);
				
				if (this._mode == 'toggle') {
					this.setChecked(!this.isChecked());
					this.fire('onCheck', this.isChecked());
				}
			}
		}
	}
});
})();
zkreg('zul.wgt.Toolbarbutton');zk._m={};
zk._m['default']=
function (out) {
	out.push('<a', this.domAttrs_(), '><span id="', this.uuid, '-cnt"',
			this.domTextStyleAttr_(), 'class="', this.$s('content'), '">',
			this.domContent_(), '</span></a>');
}

;zk._m['toggle']=[zk._p.p.Toolbarbutton,'default'];zkmld(zk._p.p.Toolbarbutton,zk._m);

zul.wgt.Image = zk.$extends(zul.Widget, {
	$define: {
		
		
		src: function (v) {
			if (v && this._preloadImage) zUtl.loadImage(v);
			var n = this.getImageNode();
			if (n) n.src = v || '';
		},
		
		
		hover: null,
		
		
		align: function (v) {
			var n = this.getImageNode();
			if (n) n.align = v || '';
		},
		
		
		hspace: function (v) {
			var n = this.getImageNode();
			if (n) n.hspace = v;
		},
		
		
		vspace: function (v) {
			var n = this.getImageNode();
			if (n) n.vspace = v;
		}
	},
	
	getImageNode: function () {
		return this.$n();
	},

	
	doMouseOver_: function () {
		var hover = this._hover;
		if (hover) {
			var img = this.getImageNode();
			if (img) img.src = hover;
		}
		this.$supers('doMouseOver_', arguments);
	},
	doMouseOut_: function () {
		if (this._hover) {
			var img = this.getImageNode();
			if (img) img.src = this._src || '';
		}
		this.$supers('doMouseOut_', arguments);
	},
	domAttrs_: function (no) {
		var attr = this.$supers('domAttrs_', arguments);
		if (!no || !no.content)
			attr += this.contentAttrs_();
		return attr;
	},
	
	contentAttrs_: function () {
		var attr = ' src="' + (this._src || '') + '"', v;
		if (v = this._align) 
			attr += ' align="' + v + '"';
		if (v = this._hspace) 
			attr += ' hspace="' + v + '"';
		if (v = this._vspace) 
			attr += ' vspace="' + v + '"';
		return attr;
	}
});

zkreg('zul.wgt.Image');zk._m={};
zk._m['alphafix']=
function (out) {
	out.push('<img', this.domAttrs_(), '/>');
}
;zk._m['default']=[zk._p.p.Image,'alphafix'];zkmld(zk._p.p.Image,zk._m);

zul.wgt.Imagemap = zk.$extends(zul.wgt.Image, {
	$define: {
		width: function (v) { 
			var n = this.getImageNode();
			if (n)
				n.style.width = v;
		},
		height: function (v) { 
			var n = this.getImageNode();
			if (n)
				n.style.height = v;
		}
	},
	bind_: function () {
		this.$supers(zul.wgt.Imagemap, 'bind_', arguments);

		if (!jq('#zk_hfr_')[0])
			jq.newFrame('zk_hfr_', null,
				zk.webkit ? 'position:absolute;top:-1000px;left:-1000px;width:0;height:0;display:inline'
					: null);
			
			
	},

	
	getImageNode: function () {
		return this.$n('real');
	},
	getCaveNode: function () {
		return this.$n('map');
	},
	doClick_: function (evt) {
		
		
	},
	onChildAdded_: function () {
		this.$supers('onChildAdded_', arguments);
		if (this.desktop && this.firstChild == this.lastChild) 
			this._fixchd(true);
	},
	onChildRemoved_: function () {
		this.$supers('onChildRemoved_', arguments);
		if (this.desktop && !this.firstChild) 
			this._fixchd(false);
	},
	_fixchd: function (bArea) {
		var mapid = this.uuid + '-map',
			img = this.getImageNode();
		img.useMap = bArea ? '#' + mapid : '';
		img.isMap = !bArea;
	},
	contentAttrs_: function () {
		var attr = this.$supers('contentAttrs_', arguments),
			w = this._width,
			h = this._height;
		if (w || h) { 
			attr += ' style="';
			if (w)
				attr += 'width:' + w + ';'
			if (h)
				attr += 'height:' + h + ';'
			attr += '"';
		}
		return attr +(this.firstChild ? ' usemap="#' + this.uuid + '-map"':
			' ismap="ismap"');
	},

	
	fromPageCoord: function (x, y) {
		
		var ofs = zk(this.getImageNode()).revisedOffset();
		return [x - ofs[0], y - ofs[1]];
	},

	_doneURI: function () {
		var Imagemap = zul.wgt.Imagemap,
			url = Imagemap._doneURI;
		return url ? url:
			Imagemap._doneURI = zk.IMAGEMAP_DONE_URI ? zk.IMAGEMAP_DONE_URI:
				zk.ajaxURI('/web/zul/html/imagemap-done.html', {desktop:this.desktop, au:true});
	}
},{
	
	onclick: function (href) {
		if (zul.wgt.Imagemap._toofast()) return;

		var j = href.indexOf('?');
		if (j < 0) return;

		var k = href.indexOf('?', ++j);
		if (k < 0 ) return;

		var id = href.substring(j, k),
			wgt = zk.Widget.$(id);
		if (!wgt) return; 

		j = href.indexOf(',', ++k);
		if (j < 0) return;

		wgt.fire('onClick', {
			x: zk.parseInt(href.substring(k, j)),
			y: zk.parseInt(href.substring(j + 1))
		}, {ctl:true});
	},
	_toofast: function () {
		if (zk.gecko) { 
			var Imagemap = zul.wgt.Imagemap,
				now = jq.now();
			if (Imagemap._stamp && now - Imagemap._stamp < 800)
				return true;
			Imagemap._stamp = now;
		}
		return false;
	}
});

zkreg('zul.wgt.Imagemap');zk._m={};
zk._m['alphafix']=
function (out) {
	var uuid = this.uuid, mapid = uuid + '-map';
	out.push('<span', this.domAttrs_({content:1}), '><img id="',
		uuid, '-real"', this.contentAttrs_(),
		'/><map name="', mapid, '" id="', mapid, '">');

	for (var w = this.firstChild; w; w = w.nextSibling)
		w.redraw(out);

	out.push('</map></span>');
}

;zk._m['default']=[zk._p.p.Imagemap,'alphafix'];zkmld(zk._p.p.Imagemap,zk._m);

zul.wgt.Area = zk.$extends(zk.Widget, {
	$define: {
		
		
		shape: function (v) {
			var n = this.$n();
			if (n) n.shape = v || '';
		},
		
		
		coords: function (v) {
			
			var n = this.$n();
			if (n) n.coords = v || '';
		}
	},

	
	doClick_: function (evt) {
		if (zul.wgt.Imagemap._toofast()) return;

		var area = this.id || this.uuid;
		this.parent.fire('onClick', {area: area}, {ctl:true});
		evt.stop();
	},

	domAttrs_: function (no) {
		var attr = this.$supers('domAttrs_', arguments)
			+ ' href="javascript:;"', v;
		if (v = this._coords) 
			attr += ' coords="' + v + '"';
		if (v = this._shape) 
			attr += ' shape="' + v + '"';
		return attr;
	}
});

zkreg('zul.wgt.Area');zk._m={};
zk._m['default']=
function (out) {
	out.push('<area', this.domAttrs_(), '/>');
}
;zkmld(zk._p.p.Area,zk._m);

zul.wgt.Chart = zk.$extends(zul.wgt.Imagemap, {
});

zkreg('zul.wgt.Chart');zk._m={};
zk._m['default']=[zk._p.p.Imagemap,'alphafix'];zkmld(zk._p.p.Chart,zk._m);

zul.wgt.Captcha = zk.$extends(zul.wgt.Image, {
});

zkreg('zul.wgt.Captcha');zk._m={};
zk._m['default']=[zk._p.p.Image,'alphafix'];zkmld(zk._p.p.Captcha,zk._m);

zul.wgt.Progressmeter = zk.$extends(zul.Widget, {
	_value: 0,

	$define: {
		
		
		value: function () {
			if(this.$n()) 
				this._fixImgWidth();
		}
	},

	
	_fixImgWidth: _zkf = function() {
		var n = this.$n(), 
			img = this.$n('img');
		if (img) {
			
			if (zk(n).isRealVisible()) { 
				var $img = jq(img);
				$img.animate({
					width: Math.round((jq(n).innerWidth() * this._value) / 100) + 'px'
				}, $img.zk.getAnimationSpeed('slow'));
			}
		}
	},
	onSize: _zkf,
	bind_: function () {
		this.$supers(zul.wgt.Progressmeter, 'bind_', arguments); 
		this._fixImgWidth(this._value);
		zWatch.listen({onSize: this});
	},
	unbind_: function () {
		zWatch.unlisten({onSize: this});
		this.$supers(zul.wgt.Progressmeter, 'unbind_', arguments);
	},
	setWidth : function (val){
		this.$supers('setWidth', arguments);
		this._fixImgWidth();
	}
});


zkreg('zul.wgt.Progressmeter');zk._m={};
zk._m['default']=
function (out) {
	out.push('<div', this.domAttrs_(), '><span id="',
			this.uuid,'-img"', 'class="', this.$s('image'),'"></span></div>');
}
;zkmld(zk._p.p.Progressmeter,zk._m);

zul.wgt.Fileupload = zk.$extends(zul.wgt.Button, {
	getZclass: function () { 
		return this._zclass == null ? 'z-button' : this._zclass;
	}
});

zkreg('zul.wgt.Fileupload');
(function() {
	
	
	function _setCloseTimer (wgt) {
		if (!wgt._tidclose)
			wgt._tidclose = setTimeout(function() {
				if (!wgt._bover) {
					if (wgt._autodrop && wgt.isOpen())
						wgt.close({sendOnOpen: true});
				}
				wgt._tidclose = null;
			}, 200);
	}

	function _fireOnOpen (wgt, opts, o) {
		if (opts && opts.sendOnOpen)
			wgt.fire('onOpen', {open:o, value: wgt.getLabel()}, {rtags: {onOpen: 1}});
	}
	
	function _attachPopup(wgt, bListen) {
		
		if (!wgt._oldppclose) {
			var pp = wgt.firstChild;
			if (pp) {
				var $pp = jq(pp),
					wd = jq(wgt).width();
				if($pp.width() < wd) {
					$pp.width(wd - zk(pp).padBorderWidth());

					
					pp.fire(pp.firstChild);
					var openInfo = pp._openInfo;
					if (openInfo) {
						pp.position.apply(pp, openInfo);
						
						
					}
				}
			}
			wgt._oldppclose = pp.close;
			
			if (bListen)
				wgt.domListen_(pp, 'onMouseOver')
					.domListen_(pp, 'onMouseOut');

			
			pp.close = function (opts) {
				wgt._oldppclose.apply(pp, arguments);
				_fireOnOpen(wgt, opts, false);

				if (bListen)
					wgt.domUnlisten_(pp, 'onMouseOver')
						.domUnlisten_(pp, 'onMouseOut');
				pp.close = wgt._oldppclose;
				delete wgt._oldppclose;
			}
		}
	}

zul.wgt.Combobutton = zk.$extends(zul.wgt.Button, {
	$define: {
		
		
		autodrop: null
	},
	getZclass: function () {
		return 'z-combobutton';
	},
	domContent_: function () {
		var label = '<span id="' + this.uuid + '-txt" class="' + this.$s('text') + '">' 
		 	+ zUtl.encodeXML(this.getLabel()) + '</span>',
			img = this.getImage(),
			iconSclass = this.domIcon_();
		if (!img && !iconSclass) return label;

		if (!img) img = iconSclass;
		else
			img = '<img class="' + this.$s('image') + '" src="' + img + '" />'
				+ (iconSclass ? ' ' + iconSclass : '');
		var space = "vertical" == this.getOrient() ? '<br/>': ' ';
		return this.getDir() == 'reverse' ?
			label + space + img: img + space + label;
	},
	domClass_: function (no) {
		var cls = this.$supers(zul.wgt.Combobutton, 'domClass_', arguments);
		if (!this._isDefault())
			cls += ' z-combobutton-toolbar';
		return cls;
	},
	_isDefault: function () {
		return this._mold == 'default';
	},
	
	isOpen: function () {
		var pp = this.firstChild;
		return pp && pp.isOpen();
	},
	
	setOpen: function (b, opts) {
		if (!this._disabled && !zk.animating())
			
			this[b ? 'open' : 'close'](opts || {});
	},
	renderInner_: function (out) {
		for (var w = this.firstChild; w; w = w.nextSibling)
			w.redraw(out);
	},
	isTableLayout_: function () {
		return true;
	},
	unbind_: function () {
		var pp;
		
		if ((pp = this.firstChild)
			&& (pp = pp.$n()))
			this.domUnlisten_(pp, 'onMouseOver')
				.domUnlisten_(pp, 'onMouseOut');
		this.$supers('unbind_', arguments);
	},
	doFocus_: function (evt) {
		if (this == evt.target)
			
			this.$supers('doFocus_', arguments);
	},

	
	open: function (opts) {
		var pp = this.firstChild;
		if (pp && !this.isOpen()) {
			if (pp.$instanceof(zul.wgt.Popup)) {
				pp.open(this.uuid, null, 'after_start', opts);
				_fireOnOpen(this, opts, true);
			}
			_attachPopup(this, !pp.$instanceof(zul.wgt.Menupopup));
		}
	},
	
	close: function (opts) {
		if (this.isOpen())
			this.firstChild.close(opts);
	},

	doClick_: function (evt) {
		var d = evt.domTarget;
		
		
		if (d) {
			
			
			var open = !this.isOpen();
			if (this == evt.target)
				if (this.$n('btn') == d || this.$n('icon') == d || !open)
					this.setOpen(open, {sendOnOpen: true});
				else
					this.$supers('doClick_', arguments);
		}
	},
	doMouseDown_: function (evt) {
		if (this == evt.target)
			
			this.$supers('doMouseDown_', arguments);
	},
	doMouseOver_: function (evt) {
		this._bover = true;
		if (this == evt.target) {
			var d = evt.domTarget;
			
			if (this._autodrop && (this.$n('btn') == d || this.$n('icon') == d) && !this.isOpen())
				this.open({sendOnOpen: true});
			this.$supers('doMouseOver_', arguments);
		}
	},
	doMouseOut_: function (evt) {
		this._bover = false;
		_setCloseTimer(this);
		this.$supers('doMouseOut_', arguments);
	},
	_doMouseOver: function (evt) { 
		
		this._bover = true;
	},
	_doMouseOut: function (evt) { 
		
		this._bover = false;
		_setCloseTimer(this);
	},
	ignoreDescendantFloatUp_: function (des) {
		return des && des.$instanceof(zul.wgt.Popup);
	},
	
	
	
	rerender: function(skipper) {
		if (this.isOpen()) {
			this.close();
		}
		this.$supers('rerender', arguments);
	}
});
})();
zkreg('zul.wgt.Combobutton');zk._m={};
zk._m['default']=
function (out) {
	var tabi = this._tabindex,
		uuid = this.uuid;
	
	out.push('<span ', this.domAttrs_());
	
	if (this._disabled)
		out.push(' disabled="disabled"');
	
	out.push(' ><span id="', uuid, '-real" class="', this.$s('content') ,'"');
	
	if (tabi)
		out.push(' tabindex="', tabi, '"');
	
	out.push('>', this.domContent_(), 
			 '<span id="', uuid, '-btn" class="', this.$s('button'), '">', 
				'<i id="', uuid, '-icon" class="', this.$s('icon'), ' z-icon-caret-down"></i>', 
			 '</span></span>');
	
	if (this.firstChild)
		this.firstChild.redraw(out);
	
	out.push('</span>');
}
;zk._m['toolbar']=[zk._p.p.Combobutton,'default'];zkmld(zk._p.p.Combobutton,zk._m);

zul.wgt.Selectbox = zk.$extends(zul.Widget, {
	$define: {
		
		
		tabindex: function (tabindex) {
			var n = this.$n();
			if (n) n.tabindex = tabindex || '';
		},
		
		
		selectedIndex: function (selectedIndex) {
			var n = this.$n();
			if (n)
				n.selectedIndex = selectedIndex;
		},
		
		
		disabled: function (disabled) {
			var n = this.$n();
			if (n) n.disabled = disabled ? 'disabled' : '';
		},
		
		
		name: function (name) {
			var n = this.$n();
			if (n) n.name = name;
		}
	},
	_fixSelIndex: function () {
		if (this._selectedIndex < 0)
			this.$n().selectedIndex = -1;
	},
	bind_: function () {
		this.$supers(zul.wgt.Selectbox, 'bind_', arguments);
		var n = this.$n();
		this.domListen_(n, 'onChange')
			.domListen_(n, 'onFocus', 'doFocus_')
			.domListen_(n, 'onBlur', 'doBlur_');
		
		if (!zk.gecko) {
			var fn = [this,  this._fixSelIndex];
			zWatch.listen({onRestore: fn, onVParent: fn});
		}

		this._fixSelIndex();
	},
	unbind_: function () {
		var n = this.$n();
		this.domUnlisten_(n, 'onChange')
			.domUnlisten_(n, 'onFocus', 'doFocus_')
			.domUnlisten_(n, 'onBlur', 'doBlur_')
			.$supers(zul.wgt.Selectbox, 'unbind_', arguments);

		var fn = [this,  this._fixSelIndex];
		zWatch.unlisten({onRestore: fn, onVParent: fn});
	},
	_doChange: function (evt) {
		var n = this.$n(),
			v = n.selectedIndex;
		if (zk.opera) n.selectedIndex = v; 
		if (this._selectedIndex == v)
			return;
		this.setSelectedIndex(n.selectedIndex);
		this.fire('onSelect', n.selectedIndex);
	},
	
	doBlur_: function (evt) {
		this._doChange(evt);
		return this.$supers('doBlur_', arguments); 		
	},
	
	beforeCtrlKeys_: function (evt) {
		this._doChange(evt);
	},
	domAttrs_: function () {
		var v;
		return this.$supers('domAttrs_', arguments)
			+ (this.isDisabled() ? ' disabled="disabled"' :'')
			+ ((v=this.getSelectedIndex()) > -1 ? ' selectedIndex="' + v + '"': '')
			+ ((v=this.getTabindex()) ? ' tabindex="' + v + '"': '')
			+ ((v=this.getName()) ? ' name="' + v + '"': '');
	}
});
zkreg('zul.wgt.Selectbox');zk._m={};
zk._m['default']=
function (out) {
	out.push('<select', this.domAttrs_(), '>');
	var s = $eval(this.items) || [] ;
	for (var i = 0, j = s.length; i < j; i++) {
		out.push('<option');
		if (this._selectedIndex > -1 && this._selectedIndex == i)
			out.push(' selected="selected"');
		out.push('>', s[i], '</option>');
	}
	out.push('</select>');
}
;zkmld(zk._p.p.Selectbox,zk._m);
(function () {
	var _iconMap = {
		'warning': 'z-icon-exclamation-circle',
		'info': 'z-icon-info-circle',
		'error': 'z-icon-times-circle'
	};
	var _dirMap = {
		'u': 'up',
		'd': 'down',
		'l': 'left',
		'r': 'right'
	};

zul.wgt.Notification = zk.$extends(zul.wgt.Popup, {
	
	$init: function (msg, opts) {
		this.$supers(zul.wgt.Notification, '$init', arguments);
		this._msg = msg;
		this._type = opts.type;
		this._ref = opts.ref;
		this._dur = opts.dur;
		this._closable = opts.closable;
	},
	redraw: function (out) {
		var uuid = this.uuid,
			icon = this.$s('icon');
		out.push('<div', this.domAttrs_(), '>');
		if (this._ref) 
			out.push('<div id="', uuid, '-p" class="', this.$s('pointer'), '"></div>');
		out.push('<i id="', uuid, '-icon" class="', icon, ' ', (_iconMap[this._type]), '"></i>');
		out.push('<div id="', uuid, '-cave" class="', this.$s('content'), '">',
				this._msg, '</div>');
		if (this._closable)
			out.push('<div id="', uuid, '-cls" class="', this.$s('close'),
					'"><i id="', uuid, '-clsIcon" class="', icon, ' z-icon-times"></i></div>');
		out.push('</div>'); 
	},
	domClass_: function (no) {
		var type = this._type,
			ref = this._ref,
			s = this.$supers(zul.wgt.Notification, 'domClass_', arguments);
		if (type)
			s += ' ' + this.$s(zUtl.encodeXML(type));
		return s;
	},
	doClick_: function (evt) {
		var p = evt.domTarget;
		if (p == this.$n('cls') || p == this.$n('clsIcon')) 
			this.close();
		else
			this.$supers('doClick_', arguments);
	},
	onFloatUp: function(ctl, opts) {
		if (opts && opts.triggerByFocus) 
			return;
		if (!this.isVisible())
			return;
		var wgt = ctl.origin;
		for (var floatFound; wgt; wgt = wgt.parent) {
			if (wgt == this) {
				if (!floatFound) 
					this.setTopmost();
				return;
			}
			if (wgt == this.parent && wgt.ignoreDescendantFloatUp_(this))
				return;
			floatFound = floatFound || wgt.isFloating_();
		}
		if (!this._closable && this._dur <= 0)
			this.close({sendOnOpen:true});
	},
	open: function (ref, offset, position, opts) {
		this.$supers(zul.wgt.Notification, 'open', arguments);
		this._fixarrow(ref); 
		zk(this).redoCSS(-1, {'fixFontIcon': true});
	},
	position: function (ref, offset, position, opts) {
		this.$supers(zul.wgt.Notification, 'position', arguments);
		this._fixarrow(ref); 
	},
	_posInfo: function (ref, offset, position, opts) {
		this._fixPadding(position);
		return this.$supers(zul.wgt.Notification, '_posInfo', arguments);
	},
	_fixPadding: function (position) {
		var p = this.$n('p');
		if (!p)
			return;
		var n = this.$n(),
			pw = 2 + (zk(p).borderWidth() / 2) || 0,
			ph = 2 + (zk(p).borderHeight() / 2) || 0;
		
		n.style.padding = '0';
		
		switch (position) {
		case "before_start":
		case "before_center":
		case "before_end":
			this._dir = 'd';
			n.style.paddingBottom = ph + 'px';
			break;
		case "after_start":
		case "after_center":
		case "after_end":
			this._dir = 'u';
			n.style.paddingTop = ph + 'px';
			break;
		case "end_before":
		case "end_center":
		case "end_after":
			this._dir = 'l';
			n.style.paddingLeft = pw + 'px';
			break;
		case "start_before":
		case "start_center":
		case "start_after":
			this._dir = 'r';
			n.style.paddingRight = pw + 'px';
			break;
		case "top_left":
		case "top_center":
		case "top_right":
		case "middle_left":
		case "middle_center":
		case "middle_right":
		case "bottom_left":
		case "bottom_center":
		case "bottom_right":
		case "overlap":
		case "overlap_end":
		case "overlap_before":
		case "overlap_after":
			this._dir = 'n';
			break;
		
		default:
			this._dir = 'n';
		}
	},
	_fixarrow: function (ref) {
		var p = this.$n('p');
		if (!p)
			return;
		
		var pzcls = this.$s('pointer'),
			n = this.$n(),
			refn = ref.$n(),
			dir = this._dir,
			zkp = zk(p),
			pw = zkp.borderWidth(),
			ph = zkp.borderHeight(),
			nOffset = zk(n).revisedOffset(),
			refOffset = zk(refn).revisedOffset(),
			arrXOffset = (refn.offsetWidth - pw) / 2,
			arrYOffset = (refn.offsetHeight - ph) / 2;
		if (dir != 'n') {
			
			if (dir == 'u' || dir == 'd') {
				var b = dir == 'u',
					l1 = (n.offsetWidth - pw) / 2 || 0,
					l2 = refOffset[0] - nOffset[0] + arrXOffset || 0;
				p.style.left = (refn.offsetWidth >= n.offsetWidth ? l1 : l2) + 'px'; 
				p.style[b ? 'top' : 'bottom'] = ((2 - ph / 2) || 0) + 'px';
				p.style[b ? 'bottom' : 'top'] = '';
			} else {
				var b = dir == 'l',
					t1 = (n.offsetHeight - ph) / 2 || 0,
					t2 = refOffset[1] - nOffset[1] + arrYOffset || 0;
				p.style.top = (refn.offsetHeight >= n.offsetHeight ? t1 : t2) + 'px'; 
				p.style[b ? 'left' : 'right'] = ((2 - pw / 2) || 0) + 'px';
				p.style[b ? 'right' : 'left'] = '';
			}
			
			p.className = pzcls + (_dirMap[dir] ? ' ' + this.$s(_dirMap[dir]) : '');
			jq(p).show();
			
		} else {
			p.className = pzcls;
			jq(p).hide();
		}
	},
	openAnima_: function (ref, offset, position, opts) {
		var self = this;
		jq(this.$n()).fadeIn(500, function () {
			self.afterOpenAnima_(ref, offset, position, opts);
		});
	},
	closeAnima_: function (opts) {
		var self = this;
		jq(this.$n()).fadeOut(500, function () {
			self.afterCloseAnima_(opts);
		});
	},
	afterCloseAnima_: function (opts) {
		this.detach();
	}
}, {
	
	
	show: function (msg, pid, opts) {
		if (!opts)
			opts = {};
		var parent = zk.Widget.$(pid),
			ref = opts.ref,
			pos = opts.pos,
			dur = opts.dur,
			ntf = new zul.wgt.Notification(msg, opts),
			off = opts.off;
		
		
		
		if (!pos && !off)
			pos = ref ? "end_center" : "middle_center";
		
		if (!parent) {
			
			parent = zk.Desktop.$().firstChild;
		}
		parent.appendChild(ntf);
		ntf.open(ref, off, pos);
		
		
		if (dur > 0)
			setTimeout(function () {
				if (ntf.desktop)
					ntf.close();
			}, dur);
	}
	
});

})();
zkreg('zul.wgt.Notification');
}finally{zk.setLoaded(zk._p.n);}});zk.setLoaded('zul.wgt',1);